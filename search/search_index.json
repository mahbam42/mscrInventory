{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MSCR Inventory App Documentation","text":"<p>Welcome to the official documentation for the MSCR Inventory App \u2014 a streamlined, relational, highly customizable inventory and recipe management system built for caf\u00e9s, beverage programs, and specialty operations.</p> <p>This guide includes everything you need to:</p> <ul> <li>Manage ingredients, recipes, and inventory  </li> <li>Import data from Square and Shopify  </li> <li>Reconcile unmapped items  </li> <li>Configure modifier behavior  </li> <li>Generate reports and forecasting insights  </li> <li>Administer user roles and permissions  </li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running with the core features:</p> <ul> <li>Quick Start Overview</li> <li>Dashboard Layout</li> <li>Adding &amp; Editing Ingredients</li> <li>Creating &amp; Editing Recipes</li> <li>Upload Square CSV</li> </ul>"},{"location":"#daily-operations","title":"\ud83d\udcca Daily Operations","text":"<ul> <li>View low-stock items  </li> <li>Perform bulk stock updates  </li> <li>Review modifiers and recipes  </li> <li>Reconcile unmapped imports  </li> <li>Monitor orders from Square and Shopify  </li> </ul> <p>Key sections:</p> <ul> <li>Ingredients </li> <li>Recipes </li> <li>Inventory </li> <li>Orders Dashboard</li> </ul>"},{"location":"#power-features","title":"\ud83e\uddf0 Power Features","text":""},{"location":"#imports-mapping","title":"Imports &amp; Mapping","text":"<p>The app includes a robust matching engine with support for:</p> <ul> <li>Square CSVs  </li> <li>Shopify data  </li> <li>Modifier analysis and aliasing  </li> <li>Unmapped-item reconciliation  </li> <li>Bulk creation and linking  </li> </ul> <p>\u27a1\ufe0f View: Unmapped Items Dashboard</p>"},{"location":"#reporting-analytics","title":"\ud83d\udcc8 Reporting &amp; Analytics","text":"<p>Gain clarity on:</p> <ul> <li>Cost of Goods Sold (COGS)  </li> <li>Ingredient usage trends  </li> <li>Inventory valuation  </li> <li>Exportable CSV insights  </li> </ul> <p>Start here: Reporting Overview</p>"},{"location":"#user-management","title":"\ud83d\udc64 User Management","text":"<p>Assign granular permission groups:</p> <ul> <li>Admin  </li> <li>Manager  </li> <li>Barista  </li> <li>Inventory  </li> <li>Pending  </li> </ul> <p>\u27a1\ufe0f Manage users: User Administration</p>"},{"location":"#admin-tools","title":"\ud83d\udee0 Admin Tools","text":"<p>Access advanced features (restricted):</p> <ul> <li>Raw data tables  </li> <li>Import logs  </li> <li>Direct object editing  </li> </ul> <p>\u27a1\ufe0f Django Admin (Restricted Access)</p>"},{"location":"#appendices","title":"\ud83e\udde9 Appendices","text":"<ul> <li>Appendix A: Manual Testing </li> <li>Appendix B: Unmapped Items Usage </li> <li>Appendix C: Platform Comparison</li> </ul>"},{"location":"#future-roadmap","title":"\ud83d\uddfa Future Roadmap","text":"<p>Explore upcoming planned features:</p> <ul> <li>DoorDash integration  </li> <li>Square API sync  </li> <li>Improved reporting dashboards  </li> <li>Vendor automation support  </li> </ul> <p>\u27a1\ufe0f Read the Roadmap</p>"},{"location":"01_Introduction/01_introduction/","title":"Introduction","text":"<p>The MSCR Inventory App provides a unified, streamlined workflow for managing ingredients, recipes, products, orders, inventory, and imports across caf\u00e9 and retail environments. It is designed to support both daily operations and long-term data accuracy, while remaining accessible to non-technical staff.</p> <p>This manual describes the operational workflow for managers and authorized users who handle inventory updates, recipe maintenance, product management, user permissions, and data reconciliation through the web interface.</p> <p>This guide is written for general staff, supervisors, and managers. Developer-only setup, installation, and technical notes have been removed from the main body of the manual and placed into the appendices. The intent is to keep the core documentation focused, practical, and easy to reference during daily operations.</p>"},{"location":"01_Introduction/01_introduction/#architecture-design-notes","title":"Architecture &amp; Design Notes","text":"<p>The MSCR Inventory App is built with Django, HTMX, and Bootstrap, emphasizing clarity, maintainability, and minimal dependencies. These architectural choices allow the system to remain fast, flexible, and stable across multiple environments.</p> <p>Key design principles:</p> <ul> <li> <p>Minimal Dependencies:   Uses Django, HTMX, and Bootstrap \u2014 no frontend frameworks required.  </p> </li> <li> <p>Relational, Structured Data Model:   Ingredients, products, recipes, modifiers, and packaging are fully relational to ensure consistent reporting and precise cost calculations.</p> </li> <li> <p>CSV-Driven Integration:   CSV import/export serves both as operational tooling and an internal API for external systems (automation scripts, third-party integrations).</p> </li> <li> <p>Square &amp; Shopify Integration:   Shopify integration is complete; DoorDash integration is in progress.   Direct Square and DoorDash API syncing (beyond CSV uploads) is planned.</p> </li> <li> <p>Role-Based Views:   Users only see relevant features based on their assigned permission group, keeping the UI clean and reducing confusion.</p> </li> <li> <p>HTMX-Based UI:   High-responsiveness without page reloads: edits, modals, updates, and lists refresh dynamically for a modern, lightweight interface.</p> </li> </ul>"},{"location":"01_Introduction/01_introduction/#about-this-manual","title":"About This Manual","text":"<p>This manual is organized into the following major parts:</p> <ol> <li>Daily Operations &amp; Dashboards \u2013 overview of the dashboard, navigation systems, and daily workflows.  </li> <li>Core Data Management \u2013 instructions for maintaining ingredients, recipes, products, and stock levels.  </li> <li>Imports &amp; Data Reconciliation \u2013 Square/Shopify import flows, unmapped item resolution, and modifier tools.  </li> <li>Advanced Tools \u2013 reporting, user management, admin access.  </li> <li>Appendices \u2013 manual testing, detailed unmapped item documentation, comparisons, and roadmap.</li> </ol> <p>Each section is written to be self-contained, so users can jump directly to the workflow they're performing.</p>"},{"location":"01_Introduction/01_introduction/#audience","title":"Audience","text":"<p>This manual is intended for:</p> <ul> <li>Managers &amp; Supervisors \u2014 inventory, product, and recipe changes; review reports; manage users.</li> <li>Baristas &amp; Staff \u2014 view-only access; limited editing for ingredients, recipes, and inventory (depending on assigned role).</li> <li>Inventory Personnel \u2014 stock counts, adjustments, and purchasing prep.</li> <li>Admins \u2014 full access including Django Admin.</li> </ul> <p>New users should begin with the Quick Start Overview for a high-level summary of daily responsibilities.</p>"},{"location":"01_Introduction/01_introduction/#responsibilities-safety-notes","title":"Responsibilities &amp; Safety Notes","text":"<p>This application directly influences cost calculations, product-recipe mapping, and overall reporting accuracy. When making updates:</p> <ul> <li>Double-check ingredient names and units before saving.</li> <li>Avoid deleting items that are used elsewhere (use Archive instead).</li> <li>Use Dry Runs when processing imports until you\u2019re confident in the file.</li> <li>Complete or cancel modals before navigating to avoid data loss.</li> <li>Maintain consistent naming conventions for clean imports and reporting.</li> </ul> <p>Following these guidelines ensures clean imports, accurate cost reporting, and smooth cross-system integration.</p>"},{"location":"02_Quickstart/01_Quickstart/","title":"Quick Start Overview \u2013 Daily Tasks","text":"<p>The Quick Start section highlights the most common day-to-day workflows for managers, baristas, and inventory staff. Each task can be completed quickly using the dashboard or the main navigation menus.</p> <p>Use this section as a rapid reference guide when performing routine updates.</p>"},{"location":"02_Quickstart/01_Quickstart/#daily-tasks","title":"Daily Tasks","text":"Task Steps Check inventory levels 1. Open the Dashboard tab.  2. Review the Inventory Summary panel for low-stock or out-of-stock alerts.  3. Click any ingredient name to view or update its stock levels. Add or edit an ingredient 1. Go to Inventory \u2192 Ingredients.  2. Click Add Ingredient or select an existing ingredient.  3. Update name, type, or unit cost.  4. Click Save Changes. Adjust recipe quantities 1. Go to Recipes \u2192 Manage Recipes.  2. Select a recipe and click Edit.  3. Adjust ingredient amounts as needed.  4. Click Save Recipe. Check or update product pricing 1. Go to Products \u2192 Product List.  2. Select a product and choose Edit.  3. Adjust its linked recipe or retail price.  4. Click Save. Review unmapped imports 1. Go to Imports \u2192 Unmapped Items.  2. Review any flagged entries.  3. Match each entry to an existing ingredient, product, or recipe \u2014 or create a new item.  4. Confirm mappings and close the modal."},{"location":"02_Quickstart/01_Quickstart/#notes-best-practices","title":"Notes &amp; Best Practices","text":"<p>NOTE: Changes to a recipe immediately update all products that use that recipe.</p> <p>CAUTION: Avoid deleting ingredients that are used in recipes or products \u2014 deletion can break linked data. Use Archive instead.</p> <p>TIP: Use consistent naming conventions. For example\u2014 \u201cWhole Milk (16oz)\u201d is easier for the importer to match than \u201cMilk - Whole Large Bag\u201d.</p>"},{"location":"02_Quickstart/01_Quickstart/#when-to-use-the-dashboard-vs-navigation-menu","title":"When to Use the Dashboard vs. Navigation Menu","text":"<ul> <li>Use the Dashboard for:</li> <li>Quick adjustments  </li> <li>Recently changed items  </li> <li>Low-stock alerts  </li> <li> <p>Import summaries  </p> </li> <li> <p>Use the Navigation Menu when:</p> </li> <li>Performing structured edits  </li> <li>Searching for specific records  </li> <li>Reviewing full tables of ingredients, recipes, or products  </li> <li>Managing user permissions  </li> </ul>"},{"location":"02_Quickstart/01_Quickstart/#recommended-daily-flow","title":"Recommended Daily Flow","text":"<ol> <li> <p>Log in and check dashboard alerts    Low-stock warnings, unmapped items, recent changes.</p> </li> <li> <p>Review inventory adjustments    Enter new stock from deliveries or update depleted ingredients.</p> </li> <li> <p>Check product and recipe accuracy    Ensure new items imported from Square or Shopify are mapped correctly.</p> </li> <li> <p>Look for cost discrepancies    Ingredients with unusual cost shifts may require updates.</p> </li> <li> <p>Review orders (optional)    Use the Orders Dashboard to review trends, especially custom/named drinks.</p> </li> </ol>"},{"location":"02_Quickstart/01_Quickstart/#who-uses-this-section","title":"Who Uses This Section","text":"<p>This section is most helpful for:</p> <ul> <li>Managers \u2014 ensuring data stays clean and consistent  </li> <li>Inventory staff \u2014 adjusting stock and reviewing deliveries  </li> <li>Baristas \u2014 checking recipe details or confirming ingredient availability  </li> </ul>"},{"location":"03_Navigation/01_DashboardLayout/","title":"Dashboard Layout","text":"<p>The Dashboard is the landing page after login. It summarizes recent activity and highlights key areas that may require attention.</p> <ul> <li>Inventory Summary: Displays total ingredient count and alerts for low-stock or unmapped items.</li> <li>Top Name-Your-Drink links directly into the Orders Dashboard filtered by the correct preset. Use this feature to: - Identify popular recurring custom drink names - Validate whether new recipes or modifiers should be created - Spot trends in seasonal or special\u2011request beverages</li> <li>Recent Imports: Shows the latest CSV, Square, or Shopify import sessions with timestamps and status indicators.  </li> <li>Quick Actions Panel: Shortcuts for adding ingredients, updating recipes, or opening import modals.  </li> <li>Search Bar: Filters items by name, type, or category throughout the app.  </li> <li>Notifications Banner: Displays system messages, successful saves, or warnings about incomplete data.  </li> </ul> <p>NOTE: Items highlighted in red indicate missing data or mapping conflicts. Clicking an item opens its detail view.</p>"},{"location":"03_Navigation/02_NavigationMenu/","title":"Navigation Menu","text":"<p>The navigation menu appears at the top of the screen and contains the primary sections of the app. By default every signed-in user sees the following links:</p> Menu Purpose Dashboard Summaries and quick links to recent activity. Imports Run import sessions, resolve unmapped items, and explore modifiers. Orders Unified Shopify + Square order history. Recipes View and edit recipe structures. Ingredients Manage ingredient definitions and costing inputs. Inventory Review inventory dashboards, counts, and archive history. <p>Additional entries, appear based on permissions, rendered inside the secondary admin menu when a user has the appropriate Django permissions:</p> Menu Purpose Reporting visible when the user has the <code>mscrInventory.change_order</code> permission (granted to users who need access to aggregate sales and usage reporting). Manage Users Add Users or assign permission groups Admin Access the Django Admin console to make changes directly to the database. <p>CAUTION: The Admin area should only be used by managers or technical staff.</p>"},{"location":"03_Navigation/03_ModalsDialogs/","title":"Modals and Dialogs","text":"<p>Most actions occur through modal dialogs instead of full page reloads, which keeps the workflow fast and focused.</p>"},{"location":"03_Navigation/03_ModalsDialogs/#common-modal-types","title":"Common Modal Types","text":"<ul> <li>Add / Edit Modals: Create or edit ingredients, recipes, products, and inventory entries.  </li> <li>Unmapped Items Modal: Displays unresolved import entries requiring manual review.  </li> <li>Edit Modifier Rules Modal: Manage allowed modifiers, replacements, and pricing behavior.  </li> </ul> <p>TIP: Always complete or cancel a modal before navigating elsewhere to avoid losing unsaved changes.</p>"},{"location":"03_Navigation/04_ColorIcons/","title":"Color and Icon Conventions","text":"<p>The app uses consistent visual language to indicate the status of items:</p> Color / Icon Meaning Red Error or required attention (unmapped, missing data, low stock). Yellow Pending review or incomplete information. Green Successfully saved or verified. Blue \u201c+\u201d icon Add a new record. Edit (\u270e) Edit an existing entry. <p>These conventions appear consistently across tables, forms, and dashboards.</p>"},{"location":"03_Navigation/05_SearchFilters/","title":"Search and Filters","text":"<p>Use the global search or per-table filters to locate items quickly. Filters may be combined\u2014for example, searching by name and narrowing by ingredient type.</p> <p>NOTE: Filters persist between navigation actions until manually cleared.</p> <p>When working with large inventories or recipe libraries, filters significantly reduce the time needed to locate and update records.</p>"},{"location":"04_Ingredients/01_Overview/","title":"Ingredients Overview","text":"<p>Ingredients form the foundation of all recipes and products. Each ingredient record stores its name, type, unit of measure, unit cost, and optional descriptive fields such as roast level or bag size.</p> <p>Ingredients must be maintained carefully, as they drive recipe accuracy, cost calculations, inventory counts, and reporting.</p> <p>Key capabilities: - Add, edit, or archive ingredients - Assign ingredient types - Track cost per unit - Associate packaging (cups, lids, sleeves, etc.) - Search and filter by category or status  </p>"},{"location":"04_Ingredients/02_AddingEditing/","title":"Adding or Editing Ingredients","text":""},{"location":"04_Ingredients/02_AddingEditing/#add-a-new-ingredient","title":"Add a New Ingredient","text":"<ol> <li>Navigate to Inventory \u2192 Ingredients.  </li> <li>Click Add Ingredient (+).  </li> <li>Enter the ingredient name, type, unit, and cost per unit.  </li> <li>(Optional) Add details such as roast, grind, or bag size.  </li> <li>Click Save.</li> </ol>"},{"location":"04_Ingredients/02_AddingEditing/#edit-an-existing-ingredient","title":"Edit an Existing Ingredient","text":"<ol> <li>Open the Ingredients list.  </li> <li>Click the Edit (\u270e) icon next to the ingredient.  </li> <li>Update cost, type, or metadata.  </li> <li>Save changes.</li> </ol>"},{"location":"04_Ingredients/02_AddingEditing/#archiving-ingredients","title":"Archiving Ingredients","text":"<ul> <li>Use Archive instead of Delete.  </li> <li>Archived ingredients are hidden from active lists but preserved in historical records.</li> </ul> <p>CAUTION: Do not delete ingredients used in recipes.</p>"},{"location":"04_Ingredients/03_Fields/","title":"Ingredient Fields","text":"Field Description Name Display name used throughout the app Ingredient Type Category such as Milk, Syrup, Roast, Bagel, etc. Unit of Measure oz, ml, g, bag, scoop, etc. Cost per Unit Used to calculate COGS and inventory valuation Bag Size / Roast / Grind Auto-displayed for coffee and similar items Active Whether the ingredient is currently in use <p>TIP: Ensure cost is always entered per unit, not per package.</p>"},{"location":"04_Ingredients/04_BestPractices/","title":"Ingredient Best Practices","text":"<ul> <li>Capitalize the first letter of each ingredient name.  </li> <li>Avoid brand names unless necessary.  </li> <li>Use consistent naming patterns (e.g., \u201cWhole Milk (16oz)\u201d).  </li> <li>Keep inactive or seasonal ingredients archived.  </li> <li>Audit ingredient costs regularly for accurate COGS.</li> </ul> <p>NOTE: Consistent naming helps the importer match items correctly.</p>"},{"location":"04_Ingredients/05_CSV/","title":"Bulk Editing and CSV Import","text":"<p>Large ingredient updates can be made with the Ingredient CSV Importer.</p>"},{"location":"04_Ingredients/05_CSV/#workflow","title":"Workflow","text":"<ol> <li>On the Ingredients Dashboard click Export CSV to download a round-trippable file with headers.</li> <li>Or open Import CSV \u2192 Download Template to grab a clean header-only file.</li> <li>Upload your CSV from the import modal and preview valid/invalid rows.</li> <li>Confirm to apply updates or creates; the table refreshes automatically.</li> </ol>"},{"location":"04_Ingredients/05_CSV/#template-columns","title":"Template Columns","text":"<ul> <li><code>id</code> (existing ingredient id; leave blank to create)</li> <li><code>name</code></li> <li><code>type_id</code>/<code>type_name</code></li> <li><code>unit_type_id</code>/<code>unit_type_name</code></li> <li><code>case_size</code></li> <li><code>reorder_point</code></li> <li><code>average_cost_per_unit</code></li> <li><code>lead_time</code></li> <li><code>notes</code></li> </ul>"},{"location":"04_Ingredients/05_CSV/#best-uses","title":"Best Uses","text":"<ul> <li>Updating multiple costs or reorder points</li> <li>Adding new seasonal items without using the form repeatedly</li> <li>Cleaning up inconsistent types or units</li> </ul> <p>CAUTION: Rows match by <code>id</code> first, then by <code>name</code> if no id is provided.</p>"},{"location":"04_Ingredients/06_Troubleshooting/","title":"Ingredients Troubleshooting","text":""},{"location":"04_Ingredients/06_Troubleshooting/#ingredient-not-appearing","title":"Ingredient Not Appearing","text":"<ul> <li>Check if the ingredient is Active.</li> <li>Verify the ingredient type is correct.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#cost-not-updating","title":"Cost Not Updating","text":"<ul> <li>Re-save the recipe that uses the ingredient.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#duplicate-warnings","title":"Duplicate Warnings","text":"<ul> <li>Clean up ingredient naming conventions.</li> <li>Archive old or unused entries.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#missing-packaging-options","title":"Missing Packaging Options","text":"<ul> <li>Ensure packaging types are active in the Packaging section.</li> </ul>"},{"location":"05_Recipes/01_Overview/","title":"Recipes Overview","text":"<p>Recipes define how ingredients combine to form products. Every product in the MSCR Inventory App is linked to a recipe, and recipe accuracy directly affects cost calculations, scaling, and modifier behavior.</p> <p>Recipes are stored as structured ingredient lists with quantities, units, and optional modifier rules. Updates to a recipe immediately cascade to all linked products.</p> <p>Key functions: - Create new recipes - Edit existing ones - Scale ingredient ratios for multiple sizes - Extend Recipes from <code>'base_items'</code>  - Configure modifier behavior  </p>"},{"location":"05_Recipes/02_CreateEdit/","title":"Creating or Editing Recipes","text":""},{"location":"05_Recipes/02_CreateEdit/#creating-a-new-recipe","title":"Creating a New Recipe","text":"<ol> <li>Go to Recipes \u2192 Manage Recipes.  </li> <li>Click Add Recipe.  </li> <li>Enter the recipe name, category, and base size (typically Small / 12oz).   NOTE: All Drink Recipes should be entered assuming a 12oz Capacity for Dynamic Scaling to work </li> <li>Add ingredients by selecting them from the dropdown and entering quantities.  </li> <li>Save the recipe.</li> </ol>"},{"location":"05_Recipes/02_CreateEdit/#editing-an-existing-recipe","title":"Editing an Existing Recipe","text":"<ol> <li>Navigate to Manage Recipes.  </li> <li>Find the recipe and click Edit (\u270e).  </li> <li>Adjust ingredient amounts or add/remove components.  </li> <li>Save changes.</li> </ol>"},{"location":"05_Recipes/02_CreateEdit/#copying-ingredients-from-another-recipe","title":"Copying Ingredients From Another Recipe","text":"<p>Use the Extend Recipe workflow inside the edit modal to copy ingredient lines:</p> <ol> <li>Open the target recipe (or product) and click Edit (\u270e) to launch the recipe modal.</li> <li>In the Extend From Recipe field, choose the source recipe whose ingredients you want to reuse (for example, a base latte or a seasonal variant).</li> <li>Confirm the prompt to import the selected recipe\u2019s ingredients into the current form.</li> <li>Adjust quantities or remove any lines that do not apply, then save.</li> </ol> <p>This copies the ingredient list into the current recipe while keeping the original unchanged. Editing a recipe immediately updates all linked products, so review quantities before saving.</p>"},{"location":"05_Recipes/03_Scaling/","title":"Understanding Dynamic Scaling","text":"<p>The app uses scaling ratios to automatically calculate ingredient quantities for different sizes.</p>"},{"location":"05_Recipes/03_Scaling/#example-latte-milk","title":"Example (Latte \u2013 Milk):","text":"Size Ratio Milk Amount Hot Small (12oz) 1.0 8 oz Iced Small (16oz) 1.34 11 oz Hot Large/XL (20oz) 1.66 13.3 oz Iced XL (32oz) 2.68 21 oz <p>Scaling ensures consistency and reduces repetitive data entry.</p> <p>Ingredients like Milk and Coldbrew are dynamically scaled based on Modifiers added to a drink</p> <p>TIP: Avoid rounding values prematurely \u2014 the system handles precision internally.</p>"},{"location":"05_Recipes/04_Fields/","title":"Recipe Fields","text":"Field Description Name Name of the recipe, usually matching the menu item Category Groups the recipe (Drinks, Bakery, etc.) Ingredients List of ingredients with quantities and units Active Determines whether the recipe is currently in use <p>These fields collectively determine how products are constructed from recipes.</p>"},{"location":"05_Recipes/05_AddIngredients/","title":"Adding Ingredients to Recipes","text":"<ol> <li>In the recipe editor, click Add Ingredient.  </li> <li>Choose an ingredient from the dropdown list.  </li> <li>Enter the quantity (e.g., <code>2 oz</code>, <code>1 unit</code>).  </li> <li>Repeat for additional ingredients.  </li> <li>Save the recipe.</li> </ol> <p>NOTE: Ingredients must be marked Active to appear in dropdowns.</p>"},{"location":"05_Recipes/05_AddIngredients/#removing-ingredients","title":"Removing Ingredients","text":"<ul> <li>Via the Admin by Administrators or Managers only</li> </ul>"},{"location":"05_Recipes/05_AddIngredients/#reordering-ingredients","title":"Reordering Ingredients","text":"<p>Ingredient order is automatically managed and does not affect functionality.</p>"},{"location":"05_Recipes/06_Modifiers/","title":"Modifiers and Optional Ingredients","text":"<p>Modifiers allow customers to customize drinks and food items without altering the base recipe.</p>"},{"location":"05_Recipes/06_Modifiers/#common-modifier-types","title":"Common Modifier Types","text":"<ul> <li>Milk Options: oat, soy, almond, whole, skim  </li> <li>Syrups &amp; Flavor Shots: vanilla, caramel, hazelnut  </li> <li>Size / Temperature Options: iced, large, extra hot  </li> <li>Add-ons: extra shot, whipped cream  </li> </ul> <p>Modifiers work alongside recipe ingredients but do not replace them unless specifically configured.</p>"},{"location":"05_Recipes/07_ModifierRules/","title":"Edit Modifier Rules","text":"<p>The Edit Modifier Rules modal controls how a recipe responds to customizations.</p>"},{"location":"05_Recipes/07_ModifierRules/#you-can-configure","title":"You can configure:","text":"<ul> <li>Allowed modifiers  </li> <li>Replacement behavior (e.g., replace whole milk with oat milk)  </li> <li>Additive behavior (e.g., add 0.5 oz syrup)  </li> <li>Temperature rules (hot/iced logic)  </li> <li>Additional costs or upgrades  </li> </ul> <p>Changes apply to all products linked to the recipe.</p> <p>CAUTION: Incorrect modifier rules can create mismatches during imports.</p>"},{"location":"05_Recipes/08_BestPractices/","title":"Recipe Best Practices","text":"<ul> <li>Recipes should be portioned to 12oz for Dynamic Scaling.  </li> <li>Avoid hardcoding multiple size versions \u2014 rely on scaling.  </li> <li>Audit ingredient costs regularly for accurate product pricing.   </li> <li>Archive recipes instead of deleting them.</li> </ul> <p>TIP: Keep recipe names clear to support Square/Shopify import matching.</p>"},{"location":"05_Recipes/09_Troubleshooting/","title":"Recipe Troubleshooting","text":""},{"location":"05_Recipes/09_Troubleshooting/#scaling-seems-incorrect","title":"Scaling Seems Incorrect","text":"<ul> <li>Check the recipe base size.  </li> <li>Review ingredient units for mismatches.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#ingredient-missing-from-dropdown","title":"Ingredient Missing from Dropdown","text":"<ul> <li>Ensure the ingredient is Active.  </li> <li>Confirm its type is correct.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#cost-doesnt-update","title":"Cost Doesn\u2019t Update","text":"<ul> <li>Re-save the recipe to trigger recalculation.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#imported-items-not-matching-recipe","title":"Imported Items Not Matching Recipe","text":"<ul> <li>Review modifier rules.  </li> <li>Check for naming inconsistencies.  </li> </ul>"},{"location":"06_Imports/01_Overview/","title":"Imports Overview","text":"<p>The Imports section manages all inbound data from Square, Shopify, and CSV-based internal tools. It is the central hub for maintaining accurate mappings, reconciling mismatched items, and keeping the inventory and recipe systems aligned with real-world sales.</p> <p>Imports support:</p> <ul> <li>Square CSV uploads  </li> <li>Shopify imports   </li> <li>Bulk import history review  </li> <li>Modifier classification and analysis  </li> <li>Unmapped item resolution (with modal or full-page dashboard)</li> </ul> <p>Additional CSV Imports are handled on Dashboards: - Ingredient CSV uploads - Inventory CSV updates \u2202</p> <p>Accurate imports ensure:</p> <ul> <li>Correct recipe and product usage reporting</li> <li>Clean naming conventions</li> <li>Accurate cost-of-goods tracking</li> <li>Smooth cross-platform data sync</li> </ul>"},{"location":"06_Imports/01_Overview/#import-log-output","title":"Import log output","text":"<ul> <li>Square CSV and Shopify imports now emit the same emoji-rich summary block after each run.</li> <li><code>python manage.py import_shopify_csv \u2026</code> prints the buffered log and summary at default verbosity so you immediately see counts for added/updated orders, matched items, skips, and errors.</li> <li>Daily Shopify syncs (<code>sync_orders</code>) reuse the same summary formatting, keeping console output consistent between Square and Shopify.</li> </ul>"},{"location":"06_Imports/01_Overview/#product-matching-guardrails","title":"Product matching guardrails","text":"<p>Square and Shopify imports evaluate exact matches before partial or fuzzy matches. When multiple candidates overlap in a composed line (for example, \"Small Iced Latte \u2013 Banana Bread \u2013 Oat Milk\"), partial fallbacks deliberately choose the shortest matching product name so the base drink anchors the line and modifiers remain intact. Exact matches for the full product name still take priority over these partial fallbacks.</p> <p>Fuzzy matches are now token-aware: if the closest candidate introduces words that do not appear in the incoming item (for example, matching a \"Banana Bread Latte\" line to a \"Banana Bread Matcha\" product), the importer skips the fuzzy result and leaves the row unmapped so you can resolve it explicitly.</p>"},{"location":"06_Imports/02_UploadSquare/","title":"Upload Square CSV","text":"<p>The Square Importer is one of the most frequently used tools in the app. It processes item-level sales data exported from Square.</p>"},{"location":"06_Imports/02_UploadSquare/#how-to-run-a-square-import","title":"How to Run a Square Import","text":"<ol> <li>Navigate to Imports \u2192 Square Import.  </li> <li>Upload a Square CSV file.  </li> <li>(Optional) Check Dry Run to simulate the import.  </li> <li>Click Upload.  </li> <li>Review the import summary including created, updated, skipped, or unmapped rows.</li> </ol>"},{"location":"06_Imports/02_UploadSquare/#dry-run-mode","title":"Dry Run Mode","text":"<ul> <li>Parses the full CSV  </li> <li>Performs all matching logic  </li> <li>Logs warnings and unmapped items  </li> <li>Does not write anything to the database  </li> </ul> <p>This is ideal for checking file structure before running a full import.</p>"},{"location":"06_Imports/02_UploadSquare/#import-results-summary","title":"Import Results Summary","text":"<p>After processing a file, the importer displays:</p> <ul> <li>Number of products matched  </li> <li>Number of modifiers detected  </li> <li>Items created or updated  </li> <li>Items skipped or ignored  </li> <li>Total unmapped items (with button to resolve)</li> <li>Any warnings or validation errors</li> </ul> <p>TIP: Always perform a Dry Run for new menus or seasonal items.</p>"},{"location":"06_Imports/03_Unmapped_Items/","title":"Unmapped Items Dashboard","text":"<p>Unmapped items appear when the importer cannot match a Square or Shopify row to an existing product, ingredient, or modifier. Square rows are now always logged as potential products first, even if they look like modifiers or ingredients. A hint is stored so the dashboard can suggest likely types, but you decide the final classification.</p> <p>Common reasons include:</p> <ul> <li>Misspellings  </li> <li>New seasonal drinks  </li> <li>Visibility differences between Square and the Inventory App  </li> <li>Price-point variants not recognized by the system  </li> <li>Missing modifier groups or recipe definitions  </li> </ul>"},{"location":"06_Imports/03_Unmapped_Items/#how-to-resolve-unmapped-items","title":"How to Resolve Unmapped Items","text":"<ol> <li>Go to Imports \u2192 Unmapped Items.  </li> <li>Review the list (modal or full-page).  </li> <li>For each unmapped row:</li> <li>Link to Existing product/ingredient/modifier (reclassify as needed)</li> <li>Create New record</li> <li>Mark as Ignored if not relevant</li> <li>Confirm your action.</li> <li>Unmapped count updates immediately.</li> </ol>"},{"location":"06_Imports/03_Unmapped_Items/#unmapped-items-modal","title":"Unmapped Items Modal","text":"<p>The modal presents: - Source (Square or Shopify) - Item type (defaults to Product for Square; hint shows if it resembled a modifier/ingredient) - Raw name from import (kept in sync with normalized keys when the label changes) - Suggested matches (if any) - Link/Create actions</p>"},{"location":"06_Imports/03_Unmapped_Items/#full-unmapped-items-dashboard","title":"Full Unmapped Items Dashboard","text":"<p>Includes: - Filters (type/source/date) - Pagination - Bulk actions - Links to record creation - \u201cOpen in Modal\u201d options  </p>"},{"location":"06_Imports/03_Unmapped_Items/#technical-internals","title":"Technical Internals","text":"<p>For a complete explanation of: - how unmapped items are normalized - how duplicates are prevented - when rows reopen after being resolved - how occurrence tracking works - how Ignore/Resolve/Create logic behaves  </p> <p>See Appendix B \u2013 Unmapped Items Usage.</p>"},{"location":"06_Imports/04_ModifierExplorer/","title":"Modifier Explorer","text":"<p>The Modifier Explorer helps you analyze and standardize modifier behavior across imported data. It groups modifiers into categories based on how they match existing records.</p> <p>Modifier categories include:</p> <ul> <li>Known: Clean matches to existing modifiers  </li> <li>Alias: Equivalent labels (e.g., \u201cOatmilk\u201d \u2192 \u201cOat Milk\u201d)  </li> <li>Fuzzy Match: Similar but not identical names  </li> <li>Unknown: Unrecognized or new modifiers  </li> <li>Co-occurrence Pairs: Common combinations that frequently appear together  </li> </ul>"},{"location":"06_Imports/04_ModifierExplorer/#what-you-can-do-in-modifier-explorer","title":"What You Can Do in Modifier Explorer","text":"<ul> <li>Review each category\u2019s items  </li> <li>Assign aliases to unify inconsistent naming  </li> <li>Promote or demote modifiers  </li> <li>Identify missing variants in recipes or product setups  </li> <li>Export modifier insights as CSV for deeper analysis  </li> </ul> <p>TIP: Resolve modifier inconsistencies before importing large batches to reduce unmapped items.</p>"},{"location":"06_Imports/05_ImportHistory/","title":"Import History","text":"<p>The Import History table provides a chronological view of all data imports across the system, including:</p> <ul> <li>Square CSV uploads  </li> <li>Shopify imports  </li> <li>Ingredient CSV imports  </li> <li>Inventory CSV adjustments  </li> </ul> <p>Each entry displays: - Timestamp - Source (Square/Shopify/CSV) - Run type (Dry Run or Live) - Count of created, updated, or skipped items - Links to warnings or unmapped items  </p>"},{"location":"06_Imports/05_ImportHistory/#when-to-use-import-history","title":"When to Use Import History","text":"<ul> <li>Audit previous import runs  </li> <li>Verify if a file was processed successfully  </li> <li>Confirm whether an issue came from Square or the Inventory App  </li> <li>Track changes over time  </li> </ul> <p>Import History helps identify patterns such as: - Repeated unmapped items - Inconsistent naming between systems - Products missing cost or ingredient data  </p>"},{"location":"06_Imports/06_Fetch_Shopify/","title":"Fetch Shopify CSV","text":"<p>The Shopify Importer is one of the most frequently used tools in the app. It pulls item-level sales data exported from Shopify via API, keeping recipes, products, and inventory aligned with what actually sold in the shop.</p>"},{"location":"06_Imports/06_Fetch_Shopify/#how-to-run-a-shopify-import","title":"How to Run a Shopify Import","text":"<ol> <li>Navigate to Imports \u2192 Fetch Shopify.  </li> <li>Select the Date Range you need; the importer uses the start and end dates to pull every order in that window.</li> <li>Click <code>Fetch Shopify</code>. When the importer is done a summary will show in <code>Messages</code>.</li> <li>After completion, check the import log for any unmapped SKUs or modifiers that need resolution. Unmapped items render a warning inside the modal so you can link them with the right ingredients or recipes before the next sync.</li> </ol>"},{"location":"06_Imports/06_Fetch_Shopify/#follow-up","title":"Follow-up","text":"<ul> <li>Review the imported data on the Imports History screen to confirm totals and export the batch if you need a CSV backup.  </li> <li>If inventory quantities shift, refresh the Inventory dashboard so HTMX partials rerender with the updated on-hand amounts.  </li> <li>Schedule Shopify imports daily or weekly to keep pricing and modifier usage accurate for costing and purchasing workflows.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/","title":"Orders Dashboard","text":"<p>The Orders Dashboard consolidates recent Shopify and Square orders into a single, unified view. It helps teams quickly review customer activity, custom drink trends, and imported item behavior.</p>"},{"location":"07_Orders/01_OrdersDashboard/#key-features","title":"Key Features","text":""},{"location":"07_Orders/01_OrdersDashboard/#unified-order-stream","title":"Unified Order Stream","text":"<ul> <li>Displays both Square and Shopify orders.</li> <li>Combined view by default; platform filters allow narrowing to one source.</li> <li>Customizable date range with standard presets:</li> <li>Last 7 days</li> <li>Last 14 days</li> <li>Last 30 days</li> <li>Last 90 days</li> <li>Custom date window (reveals the from/to inputs so you can set any specific range)</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#filters-and-search","title":"Filters and Search","text":"<ul> <li>Filter by platform (Square / Shopify)</li> <li>Search by product name or custom drink text</li> <li>Identify \u201cName Your Drink\u201d items that appear frequently</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#order-details","title":"Order Details","text":"<p>Each order entry includes: - Order timestamp - Source (Square / Shopify) - List of items with quantities - Modifiers applied to each item - Total item count (annotated for clarity)</p>"},{"location":"07_Orders/01_OrdersDashboard/#pagination","title":"Pagination","text":"<ul> <li>Large order volumes automatically paginate</li> <li>Navigation links preserve filter parameters</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#name-your-drink-integration","title":"\u201cName Your Drink\u201d Integration","text":"<p>The Dashboard widget for Top Name-Your-Drink links directly into the Orders Dashboard filtered by the correct preset.</p> <p>Use this feature to: - Identify popular recurring custom drink names - Validate whether new recipes or modifiers should be created - Spot trends in seasonal or special\u2011request beverages</p>"},{"location":"07_Orders/01_OrdersDashboard/#use-cases","title":"Use Cases","text":"<ul> <li>Reviewing unusual modifiers before running mapping updates</li> <li>Checking Square/Shopify consistency for newly added menu items</li> <li>Tracing the origin of unmapped or mis\u2011mapped items in imports</li> <li>Monitoring custom drink naming and usage frequency</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#troubleshooting","title":"Troubleshooting","text":""},{"location":"07_Orders/01_OrdersDashboard/#missing-orders","title":"Missing Orders?","text":"<ul> <li>Confirm selected date range.</li> <li>Ensure platform filters are not hiding results.</li> <li>Check Shopify and Square export configurations.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#unknown-modifier-appearing","title":"Unknown Modifier Appearing?","text":"<ul> <li>Visit Imports \u2192 Modifier Explorer for classification.</li> <li>Review the associated product\u2019s modifier groups.</li> <li>Check for spelling variations or Square menu discrepancies.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#duplicate-orders","title":"Duplicate Orders?","text":"<ul> <li>Ensure the same platform is not being imported twice.</li> <li>Verify the date range does not overlap across import sessions.</li> </ul>"},{"location":"08_Inventory/01_LowStock/","title":"Low Stock Ingredients","text":"<p>The Low Stock view highlights ingredients that have fallen below their reorder point. These warnings appear both on the Dashboard and in the Inventory module.</p>"},{"location":"08_Inventory/01_LowStock/#what-triggers-low-stock","title":"What Triggers Low Stock","text":"<ul> <li>An ingredient\u2019s calculated current stock drops below its <code>reorder_point</code> value. Or <code>usage</code> from last import times <code>lead time</code> will exceed <code>reorder_point</code>.</li> <li>Manual adjustments, bulk updates, or imports that reduce stock.</li> <li>Negative or inconsistent stock counts after CSV import.</li> </ul>"},{"location":"08_Inventory/01_LowStock/#how-to-use-low-stock-alerts","title":"How to Use Low Stock Alerts","text":"<ol> <li>Open the Dashboard or Inventory \u2192 Low Stock (if available).  </li> <li>Review the list of flagged ingredients.  </li> <li>Click an ingredient name to open its detail modal.  </li> <li>Enter new stock (e.g., after receiving a delivery).  </li> <li>Save to update current inventory counts.</li> </ol>"},{"location":"08_Inventory/01_LowStock/#best-practices","title":"Best Practices","text":"<ul> <li>Review low-stock items at the start of each shift.  </li> <li>Update stock as soon as new items arrive.  </li> <li>Keep reorder points realistic\u2014too low creates risk, too high inflates spent budget.  </li> </ul> <p>TIP: Low-stock items often overlap with unmapped import issues. Always verify both.  </p>"},{"location":"08_Inventory/02_BulkAdd/","title":"Bulk Add Stock","text":"<p>The Bulk Add Stock tool allows you to add multiple stock entries in a single workflow. This is faster and more reliable than updating each ingredient individually.</p>"},{"location":"08_Inventory/02_BulkAdd/#how-to-use-bulk-add-stock","title":"How to Use Bulk Add Stock","text":"<ol> <li>Open the tool from the Inventory Dashboard or Dashboard Quick Actions.  </li> <li>Add a row for each ingredient you received.  </li> <li>Enter the quantity received and cost.  </li> <li>(Optional) Include notes (lot number, supplier, etc.).  </li> <li>Submit all entries at once.</li> </ol>"},{"location":"08_Inventory/02_BulkAdd/#behind-the-scenes","title":"Behind the Scenes","text":"<ul> <li>Each entry generates a StockEntry record.  </li> <li>The ingredient\u2019s current stock is recalculated.  </li> <li>Average cost is updated based on weighted inputs.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#when-to-use-bulk-add","title":"When to Use Bulk Add","text":"<ul> <li>Daily receiving  </li> <li>Weekly deliveries  </li> <li>Adjusting multiple items after inventory count  </li> <li>Updating costs after vendor price changes  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"08_Inventory/02_BulkAdd/#stock-not-updating","title":"Stock Not Updating?","text":"<ul> <li>Ingredient may be archived.  </li> <li>Ensure units match the ingredient\u2019s defined UoM.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#average-cost-looks-wrong","title":"Average Cost Looks Wrong?","text":"<ul> <li>Check if a previous entry had incorrect cost.  </li> <li>Re-run bulk update with corrected values.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#duplicate-stock-entries","title":"Duplicate Stock Entries?","text":"<ul> <li>Confirm entries before submitting.  </li> <li>Use CSV Import for large structured updates.  </li> </ul>"},{"location":"08_Inventory/03_Overview/","title":"Inventory Dashboard Overview","text":"<p>The Inventory dashboard centralizes ingredient, recipe, and stock data so the team can spot shortages, track inflow/outflow, and make purchasing decisions without leaving the dashboard. It highlights current on\u2011hand amounts and links each row to the underlying recipes and modifiers that drive those totals.</p> <p>Two controls keep the workflow focused:</p> <ul> <li>Add Case: opens the modal that brings a new purchase case into the system, letting you specify the supplier, quantity, and cost while automatically updating linked inventory levels.</li> <li>Update Row: lets you refresh an existing entry when a quick adjustment is needed\u2014such as a count correction or unit conversion\u2014so the dashboard remains the single source of truth.</li> </ul> <p>Because the Inventory dashboard is HTMX-driven, each control applies its change instantly and rerenders the relevant partial, keeping the rest of the page responsive and in sync.</p>"},{"location":"09_Reporting/01_Reporting/","title":"Reporting","text":"<p>The Reporting module provides visibility into ingredient usage, cost of goods (COGS), inventory valuation, and operational insights across your caf\u00e9 or retail environment. These reports help managers make data\u2011driven decisions regarding purchasing, pricing, inventory, and recipe management.</p> <p>Reporting pulls from: - Ingredient records - Recipe structures - Inventory stock entries - Order histories - Square and Shopify imports  </p> <p>Accurate reporting depends on clean recipes, well\u2011maintained ingredients, and properly resolved imports.</p>"},{"location":"09_Reporting/01_Reporting/#order-date-alignment","title":"Order-date alignment","text":"<p>COGS trend and ingredient usage totals are calculated by the order date, not the import timestamp. During imports, each order\u2019s business-day date is stored on the related <code>IngredientUsageLog</code> entries so that:</p> <ul> <li>Multi-day imports still land on the correct service date.</li> <li>The COGS trend table reflects true day-to-day consumption.</li> <li>Usage totals always match what guests purchased on that day, even if the data was synced later.</li> </ul>"},{"location":"09_Reporting/01_Reporting/#leaderboard-deltas","title":"Leaderboard deltas","text":"<p>The reporting dashboard highlights rank changes for top-selling products and modifiers. Current ranks are compared to the immediately preceding window of the same length (e.g., the prior day when viewing a single date) so you can spot movers, decliners, and new entries at a glance.</p>"},{"location":"09_Reporting/01_Reporting/#quick-date-presets","title":"Quick date presets","text":"<p>Use the eight quick-range buttons under the date pickers to jump to common reporting windows without manually entering dates. Presets include today, yesterday, this/last week, this/last month, and this/last year arranged in a 2\u00d74 grid. Selecting a preset fills both date fields and immediately reloads the dashboard.</p>"},{"location":"09_Reporting/01_Reporting/#top-selling-product-context","title":"Top-selling product context","text":"<p>Within the Top Selling Products widget, modifiers are ordered by how frequently guests purchased them (based on item quantity) so the most common customizations surface first. Descriptor and variant details remain accessible via the existing collapse controls and variant modal.</p>"},{"location":"09_Reporting/02_UsageReports/","title":"Ingredient Usage Reports","text":"<p>Ingredient usage reports calculate how much of each ingredient has been consumed over a specific date range.</p>"},{"location":"09_Reporting/02_UsageReports/#how-usage-is-calculated","title":"How Usage Is Calculated","text":"<p>Usage is derived from: 1. Order data imported from Square and Shopify. 2. Recipe definitions, which determine ingredient quantities per product. 3. Scaling rules (for multiple product sizes). 4. Modifier adjustments (e.g., almond milk replacements).  </p> <p>For each order, the system multiplies: <code>ingredient quantity \u00d7 number of items sold \u00d7 size scaling</code></p>"},{"location":"09_Reporting/02_UsageReports/#use-cases","title":"Use Cases","text":"<ul> <li>Forecast purchasing needs  </li> <li>Identify high\u2011usage ingredients  </li> <li>Track cost changes over time  </li> <li>Validate recipe accuracy  </li> </ul> <p>TIP: Usage anomalies often indicate a mismatch in recipe scaling or modifier rules.</p>"},{"location":"09_Reporting/03_COGS/","title":"Cost of Goods Sold (COGS)","text":"<p>The COGS report provides estimated ingredient cost per product sold over time.</p>"},{"location":"09_Reporting/03_COGS/#how-cogs-is-computed","title":"How COGS Is Computed","text":"<ol> <li>Pull ingredient costs from the Inventory module  </li> <li>Apply recipe ingredient quantities  </li> <li>Apply size scaling  </li> <li>Add modifier cost effects  </li> <li>Aggregate totals across orders  </li> </ol>"},{"location":"09_Reporting/03_COGS/#why-cogs-matters","title":"Why COGS Matters","text":"<ul> <li>Helps refine menu pricing  </li> <li>Highlights low\u2011margin products  </li> <li>Identifies cost inefficiencies  </li> <li>Supports financial reporting  </li> </ul> <p>CAUTION: If ingredient costs are outdated, COGS results will be inaccurate. Update costs regularly.</p>"},{"location":"09_Reporting/04_InventoryValuation/","title":"Inventory Valuation","text":"<p>Inventory valuation reports show the monetary value of all active ingredients in stock.</p>"},{"location":"09_Reporting/04_InventoryValuation/#components-of-valuation","title":"Components of Valuation","text":"<ul> <li>Current stock quantity  </li> <li>Average cost per unit  </li> <li>Ingredient type and category  </li> </ul>"},{"location":"09_Reporting/04_InventoryValuation/#best-practices","title":"Best Practices","text":"<ul> <li>Run valuation reports monthly for financial accuracy  </li> <li>Use Bulk Add Stock to maintain stable cost calculations  </li> <li>Archive unused ingredients to simplify reporting  </li> </ul>"},{"location":"09_Reporting/05_ExportingReports/","title":"Exporting Reports (In Development)","text":"<p>The reporting dashboard is currently an interactive, on-screen experience. Views such as usage, COGS, and inventory snapshots re nder charts and cards that respond to the selected date window, but they do not provide CSV downloads yet.</p>"},{"location":"09_Reporting/05_ExportingReports/#current-workflow","title":"Current Workflow","text":"<ol> <li>Open the reporting dashboard.</li> <li>Adjust the date filters or presets to show the period you need.</li> <li>Review the widgets/cards directly in the browser.</li> </ol> <p>If you need to perform spreadsheet analysis, copy the on-screen values or take screenshots until CSV export endpoints are implem ented.</p>"},{"location":"09_Reporting/05_ExportingReports/#roadmap","title":"Roadmap","text":"<ul> <li>CSV export buttons will appear once dedicated download views are added to <code>mscrInventory/views/reporting.py</code>.</li> <li>When available, exports will include the same precision as the on-screen metrics (ingredient units, extended costs, etc.).</li> </ul>"},{"location":"10_manage_users/01_ManageUsers/","title":"Manage Users","text":"<p>The Manage Users section allows managers and administrators to create, update, and organize user accounts within the MSCR Inventory App. User roles determine access to recipes, inventory, reports, and administrative tools.</p> <p>This section centralizes: - New user creation - Updating user information - Assigning or changing permission groups - Reviewing account status (active, pending, archived)  </p> <p>Only users with elevated permissions (Manager or Admin) can access this area.</p>"},{"location":"10_manage_users/02_Permissions/","title":"Permission Groups","text":"<p>Permissions control what each user can see and do. Assign the appropriate group based on responsibilities.</p>"},{"location":"10_manage_users/02_Permissions/#available-permission-groups","title":"Available Permission Groups","text":""},{"location":"10_manage_users/02_Permissions/#admin","title":"Admin","text":"<ul> <li>Full system access  </li> <li>Can manage all data, users, imports, and Django Admin  </li> <li>Intended for technical staff or leadership  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#manager","title":"Manager","text":"<ul> <li>Nearly full access to the system  </li> <li>Can manage users, imports, inventory, and recipes  </li> <li>Limited access to developer-only Django Admin actions  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#barista","title":"Barista","text":"<ul> <li>View-only access for most areas  </li> <li>Can manage recipes, ingredients, and inventory  </li> <li>Cannot access: Reports, Manage Users, or Admin  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#inventory","title":"Inventory","text":"<ul> <li>Focused on stock management  </li> <li>Can adjust inventory and costs  </li> <li>Cannot access advanced reporting, user management, or Admin  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#pending","title":"Pending","text":"<ul> <li>Automatically assigned to newly created accounts  </li> <li>Must be elevated by a Manager before gaining access  </li> <li>Cannot perform any editing actions  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#how-to-assign-permissions","title":"How to Assign Permissions","text":"<ol> <li>Go to Manage Users.  </li> <li>Select the user you want to update.  </li> <li>Choose the correct permission group from the dropdown.  </li> <li>Save changes.</li> </ol> <p>TIP: Keep at least one Admin and two Managers assigned at all times.</p>"},{"location":"11_Admin/01_Admin/","title":"Admin (Restricted Access)","text":"<p>The Admin section refers specifically to the Django Admin interface bundled with the MSCR Inventory App. This area provides direct access to the underlying database models and is intended only for trained Managers and Admins.</p> <p>Because changes made here bypass some of the safety checks and convenience tools in the main UI, access is intentionally limited.</p>"},{"location":"11_Admin/01_Admin/#what-you-can-do-in-the-admin-area","title":"What You Can Do in the Admin Area","text":"<p>The Django Admin exposes raw records for: - Ingredients - Products - Recipes - Recipe Modifiers - Ingredient Types - Stock Entries - Import Logs - Square Unmapped Items - Users and Groups (Permissions)</p> <p>From here you can: - Correct data inconsistencies - Perform bulk edits not yet supported in the main interface - Review historical logs - Diagnose issues during import reconciliation - Inspect raw relationships between objects  </p>"},{"location":"11_Admin/01_Admin/#when-to-use-django-admin","title":"When to Use Django Admin","text":"<p>Use Admin for: - Troubleshooting unusual data inconsistencies - Cleaning up legacy entries - Reviewing unmapped items directly - Viewing ImportLog objects and raw CSV storage - Quick data inspection during development or QA  </p> <p>Avoid using Admin for: - Day\u2011to\u2011day ingredient or recipe updates - Product creation - Inventory adjustments - User creation (use Manage Users instead)</p>"},{"location":"11_Admin/01_Admin/#safety-notes","title":"Safety Notes","text":"<p>WARNING: Actions taken in Django Admin update the database immediately and permanently.</p> <p>To ensure data integrity:</p> <ul> <li>Do not delete ingredients or recipes that appear in orders or imports  </li> <li>Avoid editing primary keys or relational links unless you fully understand downstream effects  </li> <li>Use Archive instead of Delete wherever possible  </li> <li>Double\u2011check ingredient type, units, and cost fields before saving  </li> <li>Review all changes in the main UI after editing records in Admin</li> </ul>"},{"location":"11_Admin/01_Admin/#access-requirements","title":"Access Requirements","text":"<p>Only users in the following groups may access Admin:</p> <ul> <li>Admin: Full access  </li> <li>Manager: Limited, read\u2011oriented access depending on configuration  </li> </ul> <p>Barista, Inventory, and Pending users cannot enter the Django Admin interface.</p>"},{"location":"11_Admin/01_Admin/#troubleshooting","title":"Troubleshooting","text":""},{"location":"11_Admin/01_Admin/#access-denied","title":"Access Denied?","text":"<ul> <li>Ensure your user account is assigned to Admin or Manager.</li> <li>Reload the page after permissions update.</li> <li>Log out and back in if the session does not refresh.</li> </ul>"},{"location":"11_Admin/01_Admin/#changes-not-appearing-in-main-ui","title":"Changes Not Appearing in Main UI?","text":"<ul> <li>Some cached views require reload.</li> <li>Verify your edits match expected model fields.</li> <li>Inspect ImportLog or ingredient relationships if mappings seem incorrect.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/","title":"Appendix A \u2013 Manual Testing","text":""},{"location":"12_Appendix_A_Testing/01_ManualTests/#manual-test-plan","title":"Manual Test Plan","text":"<p>Use this as a high-level smoke/regression checklist. Unless otherwise noted, start from a fresh <code>python manage.py migrate</code> + demo data and remain logged in as a user with edit permissions.</p>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#authentication-session-guardrails","title":"Authentication &amp; Session Guardrails","text":"<ul> <li>Log out, visit <code>/recipes/</code>, and confirm you are redirected to the login page; then log in and ensure you return to the requested URL.</li> <li>Attempt to POST to an HTMX endpoint (e.g., add ingredient to a recipe) while logged out; verify a 403 response with the expected \u201cForbidden\u201d message.</li> <li>Confirm permission scoping: a user with <code>view_recipemodifier</code> but no ingredient permissions can open Modifier Explorer but cannot edit ingredients or save aliases.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#dashboard-overview","title":"Dashboard Overview (<code>/</code>)","text":"<ul> <li>Widgets populate: Active Products, Tracked Ingredients, Recent Imports, Recent Changes, Top Name-Your-Drink, Recent Warnings, Shortcuts, Quick Add/Import cards.</li> <li>Low stock + import failures raise warnings: create an ingredient below its reorder point and a failed import log, reload, and confirm both warnings appear.</li> <li>\u201cTop Name-Your-Drink\u201d tile links to orders search (URL contains <code>orders/?preset=</code>) and shows at least one named drink entry.</li> <li>Recent imports tile shows unmatched Square items when present.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#orders-dashboard-orders","title":"Orders Dashboard (<code>/orders/</code>)","text":"<ul> <li>Default preset is 14 days and combines Square + Shopify orders.</li> <li>Platform filter: selecting Shopify hides Square orders; switching back restores both.</li> <li>Custom date range: choose preset \u201cCustom,\u201d set a start/end window that includes only mid-range orders, and verify only those appear; banner should note the custom window.</li> <li>Pagination: load with &gt;25 orders, verify page 1 has 25, navigate to page 2 and confirm querystring retains filters.</li> <li>Open any order row and confirm <code>total_items</code> annotation equals the sum of item quantities.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#recipes-dashboard-recipes","title":"Recipes Dashboard (<code>/recipes/</code>)","text":"<ul> <li>Grid headers are sortable: toggle ID, Product, Category, or Cost columns and confirm sort direction indicators update.</li> <li>Inactive products are hidden: deactivate a product, reload, and verify it disappears from the dashboard list and Base Item dropdown.</li> <li>Grid renders columns including product temperature. Search for \u201cmilk\u201d and confirm matches bubble to the top while categories collapse appropriately.</li> <li>Edit modal opens from \u201cEdit\u201d and lists all ingredients with current quantities and units.</li> <li>Add an ingredient: choose from dropdown, enter quantity, click <code>+</code>; ingredient row appears immediately via HTMX without full page reload.</li> <li>Delete an ingredient: click \u2715, accept confirmation, and ensure the row disappears instantly.</li> <li>Extend recipe: pick a base recipe in the modal, submit, and confirm ingredients clone into the current recipe.</li> <li>Live-reload: while server running, edit a template referenced by the page and verify auto-refresh.</li> <li>CSRF handling: repeat an add/delete while logged out to confirm safe 403 responses (no partial writes).</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#recipe-csv-exportimport","title":"Recipe CSV Export/Import","text":"<ul> <li>Export CSV: click \u201c\ud83d\udce4 Export Recipes CSV,\u201d open the file, and confirm each product appears once per ingredient with category name and COGS subtotal columns populated.</li> <li>Import (two-step modal if enabled): upload a CSV with valid + invalid rows, run dry-run, confirm invalid rows are reported without DB writes; rerun without dry-run to commit and verify recipe grid updates.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#modifier-explorer-modifier-explorer","title":"Modifier Explorer (<code>/modifier-explorer/</code>)","text":"<ul> <li>Load page with a <code>view_recipemodifier</code> user; confirm sections for Known, Alias token, Fuzzy, Unknown, and co-occurrence pairs.</li> <li>Classification filter: choose \u201cUnknown\u201d and verify matching products are hidden with a \u201cHiding N matching product(s)\u201d banner; toggle \u201cinclude known products\u201d to reveal matches.</li> <li>Alias management: for an alias row, pick a mapped modifier from the select box and save; confirm selection persists after refresh.</li> <li>CSV export: load with sample data and request <code>?format=csv</code>; verify the response downloads with header containing <code>alias_label</code> and rows for each modifier insight.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#inventory-management","title":"Inventory Management","text":"<ul> <li>Bulk Add modal: open from inventory dashboard, add multiple stock entries, submit, and confirm StockEntry records and current stock totals update correctly.</li> <li>Inventory CSV export: trigger export, open file, and confirm ingredients, quantities, costs, and units are present.</li> <li>Inventory CSV import: upload a modified CSV, run in dry-run to view summary and validation errors, then import for real and check ingredient quantities and average cost adjustments reflect the file.</li> <li>Reorder point alert: set an ingredient below reorder level and ensure it appears in dashboard warnings and any \u201cInventory running low\u201d lists.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#imports-dashboard-squareshopify-integration","title":"Imports Dashboard &amp; Square/Shopify Integration","text":"<ul> <li>Square CSV upload: submit a sample file with \u201cDry run\u201d checked; expect redirect to imports dashboard, creation of a <code>square</code> ImportLog marked <code>dry-run</code>, stored file name ending in <code>-square.csv</code>, and buffered output displayed in the log detail.</li> <li>Secure temp file handling: verify uploaded Square CSV is stored in the configured <code>squareCSVs/</code> directory and removed after processing when appropriate.</li> <li>Unmapped Square items: after a Square import containing unknown items, open the \u201cUnmapped items\u201d tab, link an item to an existing product via \u201cLink existing,\u201d then create a new product using \u201cCreate from unmapped\u201d; ensure mappings persist and import warnings decrease.</li> <li>Shopify sync/dry-run (if enabled): run the import or dry-run flow and confirm ImportLog captures run type, counts, and any unmatched items; verify no DB writes on dry-run.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#reporting-analytics","title":"Reporting &amp; Analytics","text":"<ul> <li>Ingredient usage aggregation: trigger the report that rolls up ingredient usage across recipes/orders and confirm totals match expected counts.</li> <li>Dashboard metrics: verify calculated COGS and metric cards update after adjusting ingredient costs or recipe quantities.</li> <li>Export inventory/recipe/usage reports to CSV and ensure numerical columns retain precision (e.g., Decimal costs).</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#admin-user-management","title":"Admin &amp; User Management","text":"<ul> <li>Admin access: log in as superuser (or Admin/Manager), open Django admin, and confirm core models (Ingredient, Product, Recipe, RecipeModifier, ImportLog, Order) are visible.</li> <li>Permission enforcement: create a user without <code>change_ingredient</code> and confirm edit/delete buttons disappear while view-only pages still load.</li> <li>User creation: add a new user through the app\u2019s user management flow, set a password, and verify login/logout works.</li> <li>Delete <code>Test User</code> from Admin</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#permissions-testing","title":"Permissions Testing","text":"Group Can View Can Add/Edit Can Import Can Export Can Access /admin Can Delete Superuser \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Manager \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Barista \u2705 \u2705 (recipes, mods, ingredients, inventory) \u274c \u274c \u274c \u274c Inventory \u2705 (inventory only) \u2705 (inventory) \u274c \u274c \u274c \u274c"},{"location":"12_Appendix_A_Testing/02_TestSuite/","title":"Appendix A \u2013 Automated Test Suite","text":"<p>Our <code>tests/</code> directory provides automated regression coverage across the app. The suite uses <code>pytest</code> with factory fixtures (<code>tests/factories.py</code>, <code>tests/conftest.py</code>) to spin up lightweight data for each scenario.</p>"},{"location":"12_Appendix_A_Testing/02_TestSuite/#coverage-snapshot","title":"Coverage snapshot","text":"<ul> <li>Views &amp; HTMX flows (auth, dashboard, orders, recipes, inventory, user management)</li> <li>Importers (Square, Shopify, CSV), dry-run behavior, and data hygiene tools</li> <li>Reporting utilities and dashboard metrics</li> <li>Model behaviors, modifiers, and recipe math (including packaging and COGS)</li> <li>Templates and permission enforcement regressions</li> <li>Migration cleanup and critical utilities</li> </ul>"},{"location":"12_Appendix_A_Testing/02_TestSuite/#how-to-run","title":"How to run","text":"<p>From the repo root, run: <pre><code>pytest\n</code></pre> This executes the full regression suite locally; CI runs the same entry point to guard releases.</p>"},{"location":"12_Appendix_A_Testing/02_TestSuite/#automation-log","title":"Automation Log","text":"<p>The test suite runs automatically with every push to <code>main</code> on GitHub. Results can be viewed on GitHub. </p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/","title":"Appendix B \u2013 Unmapped Items Usage","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#overview","title":"Overview","text":"<p>Unmapped items are created when SquareImporter or ShopifyImporter cannot associate an incoming row with an existing product, ingredient, or modifier. This system is designed not only to catch inconsistencies in imports, but also to intelligently retain history and prevent duplicates.</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#unmapped-item-flow","title":"Unmapped-Item Flow","text":"<p>The importer performs the following steps:</p> <ol> <li>Initialize a fresh run state</li> <li>Each import session maintains a per-run log and counters.</li> <li>All tracking resets at the start of each file.</li> <li> <p>When <code>dry_run=True</code>, all writes are rolled back, but the importer still performs all matching logic and logging.</p> </li> <li> <p>Row processing</p> </li> <li>Each row is logged with contextual details.</li> <li>The importer calls <code>_find_best_product_match</code>.</li> <li> <p>If no match is found, the system funnels into <code>_record_unmapped_item</code>.</p> </li> <li> <p>Price-point and shell item handling</p> </li> <li>Generic menu shells such as \u201cBarista\u2019s Choice\u201d are treated as unmatched unless pricing clarifies the intended product.</li> <li> <p>Seasonal or experimental variations properly surface as unmapped.</p> </li> <li> <p>Recording the unmapped item</p> </li> <li>The importer normalizes its item/price-point pair.</li> <li>Deduping occurs at both the per-run level and persistent DB level.</li> <li>On live imports, normalization keys are used with <code>get_or_create</code> to avoid duplicates.</li> <li> <p>Reappearances update:</p> <ul> <li><code>last_seen</code></li> <li><code>seen_count</code></li> <li>captured modifiers</li> <li>resolution status</li> </ul> </li> <li> <p>Reopening resolved entries</p> </li> <li>If an item previously resolved appears again with new context, the importer may reopen it rather than create a new entry.</li> <li>This keeps history tidy but complete.</li> </ol>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#data-model-persistence","title":"Data Model &amp; Persistence","text":"<p><code>SquareUnmappedItem</code> includes:</p> <ul> <li>Source (Square/Shopify)</li> <li>Item type (Product, Ingredient, Modifier)</li> <li>Raw label values</li> <li>Normalized keys (for grouping)</li> <li>Snapshot of applied modifiers</li> <li>Reason for unmapped status</li> <li>Timestamps (<code>first_seen</code>, <code>last_seen</code>)</li> <li>Occurrence count</li> <li>Resolution metadata:</li> <li>ignored status</li> <li>link to actual Product/Ingredient/Modifier (if resolved)</li> </ul> <p>Uniqueness constraint: One row per normalized item/variant ensures no duplicates are created.</p> <p>Helper methods encapsulate: - resolving - reopening - ignoring - normalization logic</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#dashboard-modal-experience","title":"Dashboard &amp; Modal Experience","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#dashboard-behavior","title":"Dashboard Behavior","text":"<ul> <li>The Imports dashboard shows a warning button displaying the number of unresolved items.</li> <li>If no unmapped items exist, an \u201cAll items mapped\u201d indicator is displayed.</li> </ul>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#modal-and-full-dashboard","title":"Modal and Full Dashboard","text":"<p>The same underlying view powers: - the lightweight HTMX modal - the full-page dashboard at <code>/dashboard/unmapped/</code></p> <p>These views include: - filter controls - per-item actions - create/link forms - pagination (for full view)</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#modal-features","title":"Modal Features","text":"<ul> <li>Quick summary of unresolved items</li> <li>Inline link/create forms</li> <li>\u201cView Full Dashboard\u201d for bulk actions or extended review</li> </ul>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#table-output","title":"Table Output","text":"<p>The shared table partial includes: - Source - Type - Raw Name - First/Last Seen - Occurrences - Actions (Link, Create, Ignore)</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#mapping-actions-validation","title":"Mapping Actions &amp; Validation","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#linking","title":"Linking","text":"<p><code>LinkUnmappedItemForm</code> allows associating an item with: - existing product - existing ingredient - existing modifier  </p> <p>Upon save: - <code>mark_resolved</code> is called - updated metadata is returned - the dashboard refreshes via HTMX</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#creating-new-items","title":"Creating New Items","text":"<p><code>CreateFromUnmappedItemForm</code>: - tailors fields based on item type - generates default SKUs when needed - handles IntegrityErrors gracefully   - duplicate names trigger user-friendly validation messages</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#bulk-actions","title":"Bulk Actions","text":"<p>Bulk modes allow staff to: - resolve all filtered items - ignore all filtered items - create placeholder records for batches</p> <p>Bulk actions reuse: - SKU generation helpers - <code>get_or_create</code> for ingredients - shared validation logic</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#admin-coverage","title":"Admin &amp; Coverage","text":"<p>In Django Admin, staff can view: - All unmapped items - Filters (source, type, ignored/resolved) - Read-only historical fields - Link/autocomplete relationships - Custom admin actions:   - resolve   - ignore   - reopen</p> <p>ImportLog objects also include: - summary previews - stored file metadata - associated warnings</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#regression-test-coverage","title":"Regression Test Coverage","text":"<p>Automated tests include: - dry-run safety - handling variant unmapped items - idempotent re-runs - deduping behavior - modal rendering - full-page dashboard output - bulk creation flows - upload logging - integration with ImportLog and related models</p> <p>This ensures stable behavior across updates.</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#expected-behavior-recap","title":"Expected Behavior Recap","text":"<ol> <li>Run a Square import (use a Dry Run first).</li> <li>Rows that cannot be matched become unmapped.</li> <li>Live runs update:</li> <li>occurrence count</li> <li>timestamps</li> <li>reopened vs. newly created entries</li> <li>Staff review unmapped items using modal or dashboard.</li> <li>Items are resolved by:</li> <li>linking</li> <li>creating a new record</li> <li>marking as ignored</li> <li>Bulk actions support efficient cleanup.</li> <li>Admin provides a fallback UI for deeper workflow management.</li> </ol> <p>Unmapped items ensure that all Square/Shopify data ultimately maps to a clean, unified dataset in the inventory system.</p>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/","title":"Appendix C \u2013 Inventory Management Platform Comparison","text":"<p>This appendix compares mscrInventory to major commercial inventory platforms used in caf\u00e9s and retail environments. It highlights strengths, limitations, pricing expectations, and unique differentiators.</p>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#options-at-a-glance","title":"Options at a Glance","text":"Platform Strengths Limitations Typical Pricing Thrive Simple, lightweight, good for small caf\u00e9s Limited advanced analytics $$ MarketMan Vendor management, invoice scanning, multi\u2011location tools Complex setup, higher cost $$$$ MarginEdge Strong financial reporting, invoice processing Less granular ingredient modeling $$$$ BevSpot Excellent for beverage cost tracking Not food\u2011focused, limited recipe depth $$$ mscrInventory Fully customizable, relational recipe system, integrated Square/Shopify imports DIY hosting/maintenance, requires initial setup $ (self\u2011hosted)"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#detailed-comparison","title":"Detailed Comparison","text":""},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#thrive","title":"Thrive","text":"<ul> <li>Good for smaller operations  </li> <li>Simple stock workflows  </li> <li>Limited visibility into recipe\u2011level cost structures  </li> <li>Lacks advanced import reconciliation tools  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#marketman","title":"MarketMan","text":"<ul> <li>Great vendor and purchasing modules  </li> <li>Automated invoice scanning  </li> <li>Robust multi\u2011unit controls  </li> <li>High subscription costs  </li> <li>Requires adaptation to MarketMan\u2019s data modeling  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#marginedge","title":"MarginEdge","text":"<ul> <li>Finance\u2011driven system powering COGS and AP workflows  </li> <li>Strong invoice uploading and accounting integrations  </li> <li>Recipe modeling is functional but less flexible  </li> <li>Not designed for granular ingredient/packaging tracking  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#bevspot","title":"BevSpot","text":"<ul> <li>Beverage\u2011oriented inventory  </li> <li>Solid for bars or drink\u2011forward businesses  </li> <li>Recipe and food tracking minimal  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#mscrinventory","title":"mscrInventory","text":"<ul> <li>Fully relational ingredient \u2192 recipe \u2192 product workflow  </li> <li>Deep Square/Shopify integration  </li> <li>Clean UI with HTMX responsiveness  </li> <li>Does not require third\u2011party vendor onboarding  </li> <li>Agile and customizable for non\u2011standard workflows  </li> <li>Extremely low cost for long\u2011term maintenance  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#why-mscrinventory","title":"Why mscrInventory?","text":"<ol> <li>Direct control \u2014 tailor recipes, ingredients, and modifiers exactly to your menu.  </li> <li>Integrated parsing logic \u2014 Square and Shopify naming differences are handled gracefully.  </li> <li>Deep relational modeling \u2014 packaging, recipes, modifiers, and inventory map tightly.  </li> <li>Transparent pricing \u2014 no subscription required for self\u2011hosted deployments.  </li> <li>Operational clarity \u2014 clean dashboards, unmapped item workflows, and powerful filters.</li> </ol>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#when-to-choose-a-commercial-tool-instead","title":"When to Choose a Commercial Tool Instead","text":"<ul> <li>If you require automated invoice OCR (MarketMan, MarginEdge).  </li> <li>If you have multi\u2011unit corporate purchasing teams needing standardized PO systems.  </li> <li>If accounting/AP is your primary goal rather than recipe accuracy.  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#summary","title":"Summary","text":"<p>mscrInventory excels in: - caf\u00e9s with custom drink workflows - environments with many modifiers or seasonal items - teams that want direct control over ingredients and recipes - operations where cost and accuracy matter more than big\u2011vendor ecosystems  </p> <p>Commercial platforms may excel for: - large multi\u2011unit operations - accounting\u2011heavy workflows - organizations needing AP automation  </p> <p>Each option suits different needs, but mscrInventory offers exceptional flexibility, cost savings, and precision for ingredient\u2011driven caf\u00e9s.</p>"},{"location":"15_roadmap/01_Roadmap/","title":"Future Roadmap","text":"<p>The MSCR Inventory App continues to evolve based on operational needs, user feedback, and integration opportunities. This roadmap outlines major upcoming features, improvements, and long\u2011term goals.</p>"},{"location":"15_roadmap/01_Roadmap/#near-term-roadmap-high-priority","title":"Near-Term Roadmap (High Priority)","text":""},{"location":"15_roadmap/01_Roadmap/#direct-doordash-integration","title":"Direct DoorDash Integration","text":"<ul> <li>Replace the \u201cvia Square\u201d workflow with native DoorDash API sync.</li> <li>Support menu import, modifier synchronization, and order ingestion.</li> <li>Reduce unmapped items from DoorDash-specific naming.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#square-api-integration","title":"Square API Integration","text":"<ul> <li>Move beyond CSV uploads for Square.</li> <li>Real\u2011time or scheduled syncing for:</li> <li>Orders  </li> <li>Menu items  </li> <li>Modifiers  </li> <li>Categories  </li> <li>More accurate variant and price\u2011point mapping.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#improved-reporting","title":"Improved Reporting","text":"<ul> <li>Expanded dashboard widgets with:</li> <li>Category-level COGS  </li> <li>Supplier-level valuations  </li> <li>Trend lines over time  </li> <li>Multi-location aggregator support (if needed later).</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#automatedscheduled-syncing","title":"Automated/Scheduled Syncing","text":"<ul> <li>Nightly sync jobs for Square/Shopify imports.</li> <li>Optional \u201cauto\u2011map safe matches\u201d mode.</li> <li>Email-based import summaries.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#mid-term-roadmap-planned-enhancements","title":"Mid-Term Roadmap (Planned Enhancements)","text":""},{"location":"15_roadmap/01_Roadmap/#email-logs-stock-alerts","title":"Email Logs &amp; Stock Alerts","text":"<ul> <li>Low-stock warnings sent to managers.</li> <li>Import error summaries delivered automatically.</li> <li>Optional \u201cdaily operations digest.\u201d</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#vendor-automation-support","title":"Vendor Automation Support","text":"<ul> <li>Integrate cost updates from vendor CSVs.</li> <li>Auto-create purchase suggestions:</li> <li>Based on usage trends  </li> <li>Based on minimum reorder points  </li> <li>Future potential: direct purchase\u2011order workflow.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#enhanced-inventory-tools","title":"Enhanced Inventory Tools","text":"<ul> <li>Multi-location stock separation.</li> <li>Batch SKU assignment tools.</li> <li>Richer packaging logic for combination items.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#long-term-vision","title":"Long-Term Vision","text":""},{"location":"15_roadmap/01_Roadmap/#fully-automated-operations-loop","title":"Fully Automated Operations Loop","text":"<ul> <li>Orders \u2192 Usage \u2192 Purchasing \u2192 Replenishment  </li> <li>True closed-loop forecasting and inventory control.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#crossplatform-menu-intelligence","title":"Cross\u2011Platform Menu Intelligence","text":"<ul> <li>Unified menu detection across Square, Shopify, DoorDash, and others.</li> <li>Modifier frequency analysis for recipe optimization.</li> <li>Support for predictive seasonal planning.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#deep-analytics-portal","title":"Deep Analytics Portal","text":"<ul> <li>Advanced dashboards for:</li> <li>Profitability  </li> <li>Ingredient volatility  </li> <li>Labor x ingredient cost modeling  </li> <li>Export-friendly BI data layers.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#development-philosophy","title":"Development Philosophy","text":"<p>The project continues to follow these principles:</p> <ul> <li> <p>Minimal Dependencies   Simple, stable, maintainable tech stack.</p> </li> <li> <p>Human-Centric Workflows   Designed for baristas, supervisors, and managers\u2014not engineers.</p> </li> <li> <p>Transparent Operations   CSV import/export always available as a fallback or manual override.</p> </li> <li> <p>Incremental Enhancements   Each release focuses on refining the real workflows used daily.</p> </li> </ul>"},{"location":"15_roadmap/01_Roadmap/#summary","title":"Summary","text":"<p>The MSCR Inventory App aims to provide: - A deeply reliable inventory and recipe system - Dead-simple daily workflows - Strong integrations - Extremely low long-term cost - Flexibility for any caf\u00e9 or specialty drinks environment  </p> <p>This roadmap ensures that the system continues improving while preserving its core strengths: accuracy, clarity, and efficiency.</p>"},{"location":"16_API/","title":"API Reference","text":"<p>This section documents the internal Python modules that power the MSCR Inventory App.</p> <p>All pages auto-generate content from the actual source code using <code>mkdocstrings</code>.</p>"},{"location":"16_API/#available-modules","title":"Available Modules","text":"<ul> <li>Models</li> <li>Views</li> <li>Admin</li> <li>Forms</li> <li>Importers</li> <li>Management Commands</li> <li>Utilities</li> <li>Scripts</li> </ul>"},{"location":"16_API/admin/","title":"Admin API","text":"<p>import docs.django_setup </p> <p>Admin customizations for managing inventory, recipes, and imports.</p>"},{"location":"16_API/admin/#mscrInventory.admin.CategoryAdmin","title":"<code>CategoryAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Basic admin listing for taxonomy categories.</p>"},{"location":"16_API/admin/#mscrInventory.admin.ContainerTypeAdmin","title":"<code>ContainerTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>CRUD interface for reusable container definitions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.ImportLogAdmin","title":"<code>ImportLogAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Show high-level stats for each import run.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientAdmin","title":"<code>IngredientAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Main ingredient admin including stock history and inline helpers.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientTypeAdmin","title":"<code>IngredientTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage ingredient type classifications.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientUsageLogAdmin","title":"<code>IngredientUsageLogAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Expose aggregated usage rows for auditing deductions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderAdmin","title":"<code>OrderAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Expose imported orders with related line items.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderItemAdmin","title":"<code>OrderItemAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Allow inspection of imported order items independently.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderItemInline","title":"<code>OrderItemInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Show associated order items under an Order.</p>"},{"location":"16_API/admin/#mscrInventory.admin.PackagingInline","title":"<code>PackagingInline</code>","text":"<p>               Bases: <code>StackedInline</code></p> <p>Allow packaging metadata to be edited alongside an Ingredient.</p>"},{"location":"16_API/admin/#mscrInventory.admin.PackagingInline.filter_horizontal","title":"<code>filter_horizontal = ('expands_to',)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>def formfield_for_manytomany(self, db_field, request, *kwargs): if db_field.name == \"expands_to\":     kwargs[\"queryset\"] = Packaging.objects.all() return super().formfield_for_manytomany(db_field, request, *kwargs)</p>"},{"location":"16_API/admin/#mscrInventory.admin.ProductAdmin","title":"<code>ProductAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Product admin with inline recipe rows and modifier chooser.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeItemInline","title":"<code>RecipeItemInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Allow recipe items to be edited inline on the product page.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeModifierAdmin","title":"<code>RecipeModifierAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Admin panel for curated modifier catalog.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeModifierAliasInline","title":"<code>RecipeModifierAliasInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Inline editing for alias rows beneath a modifier.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RoastProfileInline","title":"<code>RoastProfileInline</code>","text":"<p>               Bases: <code>StackedInline</code></p> <p>Inline editor for roast profile attributes on roast ingredients.</p>"},{"location":"16_API/admin/#mscrInventory.admin.SizeLabelAdmin","title":"<code>SizeLabelAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage the display names for packaging size labels.</p>"},{"location":"16_API/admin/#mscrInventory.admin.SquareUnmappedItemAdmin","title":"<code>SquareUnmappedItemAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Front-end to resolve unmapped Square items.</p>"},{"location":"16_API/admin/#mscrInventory.admin.StockEntryAdmin","title":"<code>StockEntryAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Read-only dashboard for verifying stock additions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.StockEntryInline","title":"<code>StockEntryInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Display historical stock entries on the ingredient detail page.</p>"},{"location":"16_API/admin/#mscrInventory.admin.UnitTypeAdmin","title":"<code>UnitTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage measurement units and conversion ratios.</p>"},{"location":"16_API/admin/#mscrInventory.admin.UnmappedProductFilter","title":"<code>UnmappedProductFilter</code>","text":"<p>               Bases: <code>SimpleListFilter</code></p> <p>Filter that separates mapped vs unmapped placeholder products.</p>"},{"location":"16_API/forms/","title":"Forms API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized </p> <p>Forms for managing catalog, inventory, and unmapped Square data.</p>"},{"location":"16_API/forms/#mscrInventory.forms.CreateFromUnmappedItemForm","title":"<code>CreateFromUnmappedItemForm(*args, item, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Create a new record directly from an unmapped entry.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, item: SquareUnmappedItem, **kwargs):\n    self.item = item\n    super().__init__(*args, **kwargs)\n\n    self.is_known_recipe = bool(getattr(item, \"is_known_recipe\", False))\n    self.effective_item_type = \"product\" if self.is_known_recipe else item.item_type\n\n    # Initialise defaults from the unmapped item\n    self.fields[\"name\"].initial = item.price_point_name or item.item_name\n    self.fields[\"filter_type\"].initial = kwargs.get(\"initial\", {}).get(\"filter_type\")\n\n    if self.effective_item_type == \"product\":\n        self.fields[\"sku\"].required = False\n        self.fields[\"sku\"].initial = self._generate_default_sku(item)\n    else:\n        self.fields.pop(\"sku\")\n\n    if self.effective_item_type == \"ingredient\":\n        self.fields[\"ingredient_type\"].required = False\n    else:\n        self.fields.pop(\"ingredient_type\")\n\n    if self.effective_item_type == \"modifier\":\n        self.fields[\"modifier_ingredient\"].required = True\n        self.fields[\"behavior\"].required = True\n        self.fields[\"behavior\"].initial = RecipeModifier.ModifierBehavior.ADD\n        self.fields[\"base_quantity\"].required = True\n        self.fields[\"unit\"].required = True\n    else:\n        for field in (\n            \"modifier_ingredient\",\n            \"modifier_type\",\n            \"behavior\",\n            \"base_quantity\",\n            \"unit\",\n        ):\n            self.fields.pop(field)\n\n    for name, field in self.fields.items():\n        if name == \"filter_type\":\n            continue\n        css_class = \"form-select\" if isinstance(field.widget, forms.Select) else \"form-control\"\n        field.widget.attrs.setdefault(\"class\", css_class)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm","title":"<code>IngredientForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Primary form for creating or editing Ingredient records.</p> <p>Apply consistent Bootstrap styling to all fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Apply consistent Bootstrap styling to all fields.\"\"\"\n    super().__init__(*args, **kwargs)\n    for field_name, field in self.fields.items():\n        widget = field.widget\n        existing = widget.attrs.get(\"class\", \"\")\n        widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n        widget.attrs.setdefault(\"autocomplete\", \"off\")\n        if isinstance(widget, forms.Textarea):\n            widget.attrs.setdefault(\"rows\", 3)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm.requires_packaging_fields","title":"<code>requires_packaging_fields(type_obj)</code>  <code>classmethod</code>","text":"<p>Return True when packaging-specific fields should be shown.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>@classmethod\ndef requires_packaging_fields(cls, type_obj) -&gt; bool:\n    \"\"\"Return True when packaging-specific fields should be shown.\"\"\"\n    return cls._requires_type(type_obj, cls.PACKAGING_TYPE_NAMES)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm.requires_roast_fields","title":"<code>requires_roast_fields(type_obj)</code>  <code>classmethod</code>","text":"<p>Return True when roast-specific fields should be shown.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>@classmethod\ndef requires_roast_fields(cls, type_obj) -&gt; bool:\n    \"\"\"Return True when roast-specific fields should be shown.\"\"\"\n    return cls._requires_type(type_obj, cls.ROAST_TYPE_NAMES)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.LinkUnmappedItemForm","title":"<code>LinkUnmappedItemForm(*args, item, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Resolve an unmapped item by linking to an existing record.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, item: SquareUnmappedItem, **kwargs):\n    self.item = item\n    super().__init__(*args, **kwargs)\n\n    field_kwargs = {\"required\": True}\n    if getattr(item, \"is_known_recipe\", False):\n        field_kwargs[\"queryset\"] = Product.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Product\"\n    elif item.item_type == \"product\":\n        field_kwargs[\"queryset\"] = Product.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Product\"\n    elif item.item_type == \"ingredient\":\n        field_kwargs[\"queryset\"] = Ingredient.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Ingredient\"\n    else:\n        field_kwargs[\"queryset\"] = RecipeModifier.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Modifier\"\n\n    self.fields[\"target\"] = forms.ModelChoiceField(**field_kwargs)\n    css_class = \"form-select\" if isinstance(self.fields[\"target\"].widget, forms.Select) else \"form-control\"\n    self.fields[\"target\"].widget.attrs.setdefault(\"class\", css_class)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PackagingForm","title":"<code>PackagingForm(*args, ingredient=None, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Collect packaging preferences for a given Ingredient.</p> <p>Pre-populate with saved Packaging data and style widgets.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, ingredient: Ingredient | None = None, **kwargs):\n    \"\"\"Pre-populate with saved Packaging data and style widgets.\"\"\"\n    super().__init__(*args, **kwargs)\n    packaging = None\n    if ingredient:\n        try:\n            packaging = ingredient.packaging\n        except Packaging.DoesNotExist:\n            packaging = None\n        expands_field = self.fields.get(\"expands_to\")\n        if expands_field is not None:\n            expands_field.queryset = expands_field.queryset.exclude(pk=ingredient.pk)\n\n    if not self.is_bound and packaging:\n        self.initial.setdefault(\"container\", packaging.container_id)\n        self.initial.setdefault(\"temp\", packaging.temp)\n        self.initial.setdefault(\"multiplier\", packaging.multiplier)\n        self.initial.setdefault(\n            \"size_labels\",\n            list(packaging.size_labels.values_list(\"pk\", flat=True)),\n        )\n        self.initial.setdefault(\n            \"expands_to\",\n            list(packaging.expands_to.values_list(\"pk\", flat=True)),\n        )\n\n    for field_name, field in self.fields.items():\n        widget = field.widget\n        existing = widget.attrs.get(\"class\", \"\")\n        if isinstance(field, forms.ModelMultipleChoiceField):\n            widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n            widget.attrs.setdefault(\"multiple\", True)\n            widget.attrs.setdefault(\"size\", 4)\n        elif isinstance(field, forms.ModelChoiceField) or isinstance(field, forms.ChoiceField):\n            widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n        else:\n            widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm","title":"<code>ProductForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Bootstrap-friendly CRUD form for Product records.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    for field_name, field in self.fields.items():\n        if field_name == \"categories\":\n            field.widget = forms.SelectMultiple(attrs={\"class\": \"form-select\", \"size\": 6})\n        else:\n            existing = field.widget.attrs.get(\"class\", \"\")\n            field.widget.attrs[\"class\"] = (existing + \" form-control\").strip()\n        field.widget.attrs.setdefault(\"autocomplete\", \"off\")\n\n        if self.is_bound and field_name in self.errors:\n            css = field.widget.attrs.get(\"class\", \"\")\n            field.widget.attrs[\"class\"] = f\"{css} is-invalid\".strip()\n\n    self.fields[\"sku\"].required = False\n    self.fields[\"shopify_id\"].required = False\n    self.fields[\"square_id\"].required = False\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.clean_name","title":"<code>clean_name()</code>","text":"<p>Normalize whitespace around the submitted name.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean_name(self):\n    \"\"\"Normalize whitespace around the submitted name.\"\"\"\n    return (self.cleaned_data.get(\"name\") or \"\").strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.clean_sku","title":"<code>clean_sku()</code>","text":"<p>Ensure the SKU is unique and auto-generate one if omitted.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean_sku(self):\n    \"\"\"Ensure the SKU is unique and auto-generate one if omitted.\"\"\"\n    sku = (self.cleaned_data.get(\"sku\") or \"\").strip()\n\n    qs = Product.objects.all()\n    if self.instance.pk:\n        qs = qs.exclude(pk=self.instance.pk)\n\n    if not sku:\n        base_name = self.cleaned_data.get(\"name\") or getattr(self.instance, \"name\", \"\")\n        base_name = (base_name or \"product\").strip()\n\n        while True:\n            sku = generate_auto_sku(base_name)\n            if not qs.filter(sku__iexact=sku).exists():\n                break\n    else:\n        if qs.filter(sku__iexact=sku).exists():\n            raise forms.ValidationError(\"A product with this SKU already exists.\")\n\n    return sku\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.save","title":"<code>save(commit=True)</code>","text":"<p>Persist the product while normalizing key text fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Persist the product while normalizing key text fields.\"\"\"\n    instance = super().save(commit=False)\n    instance.name = (self.cleaned_data.get(\"name\") or \"\").strip()\n    instance.sku = (self.cleaned_data.get(\"sku\") or \"\").strip()\n    if commit:\n        instance.save()\n        self.save_m2m()\n    return instance\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm","title":"<code>PublicUserCreateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Self-service registration form used on the public site.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    for field in self.fields.values():\n        existing = field.widget.attrs.get(\"class\", \"\")\n        field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm.clean","title":"<code>clean()</code>","text":"<p>Validate that passwords match and meet strength requirements.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate that passwords match and meet strength requirements.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 != password2:\n        raise forms.ValidationError(\"Passwords do not match.\")\n    if password1:\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Create an inactive user pending admin approval.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Create an inactive user pending admin approval.\"\"\"\n    user = super().save(commit=False)\n    user.is_active = False\n    user.is_staff = False\n    user.set_password(self.cleaned_data[\"password1\"])\n    if commit:\n        user.save()\n    return user\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.RoastProfileForm","title":"<code>RoastProfileForm(*args, ingredient=None, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Supplemental form for roast bag metadata.</p> <p>Prefill defaults from an existing RoastProfile (if any).</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, ingredient: Ingredient | None = None, **kwargs):\n    \"\"\"Prefill defaults from an existing RoastProfile (if any).\"\"\"\n    super().__init__(*args, **kwargs)\n    profile = None\n    if ingredient:\n        try:\n            profile = ingredient.roastprofile\n        except RoastProfile.DoesNotExist:\n            profile = None\n\n    if not self.is_bound:\n        self.initial.setdefault(\n            \"bag_size\",\n            profile.bag_size if profile else RoastProfile._meta.get_field(\"bag_size\").get_default(),\n        )\n        self.initial.setdefault(\n            \"grind\",\n            profile.grind if profile else RoastProfile._meta.get_field(\"grind\").get_default(),\n        )\n\n    for field in self.fields.values():\n        existing = field.widget.attrs.get(\"class\", \"\")\n        field.widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm","title":"<code>UserCreateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Internal admin form for provisioning a new Django user.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.fields[\"groups\"].queryset = Group.objects.order_by(\"name\")\n    if \"is_active\" in self.fields:\n        self.fields[\"is_active\"].initial = True\n    for name, field in self.fields.items():\n        if name == \"groups\":\n            continue\n        existing = field.widget.attrs.get(\"class\", \"\")\n        if isinstance(field.widget, forms.CheckboxInput):\n            field.widget.attrs[\"class\"] = f\"{existing} form-check-input\".strip()\n        else:\n            field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm.clean","title":"<code>clean()</code>","text":"<p>Validate matching passwords and run Django's password validators.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate matching passwords and run Django's password validators.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 != password2:\n        raise forms.ValidationError(\"Passwords do not match.\")\n    if password1:\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Persist the user with the provided password.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Persist the user with the provided password.\"\"\"\n    user = super().save(commit=False)\n    user.set_password(self.cleaned_data[\"password1\"])\n    if commit:\n        user.save()\n        self.save_m2m()\n    return user\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm","title":"<code>UserUpdateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Admin form for updating an existing Django user.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.fields[\"groups\"].queryset = Group.objects.order_by(\"name\")\n    for name, field in self.fields.items():\n        if name == \"groups\":\n            continue\n        existing = field.widget.attrs.get(\"class\", \"\")\n        if isinstance(field.widget, forms.CheckboxInput):\n            field.widget.attrs[\"class\"] = f\"{existing} form-check-input\".strip()\n        else:\n            field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm.clean","title":"<code>clean()</code>","text":"<p>Validate optional password change fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate optional password change fields.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 or password2:\n        if password1 != password2:\n            raise forms.ValidationError(\"Passwords do not match.\")\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Update user details and optionally reset the password.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Update user details and optionally reset the password.\"\"\"\n    user = super().save(commit=False)\n    password = self.cleaned_data.get(\"password1\")\n    if password:\n        user.set_password(password)\n    if commit:\n        user.save()\n        self.save_m2m()\n    return user\n</code></pre>"},{"location":"16_API/importers/","title":"Importers API","text":"<p>import docs.django_setup </p> <p>Importer package housing Square and Shopify ingestion logic.</p>"},{"location":"16_API/importers/#importers.ShopifyImporter","title":"<code>ShopifyImporter(*, dry_run=False, log_to_console=True, report=False, report_dir=None)</code>","text":"<p>               Bases: <code>BaseImporter</code></p> <p>Importer that fetches and persists Shopify orders.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def __init__(\n    self,\n    *,\n    dry_run: bool = False,\n    log_to_console: bool = True,\n    report: bool = False,\n    report_dir: str | None = None,\n):\n    super().__init__(\n        dry_run=dry_run,\n        log_to_console=log_to_console,\n        report=report,\n        report_dir=report_dir,\n    )\n    self.usage_totals: dict[int, Decimal] = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_totals_by_date: dict[dt.date, dict[int, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self.usage_breakdown: dict[int, dict[str, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self._retail_bag_product: Product | None = None\n    self._default_usage_date: dt.date | None = None\n    self._summary_added = False\n    self._summary_cache: list[str] | None = None\n    self.counters.setdefault(\"matched\", 0)\n\n    self._bag_weight_cache: dict[str, Decimal] = {\n        \"3oz\": Decimal(\"3\"),\n        \"11oz\": Decimal(\"11\"),\n        \"20oz\": Decimal(\"20\"),\n        \"5lb\": Decimal(\"80\"),\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.get_summary","title":"<code>get_summary()</code>","text":"<p>Expose the formatted summary without duplicating output.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"Expose the formatted summary without duplicating output.\"\"\"\n\n    return self.summarize()\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.get_usage_breakdown","title":"<code>get_usage_breakdown()</code>","text":"<p>Return a copy of the usage breakdown keyed by ingredient name.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def get_usage_breakdown(self) -&gt; dict[str, dict[str, Decimal]]:\n    \"\"\"Return a copy of the usage breakdown keyed by ingredient name.\"\"\"\n\n    result: dict[str, dict[str, Decimal]] = {}\n    for ingredient_id, per_source in self.usage_breakdown.items():\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        result[name] = dict(per_source)\n    return result\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.get_usage_totals","title":"<code>get_usage_totals()</code>","text":"<p>Expose aggregated ingredient usage totals keyed by ingredient id.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def get_usage_totals(self) -&gt; dict[int, Decimal]:\n    \"\"\"Expose aggregated ingredient usage totals keyed by ingredient id.\"\"\"\n\n    return {\n        ingredient_id: qty for ingredient_id, qty in self.usage_totals.items() if qty &gt; 0\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.get_usage_totals_by_date","title":"<code>get_usage_totals_by_date()</code>","text":"<p>Expose aggregated ingredient usage keyed by business date.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def get_usage_totals_by_date(self) -&gt; dict[dt.date, dict[int, Decimal]]:\n    \"\"\"Expose aggregated ingredient usage keyed by business date.\"\"\"\n\n    results: dict[dt.date, dict[int, Decimal]] = {}\n    for usage_date, totals in self.usage_totals_by_date.items():\n        filtered = {ing_id: qty for ing_id, qty in totals.items() if qty &gt; 0}\n        if filtered:\n            results[usage_date] = filtered\n    return results\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.import_window","title":"<code>import_window(start_utc, end_utc, *, orders=None)</code>","text":"<p>Import Shopify orders for the provided UTC window.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def import_window(\n    self,\n    start_utc: dt.datetime,\n    end_utc: dt.datetime,\n    *,\n    orders: Iterable[dict[str, Any]] | None = None,\n) -&gt; dict[int, Decimal]:\n    \"\"\"Import Shopify orders for the provided UTC window.\"\"\"\n\n    self._reset_run_state()\n    if start_utc.tzinfo is None or end_utc.tzinfo is None:\n        raise ValueError(\"start_utc and end_utc must be timezone-aware\")\n\n    if orders is None:\n        orders = self._fetch_orders(start_utc, end_utc)\n\n    self.log(\n        f\"Processing Shopify orders between {start_utc.isoformat()} and {end_utc.isoformat()}\",\n        \"\ud83d\ude9a\",\n    )\n\n    self.usage_totals.clear()\n    self.usage_totals_by_date.clear()\n    self.usage_breakdown.clear()\n\n    tzname = getattr(settings, \"SYNC_TIMEZONE\", \"America/New_York\")\n    tz = ZoneInfo(tzname)\n    self._default_usage_date = start_utc.astimezone(tz).date()\n\n    with transaction.atomic():\n        for raw_order in orders:\n            self.process_row(raw_order)\n\n    self.log_usage_breakdown()\n\n    self.summarize()\n    return dict(self.usage_totals)\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.log_usage_breakdown","title":"<code>log_usage_breakdown()</code>","text":"<p>Log a human-readable breakdown of ingredient usage per source.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def log_usage_breakdown(self) -&gt; None:\n    \"\"\"Log a human-readable breakdown of ingredient usage per source.\"\"\"\n    if not self.usage_totals:\n        return\n    lines = [\"Ingredient usage breakdown:\"]\n    for ingredient_id, total_qty in sorted(self.usage_totals.items(), key=lambda item: item[0]):\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        lines.append(f\"- {name}: {_format_decimal(total_qty)} total\")\n        breakdown = self.usage_breakdown.get(ingredient_id, {})\n        for source, qty in sorted(breakdown.items(), key=lambda item: item[0]):\n            lines.append(f\"    \u2022 {source}: {_format_decimal(qty)}\")\n    message = \"\\n\".join(lines)\n    self.log(message, \"\ud83d\udce6\")\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.process_row","title":"<code>process_row(raw_order)</code>","text":"<p>Normalize and persist a single Shopify order.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def process_row(self, raw_order: dict[str, Any]) -&gt; None:  # type: ignore[override]\n    \"\"\"Normalize and persist a single Shopify order.\"\"\"\n\n    normalized = self._normalize_order(raw_order)\n    order_id = normalized[\"order_id\"]\n    line_items = normalized[\"items\"]\n\n    self.log(\n        f\"Order {order_id}: {len(line_items)} line item(s) totalling {normalized['total_amount']}\",\n        \"\ud83e\uddfe\",\n    )\n\n    order_lookup = {\"order_id\": order_id, \"platform\": self.platform}\n    defaults = {\n        \"order_date\": normalized[\"order_date\"],\n        \"total_amount\": normalized[\"total_amount\"],\n        \"data_raw\": _json_safe(normalized[\"raw\"]),\n        \"synced_at\": timezone.now(),\n    }\n\n    order_obj, created = self.create_or_update(Order, order_lookup, defaults)\n\n    if self.dry_run:\n        action = \"Would create\" if created else \"Would update\"\n        self.log(f\"\ud83e\uddea {action} {len(line_items)} order item(s) for {order_id}\")\n    else:\n        order_obj.items.all().delete()\n\n    for item in line_items:\n        product = item.get(\"product\")\n        if not product:\n            self.counters[\"unmapped\"] += 1\n            self.log(\n                f\"\u26a0\ufe0f  Unmapped Shopify item '{item.get('title')}' (SKU: {item.get('sku')})\",\n                \"\u26a0\ufe0f\",\n            )\n        else:\n            self.counters[\"matched\"] = self.counters.get(\"matched\", 0) + 1\n\n        quantity = item.get(\"quantity\", 0)\n        if self.dry_run:\n            self.log(\n                f\"\ud83e\uddea Would record {quantity}x {item.get('title')} (product={'mapped' if product else 'missing'})\",\n                \"\ud83e\uddea\",\n            )\n        else:\n            variant_payload = _json_safe(item.get(\"variant_info\", {}))\n            if quantity &gt; 0:\n                OrderItem.objects.create(\n                    order=order_obj,\n                    product=product,\n                    quantity=quantity,\n                    unit_price=item[\"unit_price\"],\n                    variant_info=variant_payload,\n                )\n\n        self._track_usage_from_item(item, order_date=normalized[\"order_date\"])\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.summarize","title":"<code>summarize()</code>","text":"<p>Render a Square-style summary for Shopify imports.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def summarize(self) -&gt; str:  # type: ignore[override]\n    \"\"\"Render a Square-style summary for Shopify imports.\"\"\"\n\n    if self._summary_added and self._summary_cache is not None:\n        return \"\\n\".join(self._summary_cache)\n\n    end_time = timezone.now()\n    elapsed = (end_time - self.start_time).total_seconds()\n    summary_lines = [\n        \"\",\n        \"\ud83d\udcca Shopify Import Summary\",\n        f\"Started: {self.start_time:%Y-%m-%d %H:%M:%S}\",\n        f\"Elapsed: {elapsed:.2f}s\",\n        \"\",\n        f\"\ud83e\uddfe Orders added: {self.counters.get('added', 0)}\",\n        f\"\ud83d\udd04 Orders updated: {self.counters.get('updated', 0)}\",\n        f\"\u2705 Items matched: {self.counters.get('matched', 0)}\",\n        f\"\u26a0\ufe0f Unmapped items: {self.counters.get('unmapped', 0)}\",\n        f\"\u23ed\ufe0f Skipped: {self.counters.get('skipped', 0)}\",\n        f\"\u274c Errors: {self.counters.get('errors', 0)}\",\n        \"\u2705 Dry-run complete.\" if self.dry_run else \"\u2705 Import complete.\",\n    ]\n\n    if self.buffer.tell() &gt; 0 and not self.buffer.getvalue().endswith(\"\\n\"):\n        self.buffer.write(\"\\n\")\n\n    summary_text = \"\\n\".join(summary_lines)\n    self.buffer.write(summary_text + \"\\n\")\n\n    if self.log_to_console:\n        print(summary_text)\n\n    if self.report_enabled:\n        self._write_report(elapsed)\n\n    self._summary_added = True\n    self._summary_cache = summary_lines\n    return summary_text\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter","title":"<code>SquareImporter(dry_run=False)</code>","text":"<p>Handles parsing and importing Square CSV exports.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def __init__(self, dry_run: bool = False):\n    self.dry_run = dry_run\n    self.buffer: list[str] = []\n    self.stats = {\n        \"rows_processed\": 0,\n        \"matched\": 0,\n        \"unmatched\": 0,\n        \"order_items_logged\": 0,\n        \"modifiers_applied\": 0,\n        \"errors\": 0,\n    }\n    self._summary_added = False\n    self._summary_cache: list[str] | None = None\n    self._last_run_started: datetime.datetime | None = None\n    self._last_run_finished: datetime.datetime | None = None\n    self._current_order: Order | None = None\n    self._orders_by_transaction: dict[str, Order | None] = {}\n    self._unmapped_seen_keys: set[tuple[str, str, str]] = set()\n    self.usage_totals: defaultdict[int, Decimal] = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_totals_by_date: dict[datetime.date | None, dict[int, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self.usage_breakdown: defaultdict[int, defaultdict[str, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self._ingredient_cache: dict[str, Ingredient | None] = {}\n    self._normalized_modifier_names: set[str] | None = None\n    self._normalized_ingredient_names: set[str] | None = None\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_output","title":"<code>get_output()</code>","text":"<p>Return concatenated importer log output.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_output(self) -&gt; str:\n    \"\"\"Return concatenated importer log output.\"\"\"\n    \"\"\"Return the collected log as a single string.\"\"\"\n    return \"\\n\".join(self.buffer)\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_run_metadata","title":"<code>get_run_metadata()</code>","text":"<p>Expose structured metadata about the previous run.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_run_metadata(self) -&gt; dict:\n    \"\"\"Expose structured metadata about the previous run.\"\"\"\n    \"\"\"Return structured metadata about the most recent run.\"\"\"\n    stats = dict(self.stats)\n    started_at = self._last_run_started\n    finished_at = self._last_run_finished\n    duration = None\n    if started_at and finished_at:\n        duration = (finished_at - started_at).total_seconds()\n\n    return {\n        \"started_at\": started_at,\n        \"finished_at\": finished_at,\n        \"duration_seconds\": duration,\n        \"stats\": stats,\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_summary","title":"<code>get_summary()</code>","text":"<p>Return the formatted summary for display (without mutating twice).</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"Return the formatted summary for display (without mutating twice).\"\"\"\n    return self.summarize()\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_usage_breakdown","title":"<code>get_usage_breakdown()</code>","text":"<p>Return ingredient usage grouped by ingredient name and source label.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_usage_breakdown(self) -&gt; dict[str, dict[str, Decimal]]:\n    \"\"\"Return ingredient usage grouped by ingredient name and source label.\"\"\"\n    result: dict[str, dict[str, Decimal]] = {}\n    for ingredient_id, per_source in self.usage_breakdown.items():\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        result[name] = dict(per_source)\n    return result\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_usage_totals","title":"<code>get_usage_totals()</code>","text":"<p>Expose aggregated ingredient usage totals keyed by id.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_usage_totals(self) -&gt; dict[int, Decimal]:\n    \"\"\"Expose aggregated ingredient usage totals keyed by id.\"\"\"\n    return {\n        ingredient_id: qty\n        for ingredient_id, qty in self.usage_totals.items()\n        if qty &gt; 0\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_usage_totals_by_date","title":"<code>get_usage_totals_by_date()</code>","text":"<p>Expose aggregated ingredient usage totals grouped by business date (or None).</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_usage_totals_by_date(self) -&gt; dict[datetime.date | None, dict[int, Decimal]]:\n    \"\"\"Expose aggregated ingredient usage totals grouped by business date (or None).\"\"\"\n\n    results: dict[datetime.date | None, dict[int, Decimal]] = {}\n    for usage_date, totals in self.usage_totals_by_date.items():\n        filtered = {ingredient_id: qty for ingredient_id, qty in totals.items() if qty &gt; 0}\n        if filtered:\n            results[usage_date] = filtered\n    return results\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.run_from_file","title":"<code>run_from_file(file_path)</code>","text":"<p>Run import from a given CSV file.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def run_from_file(self, file_path: Path):\n    \"\"\"Run import from a given CSV file.\"\"\"\n    self.buffer = []\n    self.stats = {\n        \"rows_processed\": 0,\n        \"matched\": 0,\n        \"unmatched\": 0,\n        \"order_items_logged\": 0,\n        \"modifiers_applied\": 0,\n        \"errors\": 0,\n    }\n    self.usage_totals = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_totals_by_date: dict[datetime.date | None, dict[int, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self.usage_breakdown = defaultdict(lambda: defaultdict(lambda: Decimal(\"0\")))\n    self._ingredient_cache = {}\n    start_time = timezone.now()\n    self._last_run_started = start_time\n    self._summary_added = False\n    self._summary_cache = None\n    self._unmapped_seen_keys = set()\n    self._orders_by_transaction = {}\n    self.buffer.append(\n        f\"\ud83d\udce5 Importing {file_path.name} ({'dry-run' if self.dry_run else 'live'})\"\n    )\n\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    context = nullcontext() if self.dry_run else transaction.atomic()\n\n    with context:\n        if not self.dry_run:\n            self._current_order = None\n        with open(file_path, newline=\"\", encoding=\"utf-8-sig\") as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self._process_row(row, file_path=file_path)\n\n        self.summarize()\n\n        if self.dry_run:\n            self._current_order = None\n\n    self._last_run_finished = timezone.now()\n    self._current_order = None\n    return self.get_output()\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.summarize","title":"<code>summarize()</code>","text":"<p>Generate and cache a run summary with timing and counts.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def summarize(self):\n    \"\"\"Generate and cache a run summary with timing and counts.\"\"\"\n    if self._summary_added and self._summary_cache is not None:\n        return \"\\n\".join(self._summary_cache)\n\n    start_time = self._last_run_started or timezone.now()\n    end_time = self._last_run_finished or timezone.now()\n    elapsed = (end_time - start_time).total_seconds()\n\n    summary_lines = [\n        \"\",\n        \"\ud83d\udcca Square Import Summary\",\n        f\"Started: {start_time:%Y-%m-%d %H:%M:%S}\",\n        f\"Elapsed: {elapsed:.2f}s\",\n        \"\",\n        f\"\ud83e\uddfe Rows processed: {self.stats['rows_processed']}\",\n        f\"\u2705 Products matched: {self.stats['matched']}\",\n        f\"\u26a0\ufe0f Unmatched items: {self.stats['unmatched']}\",\n        f\"\ud83e\uddfa Order items logged: {self.stats['order_items_logged']}\",\n        f\"\ud83e\udde9 Modifiers applied: {self.stats['modifiers_applied']}\",\n        f\"\u274c Errors: {self.stats['errors']}\",\n        \"\u2705 Dry-run complete.\" if self.dry_run else \"\u2705 Import complete.\",\n    ]\n\n    self.buffer.extend(summary_lines)\n    self._summary_added = True\n    self._summary_cache = summary_lines\n    return \"\\n\".join(summary_lines)\n</code></pre>"},{"location":"16_API/management_commands/","title":"Management Commands API","text":"<p>import docs.django_setup</p>"},{"location":"16_API/management_commands/#imports-and-syncing","title":"Imports and syncing","text":"<p>Wrap the SquareImporter for CLI execution with optional usage logging.</p> <p>Load Shopify orders from a CSV and run the Shopify importer without the API.</p> <p>Import product catalog data (with categories) from CSV.</p> <p>Import historical ingredient rows from a simplified CSV.</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 import_chemistry.py \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 Purpose:     This management command performs a controlled import of \u201cchemistry\u201d data \u2014     the authoritative definitions for ingredients and recipe modifiers used     throughout the MSCR Inventory app.</p> <pre><code>It reads a curated CSV file (usually created manually in Numbers or Excel)\nand ensures that all Ingredient and RecipeModifier records are up to date.\n\nTypical use:\n    python manage.py import_chemistry --file path/to/chemistry.csv\n</code></pre> Data model alignment <ul> <li>Updates Ingredient.average_cost_per_unit (not cost_per_unit).</li> <li>Retains price_per_unit for future COGS integration.</li> <li>Auto-creates IngredientType and UnitType references as needed.</li> <li>Skips malformed rows and logs every action.</li> </ul> <p>Logging &amp; safety:     - Each row is processed in an independent savepoint to prevent partial       transaction failures.     - Logs all actions (create, update, skip, error) to both console and       archive/logs/import_chemistry_.log. CSV columns required <p>type,name,unit_type,base_quantity,size_multiplier, cost_per_unit,price_per_unit,modifier_type,create_ingredient,create_modifier</p> Row customization flags <ul> <li>create_ingredient (defaults to TRUE when omitted) lets a row update or   skip touching Ingredient records.</li> <li>create_modifier (defaults to TRUE when omitted) lets a row update or   skip touching RecipeModifier records.</li> </ul> Example rows <p>ingredient,Espresso Beans,oz,1,False,0.45,0.90,BASE,TRUE,TRUE ingredient,Holiday Syrup,oz,1,False,0.75,1.10,FLAVOR,FALSE,TRUE ingredient,Winter Blend,lb,1,False,18.00,0.00,COFFEE,TRUE,FALSE</p> Maintainers <p>Use this command when updating your core recipe \u201cchemistry\u201d or ingredient cost definitions. It should not be used for daily sync operations (handled by import_square_csv.py and sync_orders.py).</p> <p>\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500</p> <p>Management command to synchronise Shopify orders and ingredient usage.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_square.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Stream Square CSV rows into the SquareImporter.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_shopify_csv.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Feed mock Shopify orders to the importer using CSV data.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_products_csv.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Create or update Product rows from a structured CSV.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_products_csv.generate_auto_sku","title":"<code>generate_auto_sku(name)</code>","text":"<p>Generate a stable-ish auto SKU from the name. We slugify the name and append a short unique suffix to avoid collisions. Example: \"B-Stingah Latte\" \u2192 \"ag-b-stingah-latte-3f2a\"</p> Source code in <code>mscrInventory/management/commands/import_products_csv.py</code> <pre><code>def generate_auto_sku(name: str) -&gt; str:\n    \"\"\"\n    Generate a stable-ish auto SKU from the name.\n    We slugify the name and append a short unique suffix to avoid collisions.\n    Example: \"B-Stingah Latte\" \u2192 \"ag-b-stingah-latte-3f2a\"\n    \"\"\"\n    base_slug = slugify(name)[:40]  # keep it manageable\n    suffix = uuid4().hex[:4]\n    return f\"ag-{base_slug}-{suffix}\"\n</code></pre>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_legacy_ingredients.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Map legacy CSV columns into Ingredient rows.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.import_chemistry.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Import curated chemistry CSV rows for ingredients and modifiers.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.sync_orders.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Synchronize Shopify orders, log usage, and notify low-stock items.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.sync_orders.nyc_day_window","title":"<code>nyc_day_window(target_date)</code>","text":"<p>Return the UTC start/end datetimes for the cafe day in New York.</p> Source code in <code>mscrInventory/management/commands/sync_orders.py</code> <pre><code>def nyc_day_window(target_date: datetime.date) -&gt; tuple[datetime.datetime, datetime.datetime]:\n    \"\"\"Return the UTC start/end datetimes for the cafe day in New York.\"\"\"\n\n    tz = ZoneInfo(getattr(settings, \"SYNC_TIMEZONE\", \"America/New_York\"))\n    start_local = datetime.datetime.combine(target_date, datetime.time.min, tzinfo=tz)\n    end_local = datetime.datetime.combine(target_date, datetime.time.max, tzinfo=tz)\n    return start_local.astimezone(datetime.timezone.utc), end_local.astimezone(datetime.timezone.utc)\n</code></pre>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.sync_orders.write_usage_logs","title":"<code>write_usage_logs(usage_by_date, *, source, default_date=None)</code>","text":"<p>Upsert IngredientUsageLog rows keyed by their order (business) date.</p> Source code in <code>mscrInventory/management/commands/sync_orders.py</code> <pre><code>def write_usage_logs(\n    usage_by_date: Dict[datetime.date, Dict[int, Decimal]] | None,\n    *,\n    source: str,\n    default_date: datetime.date | None = None,\n) -&gt; None:\n    \"\"\"Upsert IngredientUsageLog rows keyed by their order (business) date.\"\"\"\n\n    if not usage_by_date:\n        return\n\n    for usage_date, usage in usage_by_date.items():\n        target_date = usage_date or default_date or timezone.localdate()\n        if not target_date:\n            continue\n        for ingredient_id, qty in usage.items():\n            quantity = Decimal(qty)\n            if quantity &lt;= 0:\n                continue\n            quantity = quantity.quantize(Decimal(\"0.001\"))\n            log, created = IngredientUsageLog.objects.get_or_create(\n                ingredient_id=ingredient_id,\n                date=target_date,\n                source=source,\n                defaults=dict(quantity_used=quantity, calculated_from_orders=True),\n            )\n            if not created:\n                log.quantity_used = quantity\n                log.calculated_from_orders = True\n                log.save(update_fields=[\"quantity_used\", \"calculated_from_orders\", \"note\"])\n</code></pre>"},{"location":"16_API/management_commands/#data-hygiene-and-utilities","title":"Data hygiene and utilities","text":"<p>Management command to clean up invalid or duplicate RecipeItem rows.</p> <p>Management command to purge import-related data with a safe snapshot.</p> <p>Export COGS and usage CSV reports for a date range.</p> <p>Seed minimal demo data for manual testing.</p> <p>Management command to verify Shopify API credentials.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.clean_empty_recipeitems.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Remove empty RecipeItems and optionally orphaned Ingredients.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.purge_import_data.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Snapshot and delete import-related tables for fresh test runs.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.export_reports.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Write summarized and detailed reporting CSVs to disk.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.seed_demo_data.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Populate sample ingredients, stock, and recipes.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.test_shopify_connection.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Ping the Shopify API with the configured credentials.</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.test_square_row--test_square_rowpy","title":"test_square_row.py","text":"<p>Command to test parsing and import logic for a single row of a Square CSV file using the same logic as SquareImporter.</p> Usage <p>python manage.py test_square_row --file squareCSVs/squareCSV_importTest1.csv --row 2 --verbose</p>"},{"location":"16_API/management_commands/#mscrInventory.management.commands.test_square_row.Command","title":"<code>Command</code>","text":"<p>               Bases: <code>BaseCommand</code></p> <p>Exercise SquareImporter logic against a single CSV row.</p>"},{"location":"16_API/models/","title":"Models API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized </p> <p>Database models that power inventory, ordering, and import workflows.</p>"},{"location":"16_API/models/#mscrInventory.models.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>Model</code></p> <p>Simple taxonomy bucket for grouping Products.</p>"},{"location":"16_API/models/#mscrInventory.models.ContainerType","title":"<code>ContainerType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Reusable container description for packaging selections.</p>"},{"location":"16_API/models/#mscrInventory.models.ImportLog","title":"<code>ImportLog</code>","text":"<p>               Bases: <code>Model</code></p> <p>Tracks file-based or API imports, counts, and outcomes.</p>"},{"location":"16_API/models/#mscrInventory.models.Ingredient","title":"<code>Ingredient</code>","text":"<p>               Bases: <code>Model</code></p> <p>Inventory tracked item with measurement, costing, and notes.</p>"},{"location":"16_API/models/#mscrInventory.models.Ingredient.decrement_stock","title":"<code>decrement_stock(quantity)</code>","text":"<p>Decrease stock by quantity. Does NOT recalculate cost. Should be called in transaction when logging usage.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def decrement_stock(self, quantity: Decimal):\n    \"\"\"\n    Decrease stock by quantity. Does NOT recalculate cost.\n    Should be called in transaction when logging usage.\n    \"\"\"\n    new_stock = (Decimal(self.current_stock or 0) - Decimal(quantity))\n    # Allow negatives (so we can see overuse), but you might want to block it.\n    self.current_stock = new_stock.quantize(Decimal(\"0.000\"))\n    self.save(update_fields=[\"current_stock\", \"last_updated\"])\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.Ingredient.increment_stock","title":"<code>increment_stock(quantity, cost_per_unit)</code>","text":"<p>Increase stock and recalculate weighted average cost. Called by StockEntry.save() inside a transaction.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def increment_stock(self, quantity: Decimal, cost_per_unit: Decimal):\n    \"\"\"\n    Increase stock and recalculate weighted average cost.\n    Called by StockEntry.save() inside a transaction.\n    \"\"\"\n    if quantity &lt;= 0:\n        return\n\n    old_stock = Decimal(self.current_stock or 0)\n    old_cost = Decimal(self.average_cost_per_unit or 0)\n    new_stock = Decimal(quantity)\n    new_cost = Decimal(cost_per_unit)\n\n    total_qty = old_stock + new_stock\n    if total_qty &gt; 0:\n        weighted_avg = ((old_stock * old_cost) + (new_stock * new_cost)) / total_qty\n    else:\n        weighted_avg = new_cost\n\n    self.average_cost_per_unit = weighted_avg.quantize(Decimal(\"0.000001\"))\n    self.current_stock = total_qty.quantize(Decimal(\"0.000\"))\n    self.save(update_fields=[\"average_cost_per_unit\", \"current_stock\", \"last_updated\"])\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.IngredientType","title":"<code>IngredientType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Labels ingredients into logical families (roasts, packaging, etc.).</p>"},{"location":"16_API/models/#mscrInventory.models.IngredientUsageLog","title":"<code>IngredientUsageLog</code>","text":"<p>               Bases: <code>Model</code></p> <p>Log of ingredient usage per date. Typically created by the sync process that consumes OrderItems+RecipeItems and aggregates by ingredient.</p>"},{"location":"16_API/models/#mscrInventory.models.IngredientUsageLog.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>On create, decrement ingredient.current_stock. If updating an existing record, compute delta and apply difference.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def save(self, *args, **kwargs):\n    \"\"\"\n    On create, decrement ingredient.current_stock.\n    If updating an existing record, compute delta and apply difference.\n    \"\"\"\n    with transaction.atomic():\n        if self.pk:\n            # existing; compute delta\n            old = IngredientUsageLog.objects.select_for_update().get(pk=self.pk)\n            delta = Decimal(self.quantity_used) - Decimal(old.quantity_used)\n            super().save(*args, **kwargs)\n            if delta != 0:\n                # positive delta =&gt; additional consumption\n                self.ingredient.decrement_stock(delta)\n        else:\n            super().save(*args, **kwargs)\n            # new usage -&gt; decrement the stock by the full amount\n            self.ingredient.decrement_stock(Decimal(self.quantity_used))\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.ModifierBehavior","title":"<code>ModifierBehavior</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>Normalized operations for manipulating recipe ingredients.</p>"},{"location":"16_API/models/#mscrInventory.models.Order","title":"<code>Order</code>","text":"<p>               Bases: <code>Model</code></p> <p>High-level order pulled from connected commerce platforms.</p>"},{"location":"16_API/models/#mscrInventory.models.OrderItem","title":"<code>OrderItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Line item belonging to an Order, optionally linked to a Product.</p>"},{"location":"16_API/models/#mscrInventory.models.Packaging","title":"<code>Packaging</code>","text":"<p>               Bases: <code>Ingredient</code></p> <p>Ingredient subtype for cups, lids, and other packaging combos.</p>"},{"location":"16_API/models/#mscrInventory.models.Product","title":"<code>Product</code>","text":"<p>               Bases: <code>Model</code></p> <p>Sellable menu item that links recipes, modifiers, and POS identifiers.</p>"},{"location":"16_API/models/#mscrInventory.models.Product.calculated_cogs","title":"<code>calculated_cogs</code>  <code>property</code>","text":"<p>Returns total cost of goods sold for this product, based on linked ingredients and their average cost.</p>"},{"location":"16_API/models/#mscrInventory.models.ProductVariantCache","title":"<code>ProductVariantCache</code>","text":"<p>               Bases: <code>Model</code></p> <p>Normalized variant metadata learned from POS imports.</p>"},{"location":"16_API/models/#mscrInventory.models.RecipeItem","title":"<code>RecipeItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Represents a single ingredient entry within a product's recipe.</p> <p>Each RecipeItem links one Product to one Ingredient, with a specific quantity, unit, and optional cost/price data. Together, all RecipeItems for a Product define that product's complete recipe and cost-of-goods basis.</p> Example <p>Latte  \u2192  [ (Espresso Shot, 1 unit), (Milk, 8 oz), (Foam, 1 unit) ]</p>"},{"location":"16_API/models/#mscrInventory.models.RecipeModifier","title":"<code>RecipeModifier</code>","text":"<p>               Bases: <code>Model</code></p> <p>Modifiers are extensions of Ingredients (e.g. milk options, syrups, extra shots). Each links to a base Ingredient but may have its own cost, price, and behavior.</p> Extended behavior system <ul> <li>behavior: ADD, REPLACE, SCALE</li> <li>quantity_factor: scaling multiplier (replaces size_multiplier)</li> <li>target_selector: defines which ingredients to target (by type/name)</li> <li>replaces: specifies replacements for REPLACE behavior</li> </ul>"},{"location":"16_API/models/#mscrInventory.models.RecipeModifierAlias","title":"<code>RecipeModifierAlias</code>","text":"<p>               Bases: <code>Model</code></p> <p>Maps raw order modifiers to the normalized RecipeModifier.</p>"},{"location":"16_API/models/#mscrInventory.models.RoastProfile","title":"<code>RoastProfile</code>","text":"<p>               Bases: <code>Ingredient</code></p> <p>Retail coffee bag metadata tied to a roast ingredient.</p>"},{"location":"16_API/models/#mscrInventory.models.SizeLabel","title":"<code>SizeLabel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Named portion sizes used when presenting packaging choices.</p>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem","title":"<code>SquareUnmappedItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Tracks Square rows that could not be resolved to an internal mapping.</p>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem.mark_resolved","title":"<code>mark_resolved(*, user=None, ignored=False, product=None, ingredient=None, modifier=None, note=None)</code>","text":"<p>Mark the item as resolved and optionally link an existing record.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def mark_resolved(\n    self,\n    *,\n    user=None,\n    ignored: bool = False,\n    product: Optional[\"Product\"] = None,\n    ingredient: Optional[\"Ingredient\"] = None,\n    modifier: Optional[\"RecipeModifier\"] = None,\n    note: str | None = None,\n) -&gt; None:\n    \"\"\"Mark the item as resolved and optionally link an existing record.\"\"\"\n\n    update_fields = {\"resolved\", \"ignored\", \"resolved_at\"}\n\n    self.resolved = not ignored\n    self.ignored = ignored\n    self.resolved_at = timezone.now()\n    self.resolved_by = user\n    update_fields.add(\"resolved_by\")\n\n    if self.item_type == \"product\":\n        self.linked_product = product\n    else:\n        self.linked_product = None\n    update_fields.add(\"linked_product\")\n\n    if self.item_type == \"ingredient\":\n        self.linked_ingredient = ingredient\n    else:\n        self.linked_ingredient = None\n    update_fields.add(\"linked_ingredient\")\n\n    if self.item_type == \"modifier\":\n        self.linked_modifier = modifier\n    else:\n        self.linked_modifier = None\n    update_fields.add(\"linked_modifier\")\n\n    if note is not None:\n        self.item_note = note\n        update_fields.add(\"item_note\")\n\n    self.save(update_fields=list(update_fields))\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem.reopen","title":"<code>reopen()</code>","text":"<p>Reopen an item for review.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def reopen(self) -&gt; None:\n    \"\"\"Reopen an item for review.\"\"\"\n\n    self.resolved = False\n    self.ignored = False\n    self.resolved_at = None\n    self.resolved_by = None\n    self.linked_product = None\n    self.linked_ingredient = None\n    self.linked_modifier = None\n    self.save(\n        update_fields=[\n            \"resolved\",\n            \"ignored\",\n            \"resolved_at\",\n            \"resolved_by\",\n            \"linked_product\",\n            \"linked_ingredient\",\n            \"linked_modifier\",\n        ]\n    )\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.StockEntry","title":"<code>StockEntry</code>","text":"<p>               Bases: <code>Model</code></p> <p>Represents a restock event that updates weighted average cost.</p>"},{"location":"16_API/models/#mscrInventory.models.StockEntry.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>On save, update ingredient's stock and weighted average cost. If this is an update (existing pk), behavior is naive: we handle only create. For production, handle edits/deletes explicitly (reverse previous effect).</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def save(self, *args, **kwargs):\n    \"\"\"\n    On save, update ingredient's stock and weighted average cost.\n    If this is an update (existing pk), behavior is naive: we handle only create.\n    For production, handle edits/deletes explicitly (reverse previous effect).\n    \"\"\"\n    is_create = self.pk is None\n    with transaction.atomic():\n        super().save(*args, **kwargs)\n        if is_create and self.quantity_added and self.cost_per_unit is not None:\n            # Update Ingredient aggregate fields\n            self.ingredient.increment_stock(self.quantity_added, self.cost_per_unit)\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.UnitType","title":"<code>UnitType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Measurement definition with a conversion ratio to a base unit.</p>"},{"location":"16_API/models/#mscrInventory.models.ensure_roast_profile","title":"<code>ensure_roast_profile(sender, instance, created, **kwargs)</code>","text":"<p>Ensure roast ingredients always have an attached RoastProfile.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>@receiver(post_save, sender=Ingredient)\ndef ensure_roast_profile(sender, instance, created, **kwargs):\n    \"\"\"Ensure roast ingredients always have an attached RoastProfile.\"\"\"\n\n    roast_type = IngredientType.objects.filter(name__iexact=\"roasts\").first()\n    has_roast_type = bool(roast_type and instance.type_id == roast_type.id)\n    try:\n        profile = instance.roastprofile\n    except RoastProfile.DoesNotExist:\n        profile = None\n\n    if has_roast_type and profile is None:\n        get_or_create_roast_profile(instance)\n    elif not has_roast_type and profile is not None:\n        profile.delete()\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.get_or_create_roast_profile","title":"<code>get_or_create_roast_profile(ingredient)</code>","text":"<p>Return the roast profile for an ingredient, creating it if needed.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def get_or_create_roast_profile(ingredient: \"Ingredient\") -&gt; RoastProfile | None:\n    \"\"\"Return the roast profile for an ingredient, creating it if needed.\"\"\"\n\n    if ingredient is None:\n        return None\n\n    if ingredient.pk is None:\n        return None\n\n    try:\n        return ingredient.roastprofile\n    except RoastProfile.DoesNotExist:\n        pass\n\n    defaults = {\n        \"bag_size\": RoastProfile._meta.get_field(\"bag_size\").get_default(),\n        \"grind\": RoastProfile._meta.get_field(\"grind\").get_default(),\n    }\n\n    table_name = connection.ops.quote_name(RoastProfile._meta.db_table)\n    parent_column = connection.ops.quote_name(\n        RoastProfile._meta.get_field(\"ingredient_ptr\").column\n    )\n    bag_column = connection.ops.quote_name(RoastProfile._meta.get_field(\"bag_size\").column)\n    grind_column = connection.ops.quote_name(RoastProfile._meta.get_field(\"grind\").column)\n\n    with transaction.atomic():\n        with connection.cursor() as cursor:\n            try:\n                cursor.execute(\n                    f\"INSERT INTO {table_name} ({parent_column}, {bag_column}, {grind_column}) \"\n                    \"VALUES (%s, %s, %s)\",\n                    [ingredient.pk, defaults[\"bag_size\"], defaults[\"grind\"]],\n                )\n            except IntegrityError:\n                # Another transaction created the profile first; fetch below.\n                pass\n\n    try:\n        return RoastProfile.objects.get(pk=ingredient.pk)\n    except RoastProfile.DoesNotExist:\n        return None\n</code></pre>"},{"location":"16_API/scripts/","title":"Scripts","text":"<p>Utility scripts that support environment maintenance, backups, and local tooling. These are CLI-oriented modules rather than Django management commands.</p> Script Purpose <code>scripts/export_sqlite_backup.py</code> Create a timestamped SQLite backup locally. <code>scripts/import_sqlite_backup.py</code> Restore data from an archived CSV snapshot into SQLite (with optional dry-run). <code>scripts/load_db_snapshot.py</code> Fetch and load the latest pushed snapshot into a local dev environment. <code>scripts/push_db_snapshot.py</code> Dump a sanitized snapshot and copy it to a remote host. <code>scripts/relink_from_backup.py</code> Re-link integer foreign keys from CSV backups after a schema change. <code>scripts/merge_csv.py</code> Merge a directory of CSV files into one combined file while skipping duplicate headers. <code>scripts/dev_square_matcher.py</code> Quick interactive helper to exercise the Square matcher on a sample CSV."},{"location":"16_API/utils/","title":"Utilities API","text":"<p>import docs.django_setup</p>"},{"location":"16_API/utils/#dashboard-helpers","title":"Dashboard helpers","text":"<p>Metrics helpers backing the dashboard tiles and shortcuts.</p>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.build_stat_cards","title":"<code>build_stat_cards(stat_counts, low_stock_summary)</code>","text":"<p>Convert counts and low-stock details into card metadata consumed by templates.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def build_stat_cards(\n    stat_counts: Dict[str, int], low_stock_summary: Dict[str, Any]\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Convert counts and low-stock details into card metadata consumed by templates.\"\"\"\n    return [\n        {\n            \"title\": \"Active Products\",\n            \"value\": stat_counts[\"active_products\"],\n            \"description\": \"Menu items currently for sale\",\n            \"icon\": \"bi-bag-check\",\n            \"cta\": {\"label\": \"View Orders\", \"url\": reverse(\"orders_dashboard\")},\n        },\n        {\n            \"title\": \"Tracked Ingredients\",\n            \"value\": stat_counts[\"ingredients\"],\n            \"description\": \"Inventory items with stock levels\",\n            \"icon\": \"bi-archive\",\n            \"cta\": {\"label\": \"Inventory\", \"url\": reverse(\"inventory_dashboard\")},\n        },\n        {\n            \"title\": \"Unmapped Items\",\n            \"value\": stat_counts[\"unmapped\"],\n            \"description\": \"Square rows needing review\",\n            \"icon\": \"bi-exclamation-triangle\",\n            \"highlight\": stat_counts[\"unmapped\"] &gt; 0,\n            \"cta\": {\n                \"label\": \"Resolve\",\n                \"url\": reverse(\"imports_unmapped_items\"),\n            },\n        },\n        {\n            \"title\": \"Low Stock Alerts\",\n            \"value\": low_stock_summary[\"total\"],\n            \"description\": \"At or below reorder point\",\n            \"icon\": \"bi-thermometer-half\",\n            \"items\": low_stock_summary[\"items\"],\n            \"cta\": {\"label\": \"Restock\", \"url\": reverse(\"inventory_dashboard\")},\n        },\n    ]\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.determine_import_status","title":"<code>determine_import_status(log)</code>","text":"<p>Compute a badge class summarizing the import outcome.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def determine_import_status(log: ImportLog) -&gt; ImportStatus:\n    \"\"\"Compute a badge class summarizing the import outcome.\"\"\"\n    if not log.finished_at:\n        return ImportStatus(\"Running\", \"bg-info text-dark\")\n    if log.error_count:\n        return ImportStatus(\"Failed\", \"bg-danger\")\n    if log.unmatched_count:\n        return ImportStatus(\"Partial\", \"bg-warning text-dark\")\n    return ImportStatus(\"Success\", \"bg-success\")\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_activity_feed","title":"<code>get_activity_feed(limit=ACTIVITY_LIMIT)</code>","text":"<p>Return high-level change log entries for the dashboard feed.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_activity_feed(limit: int = ACTIVITY_LIMIT) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return high-level change log entries for the dashboard feed.\"\"\"\n    events: List[Dict[str, Any]] = []\n\n    for ingredient in Ingredient.objects.order_by(\"-last_updated\")[:limit]:\n        events.append(\n            {\n                \"kind\": \"Ingredient\",\n                \"name\": ingredient.name,\n                \"timestamp\": ingredient.last_updated,\n                \"detail\": \"Stock level updated\",\n            }\n        )\n\n    for modifier in RecipeModifier.objects.order_by(\"-updated_at\")[:limit]:\n        events.append(\n            {\n                \"kind\": \"Modifier\",\n                \"name\": modifier.name,\n                \"timestamp\": modifier.updated_at,\n                \"detail\": f\"Behavior: {modifier.get_behavior_display()}\",\n            }\n        )\n\n    for import_log in ImportLog.objects.order_by(\"-created_at\")[:limit]:\n        events.append(\n            {\n                \"kind\": \"Import\",\n                \"name\": f\"{import_log.get_source_display()} run\",\n                \"timestamp\": import_log.created_at,\n                \"detail\": f\"{import_log.rows_processed} rows processed\",\n            }\n        )\n\n    events = [e for e in events if e[\"timestamp\"]]\n    events.sort(key=lambda item: item[\"timestamp\"], reverse=True)\n    return events[:limit]\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_low_stock_summary","title":"<code>get_low_stock_summary(limit=LOW_STOCK_LIMIT)</code>","text":"<p>Return total low-stock count plus the top items for display.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_low_stock_summary(limit: int = LOW_STOCK_LIMIT) -&gt; Dict[str, Any]:\n    \"\"\"Return total low-stock count plus the top items for display.\"\"\"\n    cache_key = f\"{LOW_STOCK_CACHE_KEY}:{limit}\"\n    cached = cache.get(cache_key)\n    if cached:\n        return cached\n\n    qs = Ingredient.objects.filter(\n        reorder_point__gt=0,\n        current_stock__lte=F(\"reorder_point\"),\n    )\n    summary = {\n        \"total\": qs.count(),\n        \"items\": list(\n            qs.order_by(\"current_stock\").values(\n                \"id\",\n                \"name\",\n                \"current_stock\",\n                \"reorder_point\",\n            )[:limit]\n        ),\n    }\n    cache.set(cache_key, summary, CACHE_TIMEOUT)\n    return summary\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_quick_actions","title":"<code>get_quick_actions()</code>","text":"<p>Shortcut buttons linking to common admin workflows.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_quick_actions() -&gt; List[Dict[str, Any]]:\n    \"\"\"Shortcut buttons linking to common admin workflows.\"\"\"\n    return [\n        {\n            \"label\": \"Add Ingredient\",\n            \"description\": \"Track a new inventory item\",\n            \"hx_get\": reverse(\"ingredient_create_modal\"),\n            \"hx_target\": \"#modal-body\",\n            \"hx_trigger\": \"click\",\n            \"icon\": \"bi-plus-circle\",\n        },\n        {\n            \"label\": \"Upload CSV\",\n            \"description\": \"Run an import or dry run\",\n            \"url\": reverse(\"imports_dashboard\"),\n            \"icon\": \"bi-file-earmark-arrow-up\",\n        },\n        {\n            \"label\": \"Sync Square\",\n            \"description\": \"Trigger the latest order sync\",\n            \"url\": reverse(\"imports_dashboard\") + \"#square-sync\",\n            \"icon\": \"bi-arrow-repeat\",\n        },\n    ]\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_recent_imports","title":"<code>get_recent_imports(limit=RECENT_IMPORT_LIMIT)</code>","text":"<p>Return the most recent ImportLog entries with normalized metadata.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_recent_imports(limit: int = RECENT_IMPORT_LIMIT) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return the most recent ImportLog entries with normalized metadata.\"\"\"\n    logs = ImportLog.objects.order_by(\"-created_at\").select_related(\"uploaded_by\")[:limit]\n    results: List[Dict[str, Any]] = []\n    for log in logs:\n        status = determine_import_status(log)\n        results.append(\n            {\n                \"source\": log.get_source_display(),\n                \"run_type\": log.get_run_type_display(),\n                \"created_at\": log.created_at,\n                \"rows_processed\": log.rows_processed,\n                \"matched\": log.matched_count,\n                \"unmatched\": log.unmatched_count,\n                \"status\": status.label,\n                \"badge\": status.badge_class,\n                \"summary\": log.summary,\n            }\n        )\n    return results\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_shortcuts","title":"<code>get_shortcuts()</code>","text":"<p>Return the static configuration for dashboard shortcut buttons.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_shortcuts() -&gt; List[Dict[str, Any]]:\n    \"\"\"Return the static configuration for dashboard shortcut buttons.\"\"\"\n    return [\n        {\"label\": \"Products\", \"url\": reverse(\"orders_dashboard\"), \"icon\": \"bi-basket\"},\n        {\"label\": \"Ingredients\", \"url\": reverse(\"ingredients_dashboard\"), \"icon\": \"bi-droplet\"},\n        {\"label\": \"Recipes\", \"url\": reverse(\"recipes_dashboard\"), \"icon\": \"bi-journal-text\"},\n        {\"label\": \"Inventory\", \"url\": reverse(\"inventory_dashboard\"), \"icon\": \"bi-box-seam\"},\n        {\"label\": \"Imports\", \"url\": reverse(\"imports_dashboard\"), \"icon\": \"bi-cloud-arrow-down\"},\n        {\"label\": \"Reports\", \"url\": reverse(\"reporting_dashboard\"), \"icon\": \"bi-graph-up\"},\n    ]\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_stat_counts","title":"<code>get_stat_counts()</code>","text":"<p>Return cached counts backing the dashboard summary cards.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_stat_counts() -&gt; Dict[str, int]:\n    \"\"\"Return cached counts backing the dashboard summary cards.\"\"\"\n    cached = cache.get(STAT_COUNT_CACHE_KEY)\n    if cached:\n        return cached\n\n    counts = {\n        \"active_products\": Product.objects.filter(active=True).count(),\n        \"ingredients\": Ingredient.objects.count(),\n        \"unmapped\": SquareUnmappedItem.objects.filter(\n            resolved=False,\n            ignored=False,\n        ).count(),\n    }\n    cache.set(STAT_COUNT_CACHE_KEY, counts, CACHE_TIMEOUT)\n    return counts\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_top_named_drinks","title":"<code>get_top_named_drinks(limit=10, lookback_days=NAMED_DRINK_LOOKBACK_DAYS)</code>","text":"<p>Return the most popular custom drink names observed across recent orders.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_top_named_drinks(\n    limit: int = 10, lookback_days: int = NAMED_DRINK_LOOKBACK_DAYS\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Return the most popular custom drink names observed across recent orders.\"\"\"\n    cache_key = f\"{NAMED_DRINK_CACHE_KEY}:{limit}:{lookback_days}\"\n    cached = cache.get(cache_key)\n    if cached is not None:\n        return cached\n\n    since = timezone.now() - timedelta(days=lookback_days)\n    rows = (\n        OrderItem.objects.select_related(\"product\", \"order\")\n        .filter(order__order_date__gte=since)\n        .only(\"quantity\", \"variant_info\", \"product__name\", \"order__order_date\")\n    )\n\n    aggregates: Dict[str, Dict[str, Any]] = defaultdict(\n        lambda: {\"count\": 0, \"last_seen\": None, \"products\": set()}\n    )\n\n    for row in rows:\n        info = row.variant_info or {}\n        modifiers = info.get(\"modifiers\") or []\n        for token in modifiers:\n            custom = _extract_named_drink_label(token)\n            if not custom:\n                continue\n            entry = aggregates[custom]\n            qty = int(row.quantity or 1)\n            entry[\"count\"] += qty\n            order_date = getattr(row.order, \"order_date\", None)\n            if order_date and (entry[\"last_seen\"] is None or order_date &gt; entry[\"last_seen\"]):\n                entry[\"last_seen\"] = order_date\n            if row.product and row.product.name:\n                entry[\"products\"].add(row.product.name)\n\n    results: List[Dict[str, Any]] = []\n    for normalized_label, meta in aggregates.items():\n        display = normalized_label.title()\n        products = sorted(meta[\"products\"])\n        results.append(\n            {\n                \"label\": display,\n                \"normalized_label\": normalized_label,\n                \"count\": meta[\"count\"],\n                \"last_seen\": meta[\"last_seen\"],\n                \"products\": products,\n                \"orders_url\": _build_named_drink_orders_url(display, lookback_days),\n            }\n        )\n\n    results.sort(\n        key=lambda item: (\n            -item[\"count\"],\n            -(\n                item[\"last_seen\"].timestamp()\n                if item[\"last_seen\"]\n                else 0\n            ),\n        )\n    )\n\n    trimmed = results[:limit]\n    cache.set(cache_key, trimmed, CACHE_TIMEOUT)\n    return trimmed\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.dashboard_metrics.get_warning_items","title":"<code>get_warning_items(low_stock_summary, stat_counts, recent_imports)</code>","text":"<p>Compile warning callouts for low stock, unmapped items, or import issues.</p> Source code in <code>mscrInventory/utils/dashboard_metrics.py</code> <pre><code>def get_warning_items(\n    low_stock_summary: Dict[str, Any],\n    stat_counts: Dict[str, int],\n    recent_imports: List[Dict[str, Any]],\n) -&gt; List[Dict[str, Any]]:\n    \"\"\"Compile warning callouts for low stock, unmapped items, or import issues.\"\"\"\n    warnings: List[Dict[str, Any]] = []\n\n    if low_stock_summary[\"total\"]:\n        warnings.append(\n            {\n                \"title\": \"Inventory running low\",\n                \"detail\": f\"{low_stock_summary['total']} ingredients are at reorder levels\",\n                \"url\": reverse(\"inventory_dashboard\"),\n            }\n        )\n\n    if stat_counts[\"unmapped\"]:\n        warnings.append(\n            {\n                \"title\": \"Unmapped Square items\",\n                \"detail\": f\"{stat_counts['unmapped']} recent orders need attention\",\n                \"url\": reverse(\"imports_unmapped_items\"),\n            }\n        )\n\n    for import_entry in recent_imports:\n        if import_entry[\"status\"] in {\"Failed\", \"Partial\"}:\n            warnings.append(\n                {\n                    \"title\": f\"Import {import_entry['status'].lower()}\",\n                    \"detail\": (\n                        f\"{import_entry['source']} import processed {import_entry['rows_processed']} rows\"\n                    ),\n                    \"url\": reverse(\"imports_dashboard\"),\n                }\n            )\n\n    return warnings[:WARNING_LIMIT]\n</code></pre>"},{"location":"16_API/utils/#modifier-tooling","title":"Modifier tooling","text":"<p>Utility helpers for analyzing Square modifier CSV files.</p>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.FuzzyMatch","title":"<code>FuzzyMatch(id, name, behavior, score)</code>  <code>dataclass</code>","text":"<p>Represents a fuzzy match candidate for a modifier label.</p>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierExplorerAnalyzer","title":"<code>ModifierExplorerAnalyzer(ignored_tokens=None, custom_name_prefixes=None)</code>","text":"<p>Collects and summarizes modifier usage from Square CSV exports.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def __init__(\n    self,\n    ignored_tokens: Optional[Iterable[str]] = None,\n    custom_name_prefixes: Optional[Iterable[str]] = None,\n) -&gt; None:\n    self.ignored_tokens = set(ignored_tokens or IGNORED_TOKENS)\n    prefixes = custom_name_prefixes or CUSTOM_DRINK_PREFIXES\n    self.custom_name_prefixes = tuple(prefix.strip().lower() for prefix in prefixes)\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierExplorerAnalyzer.analyze","title":"<code>analyze(paths=None)</code>","text":"<p>Read one or more Square CSVs and return aggregated modifier insights.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def analyze(self, paths: Optional[Sequence[Path]] = None) -&gt; ModifierExplorerReport:\n    \"\"\"Read one or more Square CSVs and return aggregated modifier insights.\"\"\"\n    csv_files = list(self._resolve_paths(paths))\n    insights: Dict[str, ModifierInsight] = {}\n    co_occurrence_pairs: Dict[Tuple[str, str], int] = defaultdict(int)\n\n    for csv_path in csv_files:\n        for row in self._iter_csv(csv_path):\n            item_name = (row.get(\"Item\") or \"\").strip()\n            raw_modifiers = self._parse_modifiers(row.get(\"Modifiers Applied\"))\n            normalized_modifiers = [\n                normalize_modifier(raw) for raw in raw_modifiers\n            ]\n            filtered = [\n                (raw, normalized)\n                for raw, normalized in zip(raw_modifiers, normalized_modifiers)\n                if normalized\n                and normalized not in self.ignored_tokens\n                and not self._is_custom_drink_token(normalized)\n            ]\n            if not filtered:\n                continue\n\n            # Update per-modifier counters\n            for raw, normalized in filtered:\n                insight = insights.setdefault(\n                    normalized, ModifierInsight(normalized=normalized)\n                )\n                insight.add_observation(raw, item_name)\n\n            # Track co-occurrence once per unique pair per row\n            unique_norms = sorted({normalized for _, normalized in filtered})\n            for i, left in enumerate(unique_norms):\n                for right in unique_norms[i + 1 :]:\n                    co_occurrence_pairs[(left, right)] += 1\n                    insights[left].add_co_occurrence(right)\n                    insights[right].add_co_occurrence(left)\n\n    modifiers = self._fetch_modifiers()\n    aliases = self._fetch_aliases()\n    self._classify_modifiers(insights, modifiers, aliases)\n\n    return ModifierExplorerReport(\n        insights=insights,\n        co_occurrence_pairs=dict(co_occurrence_pairs),\n        source_files=csv_files,\n    )\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierExplorerReport","title":"<code>ModifierExplorerReport(insights, co_occurrence_pairs, source_files)</code>  <code>dataclass</code>","text":"<p>Final aggregated report returned by the analyzer.</p>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierExplorerReport.to_csv_rows","title":"<code>to_csv_rows()</code>","text":"<p>Flatten the insights into CSV-ready dicts.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def to_csv_rows(self) -&gt; List[Dict[str, object]]:\n    \"\"\"Flatten the insights into CSV-ready dicts.\"\"\"\n    return [insight.to_csv_row() for insight in sorted(self.insights.values(), key=lambda x: x.normalized)]\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierExplorerReport.to_json","title":"<code>to_json()</code>","text":"<p>Return a JSON-serializable payload describing the report.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def to_json(self) -&gt; Dict[str, object]:\n    \"\"\"Return a JSON-serializable payload describing the report.\"\"\"\n    return {\n        \"source_files\": [str(path) for path in self.source_files],\n        \"modifiers\": {\n            normalized: insight.as_dict()\n            for normalized, insight in sorted(self.insights.items())\n        },\n        \"co_occurrence_pairs\": {\n            f\"{a}|{b}\": count for (a, b), count in sorted(self.co_occurrence_pairs.items())\n        },\n    }\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierInsight","title":"<code>ModifierInsight(normalized, total_count=0, raw_labels=Counter(), items=Counter(), co_occurrence=Counter(), classification='unknown', modifier_id=None, modifier_name=None, modifier_behavior=None, fuzzy_matches=list(), alias_label=None, product_match_name=None)</code>  <code>dataclass</code>","text":"<p>Aggregated insight for a normalized modifier label.</p>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierInsight.add_observation","title":"<code>add_observation(raw_label, item_name)</code>","text":"<p>Update counters from a CSV observation.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def add_observation(self, raw_label: str, item_name: str) -&gt; None:\n    \"\"\"Update counters from a CSV observation.\"\"\"\n    self.total_count += 1\n    if raw_label:\n        self.raw_labels[raw_label] += 1\n    if item_name:\n        self.items[item_name] += 1\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierInsight.as_dict","title":"<code>as_dict()</code>","text":"<p>Serialize the insight for JSON responses.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def as_dict(self) -&gt; Dict[str, object]:\n    \"\"\"Serialize the insight for JSON responses.\"\"\"\n    return {\n        \"normalized\": self.normalized,\n        \"total_count\": self.total_count,\n        \"raw_labels\": dict(self.aggregated_raw_labels()),\n        \"top_items\": dict(self.items.most_common(10)),\n        \"classification\": self.classification,\n        \"modifier\": (\n            {\n                \"id\": self.modifier_id,\n                \"name\": self.modifier_name,\n                \"behavior\": self.modifier_behavior,\n            }\n            if self.modifier_id\n            else None\n        ),\n        \"alias_label\": self.alias_label,\n        \"fuzzy_matches\": [\n            {\n                \"id\": match.id,\n                \"name\": match.name,\n                \"behavior\": match.behavior,\n                \"score\": round(match.score, 4),\n            }\n            for match in self.fuzzy_matches\n        ],\n        \"co_occurrence\": dict(self.co_occurrence.most_common(10)),\n    }\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.modifier_explorer.ModifierInsight.to_csv_row","title":"<code>to_csv_row()</code>","text":"<p>Provide a flat row suitable for CSV export.</p> Source code in <code>mscrInventory/utils/modifier_explorer.py</code> <pre><code>def to_csv_row(self) -&gt; Dict[str, object]:\n    \"\"\"Provide a flat row suitable for CSV export.\"\"\"\n    top_raw = \", \".join(\n        f\"{label} ({count})\" for label, count in self.aggregated_raw_labels(limit=5)\n    )\n    top_items = \", \".join(\n        f\"{item} ({count})\" for item, count in self.items.most_common(5)\n    )\n    return {\n        \"normalized\": self.normalized,\n        \"total_count\": self.total_count,\n        \"classification\": self.classification,\n        \"modifier_id\": self.modifier_id or \"\",\n        \"modifier_name\": self.modifier_name or \"\",\n        \"modifier_behavior\": self.modifier_behavior or \"\",\n        \"alias_label\": self.alias_label or \"\",\n        \"top_raw_labels\": top_raw,\n        \"top_items\": top_items,\n    }\n</code></pre>"},{"location":"16_API/utils/#reporting-utilities","title":"Reporting utilities","text":"<p>Reporting helpers for COGS, usage, and profitability dashboards.</p>"},{"location":"16_API/utils/#mscrInventory.utils.reports.aggregate_usage_totals","title":"<code>aggregate_usage_totals(start, end)</code>","text":"<p>Aggregate ingredient usage quantities for the date range.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def aggregate_usage_totals(start: datetime.date, end: datetime.date) -&gt; Dict[str, Decimal]:\n    \"\"\"Aggregate ingredient usage quantities for the date range.\"\"\"\n\n    totals: Dict[str, Decimal] = defaultdict(lambda: Decimal(\"0\"))\n    logs = (\n        IngredientUsageLog.objects\n        .select_related(\"ingredient\")\n        .filter(date__gte=start, date__lte=end)\n    )\n    for log in logs:\n        totals[log.ingredient.name] += Decimal(log.quantity_used)\n    return dict(totals)\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.average_cost_as_of_date","title":"<code>average_cost_as_of_date(ingredient_id, day)</code>","text":"<p>Weighted average cost for an ingredient based on StockEntries &lt;= end of 'day'. If no stock exists yet, returns Decimal('0').</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def average_cost_as_of_date(ingredient_id: int, day: datetime.date) -&gt; Decimal:\n    \"\"\"\n    Weighted average cost for an ingredient based on StockEntries &lt;= end of 'day'.\n    If no stock exists yet, returns Decimal('0').\n    \"\"\"\n    start_utc, end_utc = _day_window_utc(day)\n    agg = (StockEntry.objects\n           .filter(ingredient_id=ingredient_id, date_received__lte=end_utc)\n           .aggregate(\n               qty=Sum('quantity_added'),\n               cost=Sum(F('quantity_added') * F('cost_per_unit'))\n           ))\n    qty = agg['qty'] or Decimal(0)\n    cost = agg['cost'] or Decimal(0)\n    if qty &lt;= 0:\n        return Decimal(\"0\")\n    return (cost / qty).quantize(Decimal(\"0.0001\"), rounding=ROUND_HALF_UP)\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.category_profitability","title":"<code>category_profitability(start, end)</code>","text":"<p>Return high-level profitability metrics for the selected date range.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def category_profitability(start: datetime.date, end: datetime.date) -&gt; Dict[str, Decimal]:\n    \"\"\"Return high-level profitability metrics for the selected date range.\"\"\"\n\n    product_rows = cogs_summary_by_product(start, end)\n    overall_revenue = sum((row[\"revenue\"] for row in product_rows), Decimal(\"0\"))\n    overall_cogs = sum((row[\"cogs\"] for row in product_rows), Decimal(\"0\"))\n    overall_profit = overall_revenue - overall_cogs\n    margin_pct = Decimal(\"0\")\n    if overall_revenue:\n        margin_pct = (overall_profit / overall_revenue) * Decimal(\"100\")\n\n    return {\n        \"overall_revenue\": overall_revenue,\n        \"overall_cogs\": overall_cogs,\n        \"overall_profit\": overall_profit,\n        \"overall_margin_pct\": margin_pct.quantize(Decimal(\"0.01\")) if overall_revenue else None,\n    }\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.cogs_by_day","title":"<code>cogs_by_day(start, end, tzname='America/New_York')</code>","text":"<p>Inclusive date range. Returns a list of dict rows:   [{\"date\": YYYY-MM-DD, \"cogs_total\": Decimal}, ...]</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def cogs_by_day(start: datetime.date, end: datetime.date, tzname: str = \"America/New_York\") -&gt; List[Dict]:\n    \"\"\"\n    Inclusive date range. Returns a list of dict rows:\n      [{\"date\": YYYY-MM-DD, \"cogs_total\": Decimal}, ...]\n    \"\"\"\n    rows = []\n    cur = start\n    while cur &lt;= end:\n        day_data = cogs_for_day(cur, tzname)\n        rows.append({\n            \"date\": cur.isoformat(),\n            \"date_obj\": cur,\n            \"cogs_total\": day_data[\"cogs_total\"],\n        })\n        cur += datetime.timedelta(days=1)\n    return rows\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.cogs_for_day","title":"<code>cogs_for_day(day, tzname='America/New_York')</code>","text":"Returns a mapping <p>{   \"cogs_total\": Decimal,   \"per_ingredient\": {ingredient_name: {\"qty_used\": Decimal, \"unit_cost\": Decimal, \"cogs\": Decimal}} }</p> <p>Uses IngredientUsageLog entries on that day, multiplied by each ingredient's weighted average cost as of that day.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def cogs_for_day(day: datetime.date, tzname: str = \"America/New_York\") -&gt; Dict[str, Decimal]:\n    \"\"\"\n    Returns a mapping:\n        {\n          \"cogs_total\": Decimal,\n          \"per_ingredient\": {ingredient_name: {\"qty_used\": Decimal, \"unit_cost\": Decimal, \"cogs\": Decimal}}\n        }\n    Uses IngredientUsageLog entries on that day, multiplied by each ingredient's weighted\n    average cost as of that day.\n    \"\"\"\n    start_utc, end_utc = _day_window_utc(day, tzname)\n\n    # Usage on that business day\n    usage = (IngredientUsageLog.objects\n             .select_related(\"ingredient\")\n             .filter(date=day)\n             .values(\"ingredient_id\", \"ingredient__name\")\n             .annotate(qty_used=Sum(\"quantity_used\"))\n             .order_by(\"ingredient__name\"))\n\n    per_ing = {}\n    total = Decimal(\"0\")\n    for row in usage:\n        ing_id = row[\"ingredient_id\"]\n        name = row[\"ingredient__name\"]\n        qty = row[\"qty_used\"] or Decimal(0)\n        unit_cost = average_cost_as_of_date(ing_id, day)\n        cogs = (qty * unit_cost).quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n        per_ing[name] = {\n            \"qty_used\": qty.quantize(Decimal(\"0.001\")),\n            \"unit_cost\": unit_cost,\n            \"cogs\": cogs,\n        }\n        total += cogs\n\n    return {\"cogs_total\": total, \"per_ingredient\": per_ing}\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.cogs_summary_by_category","title":"<code>cogs_summary_by_category(start, end)</code>","text":"<p>Aggregate COGS totals per category for the date range.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def cogs_summary_by_category(start: datetime.date, end: datetime.date) -&gt; List[Dict]:\n    \"\"\"Aggregate COGS totals per category for the date range.\"\"\"\n\n    product_rows = cogs_summary_by_product(start, end)\n    product_ids = [row[\"product_id\"] for row in product_rows if row.get(\"product_id\")]\n    product_qs = (\n        Product.objects.filter(id__in=product_ids)\n        .prefetch_related(\"categories\")\n    )\n    product_map = {product.id: product for product in product_qs}\n    category_totals: Dict[str, Dict[str, Decimal]] = defaultdict(lambda: {\n        \"quantity\": Decimal(\"0\"),\n        \"revenue\": Decimal(\"0\"),\n        \"cogs\": Decimal(\"0\"),\n    })\n\n    for row in product_rows:\n        product = product_map.get(row.get(\"product_id\")) if row.get(\"product_id\") else None\n        categories = list(product.categories.all()) if product else []\n        if not categories:\n            allocations = [(\"Uncategorized\", Decimal(\"1\"))]\n        else:\n            share = Decimal(\"1\") / Decimal(len(categories))\n            allocations = [(category.name, share) for category in categories]\n        for category_name, weight in allocations:\n            bucket = category_totals[category_name]\n            bucket[\"quantity\"] += row[\"quantity\"] * weight\n            bucket[\"revenue\"] += row[\"revenue\"] * weight\n            bucket[\"cogs\"] += row[\"cogs\"] * weight\n\n    results: List[Dict] = []\n    for name, payload in category_totals.items():\n        profit = payload[\"revenue\"] - payload[\"cogs\"]\n        margin = Decimal(\"0\")\n        if payload[\"revenue\"]:\n            margin = (profit / payload[\"revenue\"]) * Decimal(\"100\")\n        results.append({\n            \"category\": name,\n            \"quantity\": payload[\"quantity\"],\n            \"revenue\": payload[\"revenue\"],\n            \"cogs\": payload[\"cogs\"],\n            \"profit\": profit,\n            \"margin_pct\": margin.quantize(Decimal(\"0.01\")) if payload[\"revenue\"] else None,\n        })\n\n    results.sort(key=lambda row: row[\"cogs\"], reverse=True)\n    return results\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.cogs_summary_by_product","title":"<code>cogs_summary_by_product(start, end)</code>","text":"<p>Aggregate COGS totals per product (recipe) for the date range.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def cogs_summary_by_product(start: datetime.date, end: datetime.date) -&gt; List[Dict]:\n    \"\"\"Aggregate COGS totals per product (recipe) for the date range.\"\"\"\n\n    items = (\n        OrderItem.objects\n        .select_related(\"product\", \"order\")\n        .filter(order__order_date__date__gte=start, order__order_date__date__lte=end, product__isnull=False)\n    )\n\n    summary: Dict[int, Dict[str, Decimal | str | int]] = {}\n    for item in items:\n        if not item.product:\n            continue\n        product = item.product\n        qty = Decimal(item.quantity or 0)\n        revenue = (item.unit_price or Decimal(\"0\")) * qty\n        cogs = product.calculated_cogs * qty\n\n        data = summary.setdefault(\n            product.id,\n            {\n                \"product\": product,\n                \"product_name\": product.name,\n                \"sku\": product.sku,\n                \"product_id\": product.id,\n                \"quantity\": Decimal(\"0\"),\n                \"revenue\": Decimal(\"0\"),\n                \"cogs\": Decimal(\"0\"),\n            },\n        )\n        data[\"quantity\"] += qty\n        data[\"revenue\"] += revenue\n        data[\"cogs\"] += cogs\n\n    rows = []\n    for payload in summary.values():\n        profit = payload[\"revenue\"] - payload[\"cogs\"]\n        margin = Decimal(\"0\")\n        if payload[\"revenue\"]:\n            margin = (profit / payload[\"revenue\"]) * Decimal(\"100\")\n        rows.append({\n            \"product_name\": payload[\"product_name\"],\n            \"sku\": payload[\"sku\"],\n            \"product_id\": payload[\"product_id\"],\n            \"quantity\": payload[\"quantity\"],\n            \"revenue\": payload[\"revenue\"],\n            \"cogs\": payload[\"cogs\"],\n            \"profit\": profit,\n            \"margin_pct\": margin.quantize(Decimal(\"0.01\")) if payload[\"revenue\"] else None,\n        })\n\n    rows.sort(key=lambda row: row[\"cogs\"], reverse=True)\n    return rows\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.cogs_trend_with_variance","title":"<code>cogs_trend_with_variance(start, end, tzname='America/New_York')</code>","text":"<p>Return daily totals with variance data compared to the previous day.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def cogs_trend_with_variance(start: datetime.date, end: datetime.date, tzname: str = \"America/New_York\") -&gt; List[Dict]:\n    \"\"\"Return daily totals with variance data compared to the previous day.\"\"\"\n\n    trend = cogs_by_day(start, end, tzname=tzname)\n    previous_total: Decimal | None = None\n    for row in trend:\n        if \"date_obj\" not in row:\n            try:\n                row[\"date_obj\"] = datetime.date.fromisoformat(row[\"date\"])\n            except (TypeError, ValueError):\n                row[\"date_obj\"] = None\n        total = row[\"cogs_total\"]\n        if previous_total is None:\n            row[\"variance\"] = None\n            row[\"variance_pct\"] = None\n        else:\n            variance = total - previous_total\n            row[\"variance\"] = variance\n            if previous_total:\n                row[\"variance_pct\"] = (variance / previous_total * Decimal(\"100\")).quantize(Decimal(\"0.01\"))\n            else:\n                row[\"variance_pct\"] = None\n        previous_total = total\n    return trend\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.daterange","title":"<code>daterange(start, end)</code>","text":"<p>Yield every date between start and end inclusive.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def daterange(start: datetime.date, end: datetime.date) -&gt; Iterable[datetime.date]:\n    \"\"\"Yield every date between start and end inclusive.\"\"\"\n\n    current = start\n    while current &lt;= end:\n        yield current\n        current += datetime.timedelta(days=1)\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.top_modifiers","title":"<code>top_modifiers(start, end, *, limit=10)</code>","text":"<p>Return the most frequently used modifiers with friendly ingredient labels.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def top_modifiers(start: datetime.date, end: datetime.date, *, limit: int | None = 10) -&gt; List[Dict]:\n    \"\"\"Return the most frequently used modifiers with friendly ingredient labels.\"\"\"\n\n    items = (\n        OrderItem.objects\n        .select_related(\"order\")\n        .filter(order__order_date__date__gte=start, order__order_date__date__lte=end)\n    )\n\n    modifier_totals: Dict[str, Dict[str, object]] = {}\n\n    for item in items:\n        qty = Decimal(item.quantity or 0)\n        revenue = (item.unit_price or Decimal(\"0\")) * qty\n        info = item.variant_info or {}\n        modifiers = set(info.get(\"modifiers\") or [])\n        for modifier in modifiers:\n            normalized = _normalize_descriptor_token(modifier)\n            if (\n                not normalized\n                or normalized in SUPPRESSED_DESCRIPTOR_TOKENS\n                or normalized in IGNORED_MODIFIER_TOKENS\n            ):\n                continue\n            bucket = modifier_totals.setdefault(\n                normalized,\n                {\n                    \"quantity\": Decimal(\"0\"),\n                    \"gross_sales\": Decimal(\"0\"),\n                    \"raw_labels\": set(),\n                },\n            )\n            bucket[\"quantity\"] += qty\n            bucket[\"gross_sales\"] += revenue\n            bucket[\"raw_labels\"].add(modifier)\n\n    if not modifier_totals:\n        return []\n\n    raw_names = {label for bucket in modifier_totals.values() for label in bucket[\"raw_labels\"]}\n    modifier_qs = (\n        RecipeModifier.objects\n        .select_related(\"ingredient\", \"ingredient__unit_type\")\n        .filter(Q(name__in=raw_names) | Q(ingredient__name__in=raw_names))\n    )\n\n    resolved_modifiers: Dict[str, RecipeModifier] = {}\n    for rm in modifier_qs:\n        resolved_modifiers[_normalize_descriptor_token(rm.name)] = rm\n        if rm.ingredient:\n            resolved_modifiers[_normalize_descriptor_token(rm.ingredient.name)] = rm\n\n    rows = []\n    for normalized_name, payload in modifier_totals.items():\n        raw_labels = sorted(payload[\"raw_labels\"], key=str.lower)\n        modifier_obj = resolved_modifiers.get(normalized_name)\n        if not modifier_obj:\n            for label in raw_labels:\n                modifier_obj = resolved_modifiers.get(_normalize_descriptor_token(label))\n                if modifier_obj:\n                    break\n\n        display_name = raw_labels[0] if raw_labels else normalized_name\n        unit = None\n        if modifier_obj:\n            if modifier_obj.ingredient:\n                display_name = modifier_obj.ingredient.name\n                unit_type = getattr(modifier_obj.ingredient, \"unit_type\", None)\n                unit = modifier_obj.unit or getattr(unit_type, \"abbreviation\", None) or getattr(unit_type, \"name\", None)\n            else:\n                display_name = modifier_obj.name\n                unit = modifier_obj.unit\n\n        rows.append({\n            \"modifier\": display_name,\n            \"original_label\": raw_labels[0] if raw_labels else None,\n            \"unit\": unit,\n            \"quantity\": payload[\"quantity\"],\n            \"gross_sales\": payload[\"gross_sales\"],\n            \"rank_key\": normalized_name,\n        })\n\n    rows.sort(key=lambda row: (row[\"quantity\"], row[\"gross_sales\"]), reverse=True)\n    return rows[:limit] if limit else rows\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.top_modifiers_with_changes","title":"<code>top_modifiers_with_changes(start, end, *, limit=10)</code>","text":"<p>Return top modifiers annotated with rank deltas versus the previous window.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def top_modifiers_with_changes(start: datetime.date, end: datetime.date, *, limit: int = 10) -&gt; list[dict]:\n    \"\"\"Return top modifiers annotated with rank deltas versus the previous window.\"\"\"\n\n    current = top_modifiers(start, end, limit=limit)\n    prev_start, prev_end = _previous_window(start, end)\n    previous = top_modifiers(prev_start, prev_end, limit=None)\n    return _annotate_rank_changes(current, previous, lambda row: row.get(\"rank_key\"))\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.top_selling_products","title":"<code>top_selling_products(start, end, *, limit=10)</code>","text":"<p>Return top-selling products aggregated by base product with variant breakdowns.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def top_selling_products(start: datetime.date, end: datetime.date, *, limit: int | None = 10) -&gt; List[Dict]:\n    \"\"\"Return top-selling products aggregated by base product with variant breakdowns.\"\"\"\n\n    items = (\n        OrderItem.objects\n        .select_related(\"product\", \"order\")\n        .filter(order__order_date__date__gte=start, order__order_date__date__lte=end)\n    )\n\n    totals: Dict[\n        Tuple[int | None, str],\n        Dict[str, object],\n    ] = {}\n\n    def _ensure_bucket(key: Tuple[int | None, str], display_name: str):\n        bucket = totals.get(key)\n        if bucket is None:\n            bucket = {\n                \"product_key\": key[0] or key[1],\n                \"product_name\": display_name,\n                \"adjectives\": {},\n                \"modifiers\": {},\n                \"suppressed_descriptors\": {},\n                \"quantity\": Decimal(\"0\"),\n                \"gross_sales\": Decimal(\"0\"),\n                \"variant_details\": {},\n            }\n            totals[key] = bucket\n        return bucket\n\n    for item in items:\n        product = item.product\n        qty = Decimal(item.quantity or 0)\n        revenue = (item.unit_price or Decimal(\"0\")) * qty\n        info = item.variant_info or {}\n\n        adjectives_raw = info.get(\"adjectives\") or []\n        modifiers_raw = info.get(\"modifiers\") or []\n\n        kept_adjectives, suppressed_adjectives = _split_descriptor_tokens(adjectives_raw)\n        kept_modifiers, suppressed_modifiers = _split_descriptor_tokens(modifiers_raw)\n        kept_modifiers = [\n            token\n            for token in kept_modifiers\n            if _normalize_descriptor_token(token) not in IGNORED_MODIFIER_TOKENS\n        ]\n\n        size_token = info.get(\"size\")\n        temp_token = info.get(\"temp_type\")\n        meta_suppressed: list[str] = []\n        for token in (size_token, temp_token):\n            normalized = _normalize_descriptor_token(token)\n            if normalized:\n                if normalized in SUPPRESSED_DESCRIPTOR_TOKENS:\n                    meta_suppressed.append(token)\n                else:\n                    kept_adjectives.append(token)\n\n        canonical_product = (product.name if product else info.get(\"name\") or \"Unmapped\").strip() or \"Unmapped\"\n        product_key = getattr(product, \"id\", None)\n        bucket_key = (product_key, canonical_product.lower())\n        bucket = _ensure_bucket(bucket_key, canonical_product)\n\n        def _capture(tokens: Iterable[str], storage: dict[str, str]):\n            for token in tokens:\n                normalized = _normalize_descriptor_token(token)\n                if not normalized:\n                    continue\n                storage.setdefault(normalized, token)\n\n        def _capture_modifiers(tokens: Iterable[str], storage: dict[str, dict[str, object]], qty: Decimal):\n            \"\"\"Track modifier labels while accumulating quantity occurrences.\"\"\"\n            for token in tokens:\n                normalized = _normalize_descriptor_token(token)\n                if not normalized:\n                    continue\n                entry = storage.setdefault(normalized, {\"label\": token, \"count\": Decimal(\"0\")})\n                entry[\"count\"] += qty\n                if not entry.get(\"label\"):\n                    entry[\"label\"] = token\n\n        _capture(kept_adjectives, bucket[\"adjectives\"])\n        _capture_modifiers(kept_modifiers, bucket[\"modifiers\"], qty)\n        _capture(suppressed_adjectives, bucket[\"suppressed_descriptors\"])\n        _capture(suppressed_modifiers, bucket[\"suppressed_descriptors\"])\n        _capture(meta_suppressed, bucket[\"suppressed_descriptors\"])\n\n        bucket[\"quantity\"] += qty\n        bucket[\"gross_sales\"] += revenue\n\n        normalized_adjectives = tuple(sorted({\n            _normalize_descriptor_token(token)\n            for token in kept_adjectives\n            if _normalize_descriptor_token(token)\n        }))\n        normalized_modifiers = tuple(sorted({\n            _normalize_descriptor_token(token)\n            for token in kept_modifiers\n            if _normalize_descriptor_token(token)\n        }))\n        normalized_suppressed = tuple(sorted({\n            _normalize_descriptor_token(token)\n            for token in list(suppressed_adjectives) + list(suppressed_modifiers) + list(meta_suppressed)\n            if _normalize_descriptor_token(token)\n        }))\n\n        variant_key = (normalized_adjectives, normalized_modifiers, normalized_suppressed)\n        variant_bucket = bucket[\"variant_details\"].get(variant_key)\n        if variant_bucket is None:\n            variant_bucket = {\n                \"adjectives\": tuple(_unique_preserving_order(kept_adjectives)),\n                \"modifiers\": tuple(_unique_preserving_order(kept_modifiers)),\n                \"suppressed_descriptors\": tuple(_unique_preserving_order(list(suppressed_adjectives) + list(suppressed_modifiers) + list(meta_suppressed))),\n                \"quantity\": Decimal(\"0\"),\n                \"gross_sales\": Decimal(\"0\"),\n            }\n            bucket[\"variant_details\"][variant_key] = variant_bucket\n\n        variant_bucket[\"quantity\"] += qty\n        variant_bucket[\"gross_sales\"] += revenue\n\n    rows: List[Dict] = []\n    for payload in totals.values():\n        variant_details = list(payload[\"variant_details\"].values())\n        variant_details.sort(key=lambda row: (row[\"quantity\"], row[\"gross_sales\"]), reverse=True)\n\n        sorted_modifiers = sorted(\n            payload[\"modifiers\"].values(),\n            key=lambda entry: (-entry[\"count\"], entry[\"label\"].lower()),\n        )\n\n        rows.append({\n            \"product_name\": payload[\"product_name\"],\n            \"adjectives\": tuple(sorted(payload[\"adjectives\"].values(), key=str.lower)),\n            \"modifiers\": tuple(entry[\"label\"] for entry in sorted_modifiers),\n            \"suppressed_descriptors\": tuple(sorted(payload[\"suppressed_descriptors\"].values(), key=str.lower)),\n            \"quantity\": payload[\"quantity\"],\n            \"gross_sales\": payload[\"gross_sales\"],\n            \"variant_count\": len(variant_details),\n            \"variant_details\": tuple(variant_details),\n            \"rank_key\": payload.get(\"product_key\") or payload[\"product_name\"].lower(),\n        })\n\n    rows.sort(key=lambda row: (row[\"quantity\"], row[\"gross_sales\"]), reverse=True)\n    return rows[:limit] if limit else rows\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.top_selling_products_with_changes","title":"<code>top_selling_products_with_changes(start, end, *, limit=10)</code>","text":"<p>Return top products annotated with rank deltas versus the previous window.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def top_selling_products_with_changes(start: datetime.date, end: datetime.date, *, limit: int = 10) -&gt; list[dict]:\n    \"\"\"Return top products annotated with rank deltas versus the previous window.\"\"\"\n\n    current = top_selling_products(start, end, limit=limit)\n    prev_start, prev_end = _previous_window(start, end)\n    previous = top_selling_products(prev_start, prev_end, limit=None)\n    return _annotate_rank_changes(current, previous, lambda row: row.get(\"rank_key\"))\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.usage_detail_by_day","title":"<code>usage_detail_by_day(start, end)</code>","text":"Returns detailed rows suitable for CSV <p>date, ingredient, qty_used, unit_cost_as_of_day, cogs</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def usage_detail_by_day(start: datetime.date, end: datetime.date) -&gt; List[Dict]:\n    \"\"\"\n    Returns detailed rows suitable for CSV:\n      date, ingredient, qty_used, unit_cost_as_of_day, cogs\n    \"\"\"\n    out: List[Dict] = []\n    cur = start\n    while cur &lt;= end:\n        # Aggregate all usage logs for the day by ingredient\n        day_rows = (IngredientUsageLog.objects\n                    .select_related(\"ingredient\")\n                    .filter(date=cur)\n                    .values(\"ingredient_id\", \"ingredient__name\")\n                    .annotate(qty_used=Sum(\"quantity_used\"))\n                    .order_by(\"ingredient__name\"))\n        for r in day_rows:\n            unit_cost = average_cost_as_of_date(r[\"ingredient_id\"], cur)\n            qty = r[\"qty_used\"] or Decimal(0)\n            cogs = (qty * unit_cost).quantize(Decimal(\"0.01\"), rounding=ROUND_HALF_UP)\n            out.append({\n                \"date\": cur.isoformat(),\n                \"ingredient\": r[\"ingredient__name\"],\n                \"qty_used\": qty.quantize(Decimal(\"0.001\")),\n                \"unit_cost\": unit_cost,\n                \"cogs\": cogs,\n            })\n        cur += datetime.timedelta(days=1)\n    return out\n</code></pre>"},{"location":"16_API/utils/#mscrInventory.utils.reports.validate_cogs_linkage","title":"<code>validate_cogs_linkage(start, end)</code>","text":"<p>Identify ingredients without cost data within the usage window.</p> Source code in <code>mscrInventory/utils/reports.py</code> <pre><code>def validate_cogs_linkage(start: datetime.date, end: datetime.date) -&gt; Dict[str, List[str]]:\n    \"\"\"Identify ingredients without cost data within the usage window.\"\"\"\n\n    missing_cost: set[str] = set()\n    logs = (\n        IngredientUsageLog.objects\n        .select_related(\"ingredient\")\n        .filter(date__gte=start, date__lte=end)\n    )\n    for log in logs:\n        cost = log.ingredient.average_cost_per_unit or Decimal(\"0\")\n        if cost &lt;= 0:\n            missing_cost.add(log.ingredient.name)\n\n    return {\"missing_cost_ingredients\": sorted(missing_cost)}\n</code></pre>"},{"location":"16_API/views/","title":"Views API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized</p>"},{"location":"16_API/views/#authentication-and-user-management","title":"Authentication and user management","text":"<p>Authentication helper views.</p> <p>Manager-facing dashboard for user and group management.</p>"},{"location":"16_API/views/#mscrInventory.views.auth.LoginView","title":"<code>LoginView</code>","text":"<p>               Bases: <code>LoginView</code></p> <p>Custom login view that surfaces the public signup modal.</p>"},{"location":"16_API/views/#mscrInventory.views.auth.LoginView.get_context_data","title":"<code>get_context_data(**kwargs)</code>","text":"<p>Inject the signup form to support modal toggling.</p> Source code in <code>mscrInventory/views/auth.py</code> <pre><code>def get_context_data(self, **kwargs):\n    \"\"\"Inject the signup form to support modal toggling.\"\"\"\n    context = super().get_context_data(**kwargs)\n    context.setdefault(\"signup_form\", PublicUserCreateForm(prefix=\"signup\"))\n    context.setdefault(\"show_signup_modal\", False)\n    return context\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.auth.logout_view","title":"<code>logout_view(request)</code>","text":"<p>Log the user out and redirect to the configured page.</p> Source code in <code>mscrInventory/views/auth.py</code> <pre><code>def logout_view(request):\n    \"\"\"Log the user out and redirect to the configured page.\"\"\"\n\n    logout(request)\n    return redirect(settings.LOGOUT_REDIRECT_URL)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.auth.signup_view","title":"<code>signup_view(request)</code>","text":"<p>Handle self-service account creation for pending users.</p> Source code in <code>mscrInventory/views/auth.py</code> <pre><code>@require_POST\ndef signup_view(request):\n    \"\"\"Handle self-service account creation for pending users.\"\"\"\n\n    if request.user.is_authenticated:\n        return redirect(settings.LOGIN_REDIRECT_URL)\n\n    signup_form = PublicUserCreateForm(request.POST, prefix=\"signup\")\n    login_form = AuthenticationForm(request=request)\n\n    if signup_form.is_valid():\n        new_user = signup_form.save()\n        pending_group, _ = Group.objects.get_or_create(name=\"pending\")\n        new_user.groups.add(pending_group)\n        messages.success(\n            request,\n            \"Account requested. You will be able to sign in after an administrator approves access.\",\n        )\n        return redirect(reverse(\"login\"))\n\n    context = {\n        \"form\": login_form,\n        \"signup_form\": signup_form,\n        \"show_signup_modal\": True,\n    }\n    return render(request, \"registration/login.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.user_management.manage_users_groups_view","title":"<code>manage_users_groups_view(request)</code>","text":"<p>Allow Managers and superusers to manage accounts without Django admin.</p> Source code in <code>mscrInventory/views/user_management.py</code> <pre><code>@login_required\ndef manage_users_groups_view(request):\n    \"\"\"Allow Managers and superusers to manage accounts without Django admin.\"\"\"\n\n    if not _has_user_admin_access(request.user):\n        raise PermissionDenied\n\n    User = get_user_model()\n    can_add_user = request.user.has_perm(\"auth.add_user\") or request.user.is_superuser\n    can_change_user = request.user.has_perm(\"auth.change_user\") or request.user.is_superuser\n\n    selected_user = None\n    selected_user_id = request.GET.get(\"user\")\n    if selected_user_id:\n        selected_user = get_object_or_404(User, pk=selected_user_id)\n\n    create_form = UserCreateForm(prefix=\"create\")\n    edit_form = UserUpdateForm(prefix=\"edit\", instance=selected_user) if selected_user else None\n\n    if request.method == \"POST\":\n        action = request.POST.get(\"action\")\n        if action == \"create\":\n            if not can_add_user:\n                raise PermissionDenied\n            create_form = UserCreateForm(request.POST, prefix=\"create\")\n            if create_form.is_valid():\n                new_user = create_form.save()\n                messages.success(request, f\"Created user {new_user.username}.\")\n                return redirect(f\"{reverse('manage_users')}?user={new_user.pk}\")\n        elif action == \"update\":\n            if not can_change_user:\n                raise PermissionDenied\n            user_id = request.POST.get(\"user_id\")\n            target = get_object_or_404(User, pk=user_id)\n            edit_form = UserUpdateForm(request.POST, instance=target, prefix=\"edit\")\n            if edit_form.is_valid():\n                edit_form.save()\n                messages.success(request, f\"Updated user {target.username}.\")\n                return redirect(f\"{reverse('manage_users')}?user={target.pk}\")\n\n    users = User.objects.order_by(\"username\")\n    groups = Group.objects.order_by(\"name\").prefetch_related(\"permissions\", \"user_set\")\n\n    context = {\n        \"create_form\": create_form,\n        \"edit_form\": edit_form,\n        \"selected_user\": selected_user,\n        \"users\": users,\n        \"groups\": groups,\n        \"can_add_user\": can_add_user,\n        \"can_change_user\": can_change_user,\n    }\n    return render(request, \"user_management.html\", context)\n</code></pre>"},{"location":"16_API/views/#dashboard-and-reporting","title":"Dashboard and reporting","text":"<p>Views that render the executive dashboard.</p> <p>Reporting dashboards for COGS, usage, and profitability.</p>"},{"location":"16_API/views/#mscrInventory.views.dashboard.dashboard_view","title":"<code>dashboard_view(request)</code>","text":"<p>Render dashboard cards, stats, warnings, and quick actions.</p> Source code in <code>mscrInventory/views/dashboard.py</code> <pre><code>@login_required\ndef dashboard_view(request: HttpRequest) -&gt; HttpResponse:\n    \"\"\"Render dashboard cards, stats, warnings, and quick actions.\"\"\"\n    role = (\n        request.user.groups.first().name\n        if request.user.groups.exists()\n        else \"Unassigned\"\n    )\n    low_stock_summary = get_low_stock_summary()\n    stat_counts = get_stat_counts()\n    stat_cards = build_stat_cards(stat_counts, low_stock_summary)\n    recent_imports = get_recent_imports()\n\n    context = {\n        \"stat_cards\": stat_cards,\n        \"recent_imports\": recent_imports,\n        \"activity_feed\": get_activity_feed(),\n        \"quick_actions\": get_quick_actions(),\n        \"named_drinks\": get_top_named_drinks(),\n        \"named_drinks_window\": NAMED_DRINK_LOOKBACK_DAYS,\n        \"warnings\": get_warning_items(low_stock_summary, stat_counts, recent_imports),\n        \"shortcuts\": get_shortcuts(),\n        \"user_role\": role,\n    }\n    return render(request, \"dashboard.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.reporting.reporting_dashboard_view","title":"<code>reporting_dashboard_view(request)</code>","text":"<p>Render the reporting dashboard with aggregates and raw usage logs.</p> Source code in <code>mscrInventory/views/reporting.py</code> <pre><code>@permission_required(\"mscrInventory.change_order\", raise_exception=True)\n@login_required\ndef reporting_dashboard_view(request):\n    \"\"\"Render the reporting dashboard with aggregates and raw usage logs.\"\"\"\n    today = timezone.localdate()\n    default_start = today - datetime.timedelta(days=6)\n    start = _parse_date(request.GET.get(\"start\")) or default_start\n    end = _parse_date(request.GET.get(\"end\")) or today\n    if end &lt; start:\n        start, end = end, start\n\n    tzname = getattr(settings, \"SYNC_TIMEZONE\", \"America/New_York\")\n\n    product_summary = reports.cogs_summary_by_product(start, end)\n    category_summary = reports.cogs_summary_by_category(start, end)\n    profitability = reports.category_profitability(start, end)\n    trend = reports.cogs_trend_with_variance(start, end, tzname=tzname)\n    usage_totals = reports.aggregate_usage_totals(start, end)\n    linkage = reports.validate_cogs_linkage(start, end)\n    top_products = reports.top_selling_products_with_changes(start, end)\n    top_modifiers = reports.top_modifiers_with_changes(start, end)\n\n    total_cogs = sum((row[\"cogs\"] for row in product_summary), Decimal(\"0\"))\n    total_revenue = sum((row[\"revenue\"] for row in product_summary), Decimal(\"0\"))\n\n    usage_logs = (\n        IngredientUsageLog.objects\n        .select_related(\"ingredient\")\n        .filter(date__gte=start, date__lte=end)\n        .order_by(\"-date\", \"ingredient__name\")\n    )\n    unresolved_count = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).count()\n\n    context = {\n        \"start\": start,\n        \"end\": end,\n        \"product_summary\": product_summary,\n        \"category_summary\": category_summary,\n        \"profitability\": profitability,\n        \"trend\": trend,\n        \"usage_totals\": sorted(usage_totals.items()),\n        \"usage_logs\": usage_logs,\n        \"linkage\": linkage,\n        \"top_products\": top_products,\n        \"top_modifiers\": top_modifiers,\n        \"total_cogs\": total_cogs,\n        \"total_revenue\": total_revenue,\n        \"tzname\": tzname,\n        \"unresolved_count\": unresolved_count,\n        \"quick_date_ranges\": _quick_date_ranges(today),\n    }\n\n    return render(request, \"reports/dashboard.html\", context)\n</code></pre>"},{"location":"16_API/views/#imports-and-mapping","title":"Imports and mapping","text":"<p>Import views for handling external data sources.</p> <p>Modifier catalog views, bulk importer, and explorer endpoints.</p>"},{"location":"16_API/views/#mscrInventory.views.imports.bulk_unmapped_action","title":"<code>bulk_unmapped_action(request)</code>","text":"<p>Apply a batch link/create action to selected unmapped entries.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef bulk_unmapped_action(request):\n    \"\"\"Apply a batch link/create action to selected unmapped entries.\"\"\"\n    action = request.POST.get(\"action\")\n    filter_type = request.POST.get(\"filter_type\") or \"all\"\n    allowed_types = {choice[0] for choice in SquareUnmappedItem.ITEM_TYPE_CHOICES}\n    include_known = _should_include_known(request.POST.getlist(\"include_known\"))\n\n    qs = SquareUnmappedItem.objects.filter(resolved=False, ignored=False)\n    if filter_type in allowed_types:\n        qs = qs.filter(item_type=filter_type)\n\n    if not include_known:\n        product_match = Product.objects.filter(name__iexact=OuterRef(\"item_name\"))\n        qs = qs.annotate(_known_recipe=Exists(product_match)).filter(_known_recipe=False)\n\n    user = request.user if request.user.is_authenticated else None\n    processed = 0\n\n    if action == \"resolve\":\n        for item in qs:\n            item.mark_resolved(user=user)\n            processed += 1\n        if processed:\n            messages.success(request, f\"\u2705 Marked {processed} items as resolved.\")\n    elif action == \"ignore\":\n        for item in qs:\n            item.mark_resolved(user=user, ignored=True)\n            processed += 1\n        if processed:\n            messages.warning(request, f\"\u26a0\ufe0f Ignored {processed} items.\")\n    elif action == \"create\":\n        for item in qs:\n            name = item.price_point_name or item.item_name\n            if item.item_type == \"product\":\n                sku = CreateFromUnmappedItemForm._generate_default_sku(item, fallback=name)\n                product = Product.objects.create(name=name, sku=sku)\n                item.mark_resolved(user=user, product=product)\n                processed += 1\n            elif item.item_type == \"ingredient\":\n                ingredient, _created = Ingredient.objects.get_or_create(name=name)\n                item.mark_resolved(user=user, ingredient=ingredient)\n                processed += 1\n        if processed:\n            messages.success(request, f\"\u2705 Created {processed} placeholder records.\")\n        else:\n            messages.info(request, \"\u2139\ufe0f No eligible items to create automatically.\")\n    else:\n        messages.error(request, \"\u274c Unknown bulk action.\")\n\n    redirect_url = f\"{reverse('imports_unmapped_items')}?type={filter_type}\"\n    if include_known:\n        redirect_url += \"&amp;include_known=true\"\n    return redirect(redirect_url)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.create_unmapped_item","title":"<code>create_unmapped_item(request, pk)</code>","text":"<p>Create a Product/Ingredient/Modifier from an unmapped entry.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef create_unmapped_item(request, pk: int):\n    \"\"\"Create a Product/Ingredient/Modifier from an unmapped entry.\"\"\"\n    item = get_object_or_404(SquareUnmappedItem, pk=pk, ignored=False)\n    filter_type = request.POST.get(\"filter_type\") or None\n    item.is_known_recipe = Product.objects.filter(name__iexact=item.item_name).exists()\n\n    form = CreateFromUnmappedItemForm(request.POST, item=item)\n    try:\n        if form.is_valid():\n            user = request.user if request.user.is_authenticated else None\n            form.save(user=user)\n            response = _render_unmapped_table(request, filter_type)\n            response[\"HX-Trigger\"] = json.dumps(\n                {\n                    \"showMessage\": {\n                        \"text\": \"\u2705 Created new record from unmapped item.\",\n                        \"level\": \"success\",\n                    }\n                }\n            )\n            return response\n    except django_forms.ValidationError as exc:\n        form.add_error(None, exc.message)\n\n    overrides = {(\"create\", item.id): form}\n    return _render_unmapped_table(request, filter_type, form_overrides=overrides, status=400)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.fetch_shopify_view","title":"<code>fetch_shopify_view(request)</code>","text":"<p>Trigger Shopify importer via management command and surface output.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef fetch_shopify_view(request):\n    \"\"\"Trigger Shopify importer via management command and surface output.\"\"\"\n    \"\"\"Fetch Shopify data for a date or range.\"\"\"\n\n    start_date = request.POST.get(\"start_date\")\n    end_date = request.POST.get(\"end_date\")\n    if not start_date:\n        messages.error(request, \"Start date is required.\")\n        return redirect(\"imports_dashboard\")\n\n    output_buffer = StringIO()\n    started_at = timezone.now()\n    try:\n        if end_date:\n            call_command(\n                \"sync_orders\",\n                start_date=start_date,\n                end_date=end_date,\n                verbosity=2,\n                stdout=output_buffer,\n                stderr=output_buffer,\n            )\n            summary = f\"Shopify orders fetched for {start_date} \u2192 {end_date}\"\n        else:\n            call_command(\n                \"sync_orders\",\n                date=start_date,\n                verbosity=2,\n                stdout=output_buffer,\n                stderr=output_buffer,\n            )\n            summary = f\"Shopify orders fetched for {start_date}\"\n        finished_at = timezone.now()\n        duration_seconds = (finished_at - started_at).total_seconds()\n        log_output = output_buffer.getvalue() or summary\n\n        ImportLog.objects.create(\n            source=\"shopify\",\n            run_type=\"live\",\n            filename=\"\",\n            started_at=started_at,\n            finished_at=finished_at,\n            duration_seconds=Decimal(str(duration_seconds)),\n            summary=summary,\n            log_output=log_output,\n            uploaded_by=request.user if request.user.is_authenticated else None,\n        )\n        messages.success(request, f\"\u2705 {summary}\")\n        if log_output and log_output != summary:\n            messages.info(\n                request,\n                format_html(\n                    \"&lt;pre class='import-log bg-light p-3 border rounded small mb-0'&gt;{}&lt;/pre&gt;\",\n                    log_output,\n                ),\n            )\n    except Exception as exc:  # pragma: no cover - defensive logging\n        finished_at = timezone.now()\n        log_output = output_buffer.getvalue()\n        messages.error(request, f\"\u274c Error fetching Shopify data: {exc}\")\n        if log_output:\n            messages.error(\n                request,\n                format_html(\n                    \"&lt;pre class='import-log bg-light p-3 border rounded small mb-0'&gt;{}&lt;/pre&gt;\",\n                    log_output,\n                ),\n            )\n\n    return redirect(\"imports_dashboard\")\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.ignore_unmapped_item","title":"<code>ignore_unmapped_item(request, pk)</code>","text":"<p>Hide an unmapped entry without resolving it.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef ignore_unmapped_item(request, pk: int):\n    \"\"\"Hide an unmapped entry without resolving it.\"\"\"\n    item = get_object_or_404(SquareUnmappedItem, pk=pk)\n    filter_type = request.POST.get(\"filter_type\") or None\n\n    user = request.user if request.user.is_authenticated else None\n    item.mark_resolved(user=user, ignored=True)\n\n    response = _render_unmapped_table(request, filter_type)\n    response[\"HX-Trigger\"] = json.dumps(\n        {\"showMessage\": {\"text\": \"\u26a0\ufe0f Item ignored for now.\", \"level\": \"warning\"}}\n    )\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.import_logs_view","title":"<code>import_logs_view(request)</code>","text":"<p>List ImportLog rows with optional AJAX partial rendering.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>def import_logs_view(request):\n    \"\"\"List ImportLog rows with optional AJAX partial rendering.\"\"\"\n    \"\"\"Display a paginated history of import logs.\"\"\"\n\n    logs = ImportLog.objects.select_related(\"uploaded_by\").order_by(\"-created_at\")\n    unresolved_qs = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).order_by(\n        \"-last_seen\", \"item_name\"\n    )\n    unmapped_preview = list(unresolved_qs[:5])\n    unmapped_total = unresolved_qs.count()\n\n    error_qs = ImportLog.objects.filter(error_count__gt=0)\n    error_preview = list(error_qs.order_by(\"-created_at\")[:5])\n    error_total = error_qs.count()\n    paginator = Paginator(logs, 20)\n    page_number = request.GET.get(\"page\")\n    try:\n        page_obj = paginator.page(page_number or 1)\n    except (PageNotAnInteger, EmptyPage):\n        page_obj = paginator.page(1)\n\n    return render(\n        request,\n        \"imports/log_list.html\",\n        {\n            \"page_obj\": page_obj,\n            \"unmapped_preview\": unmapped_preview,\n            \"unmapped_total\": unmapped_total,\n            \"error_preview\": error_preview,\n            \"error_total\": error_total,\n        },\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.imports_dashboard_view","title":"<code>imports_dashboard_view(request)</code>","text":"<p>Renders the unified imports dashboard.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\n@login_required\ndef imports_dashboard_view(request):\n    \"\"\"Renders the unified imports dashboard.\"\"\"\n\n    unresolved_count = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).count()\n    return render(request, \"imports/dashboard.html\", {\"unresolved_count\": unresolved_count})\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.link_unmapped_item","title":"<code>link_unmapped_item(request, pk)</code>","text":"<p>Resolve a SquareUnmappedItem by linking to an existing record.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef link_unmapped_item(request, pk: int):\n    \"\"\"Resolve a SquareUnmappedItem by linking to an existing record.\"\"\"\n    item = get_object_or_404(SquareUnmappedItem, pk=pk, ignored=False)\n    filter_type = request.POST.get(\"filter_type\") or None\n    item.is_known_recipe = Product.objects.filter(name__iexact=item.item_name).exists()\n\n    form = LinkUnmappedItemForm(request.POST, item=item)\n    if form.is_valid():\n        user = request.user if request.user.is_authenticated else None\n        form.save(user=user)\n        response = _render_unmapped_table(request, filter_type)\n        response[\"HX-Trigger\"] = json.dumps(\n            {\"showMessage\": {\"text\": \"\u2705 Linked to existing record.\", \"level\": \"success\"}}\n        )\n        return response\n\n    overrides = {(\"link\", item.id): form}\n    return _render_unmapped_table(request, filter_type, form_overrides=overrides, status=400)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.reclassify_unmapped_item","title":"<code>reclassify_unmapped_item(request, pk)</code>","text":"<p>Allow updating the expected item_type for an unmapped Square entry.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef reclassify_unmapped_item(request, pk: int):\n    \"\"\"Allow updating the expected item_type for an unmapped Square entry.\"\"\"\n\n    item = get_object_or_404(SquareUnmappedItem, pk=pk, ignored=False)\n    filter_type = request.POST.get(\"filter_type\") or None\n    target_type = (request.POST.get(\"item_type\") or \"\").strip().lower()\n    allowed_types = {choice[0] for choice in SquareUnmappedItem.ITEM_TYPE_CHOICES}\n\n    if target_type not in allowed_types:\n        response = _render_unmapped_table(request, filter_type, status=400)\n        response[\"HX-Trigger\"] = json.dumps(\n            {\"showMessage\": {\"text\": \"\u274c Invalid type selected.\", \"level\": \"danger\"}}\n        )\n        return response\n\n    if target_type != item.item_type:\n        item.item_type = target_type\n        item.resolved = False\n        item.ignored = False\n        item.resolved_at = None\n        item.resolved_by = None\n        item.linked_product = None\n        item.linked_ingredient = None\n        item.linked_modifier = None\n        item.last_reason = \"manual_reclass\"\n        item.save(\n            update_fields=[\n                \"item_type\",\n                \"resolved\",\n                \"ignored\",\n                \"resolved_at\",\n                \"resolved_by\",\n                \"linked_product\",\n                \"linked_ingredient\",\n                \"linked_modifier\",\n                \"last_reason\",\n            ]\n        )\n\n    response = _render_unmapped_table(request, filter_type)\n    response[\"HX-Trigger\"] = json.dumps(\n        {\n            \"showMessage\": {\n                \"text\": f\"\ud83d\udd01 Updated type to {target_type.title()} for {item.display_label}.\",\n                \"level\": \"info\",\n            }\n        }\n    )\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.unmapped_items_view","title":"<code>unmapped_items_view(request)</code>","text":"<p>Render modal or page content summarising unmapped entries.</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef unmapped_items_view(request):\n    \"\"\"Render modal or page content summarising unmapped entries.\"\"\"\n\n    filter_type = request.GET.get(\"type\")\n    page_number = request.GET.get(\"page\")\n    include_known = _should_include_known(request.GET.getlist(\"include_known\"))\n    is_modal_request = request.headers.get(\"HX-Request\") == \"true\"\n    paginate = not is_modal_request\n    context = _build_unmapped_context(\n        filter_type,\n        page=page_number if paginate else None,\n        paginate=paginate,\n        include_known=include_known,\n    )\n\n    hx_target = (request.headers.get(\"HX-Target\") or \"\").lstrip(\"#\")\n    if hx_target == \"unmapped-body\":\n        template = \"imports/_unmapped_body.html\"\n    elif hx_target == \"unmapped-items-table\":\n        template = \"partials/unmapped_square_items_table.html\"\n    elif request.headers.get(\"HX-Request\") == \"true\":\n        template = \"imports/_unmapped_modal.html\"\n    else:\n        template = \"imports/unmapped_items.html\"\n\n    return render(request, template, context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.imports.upload_square_view","title":"<code>upload_square_view(request)</code>","text":"<p>Handle Square CSV upload via dashboard (supports dry run).</p> Source code in <code>mscrInventory/views/imports.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef upload_square_view(request):\n    \"\"\"Handle Square CSV upload via dashboard (supports dry run).\"\"\"\n\n    uploaded_file = request.FILES.get(\"square_csv\")\n    dry_run = bool(request.POST.get(\"dry_run\"))\n\n    if not uploaded_file:\n        messages.error(request, \"No file uploaded.\")\n        return redirect(\"imports_dashboard\")\n\n    saved_path = _save_square_upload(uploaded_file)\n\n    try:\n        importer = SquareImporter(dry_run=dry_run)\n        importer.run_from_file(saved_path)\n        output = importer.get_output()\n        summary = importer.get_summary()\n        metadata = importer.get_run_metadata()\n        stats = metadata.get(\"stats\", {})\n        duration = metadata.get(\"duration_seconds\")\n        duration_decimal = Decimal(str(duration)) if duration is not None else None\n\n        ImportLog.objects.create(\n            source=\"square\",\n            run_type=\"dry-run\" if dry_run else \"live\",\n            filename=saved_path.name,\n            started_at=metadata.get(\"started_at\"),\n            finished_at=metadata.get(\"finished_at\"),\n            duration_seconds=duration_decimal,\n            rows_processed=stats.get(\"rows_processed\", 0),\n            matched_count=stats.get(\"matched\", 0),\n            unmatched_count=stats.get(\"unmatched\", 0),\n            order_items=stats.get(\"order_items_logged\", 0),\n            modifiers_applied=stats.get(\"modifiers_applied\", 0),\n            error_count=stats.get(\"errors\", 0),\n            summary=summary,\n            log_output=output,\n            uploaded_by=request.user if request.user.is_authenticated else None,\n        )\n\n        messages.success(\n            request,\n            f\"{'\ud83e\uddea Dry-run complete' if dry_run else '\u2705 Import complete'} \u2014 {uploaded_file.name}\",\n        )\n        messages.info(\n            request,\n            format_html(\n                \"&lt;pre class='import-log bg-light p-3 border rounded small mb-0'&gt;{}&lt;/pre&gt;\",\n                summary,\n            ),\n        )\n\n        if not dry_run:\n            usage_totals = importer.get_usage_totals()\n            usage_by_date = importer.get_usage_totals_by_date()\n            if usage_totals and not usage_by_date:\n                usage_by_date = {None: usage_totals}\n            if usage_totals:\n                business_date_raw = request.POST.get(\"business_date\")\n                default_date = None\n                if business_date_raw:\n                    try:\n                        default_date = datetime.date.fromisoformat(business_date_raw)\n                    except ValueError:\n                        messages.warning(\n                            request,\n                            format_html(\n                                \"\u26a0\ufe0f Invalid business date '{}'. Using {} instead.\",\n                                business_date_raw,\n                                timezone.localdate().isoformat(),\n                            ),\n                        )\n\n                write_usage_logs(usage_by_date, source=\"square\", default_date=default_date)\n                breakdown = importer.get_usage_breakdown() or {}\n                detail_snippets: list[str] = []\n                for ingredient_name, per_source in sorted(breakdown.items()):\n                    total_qty = sum(per_source.values(), Decimal(\"0\"))\n                    detail_snippets.append(\n                        f\"{ingredient_name} \u00d7 {total_qty.quantize(Decimal('0.001'))}\"\n                    )\n                if detail_snippets:\n                    messages.success(\n                        request,\n                        \"\ud83d\udcca Logged Square usage: \" + \"; \".join(detail_snippets),\n                    )\n                else:\n                    messages.success(\n                        request,\n                        f\"\ud83d\udcca Logged Square usage for {len(usage_totals)} ingredient(s).\",\n                    )\n            else:\n                messages.warning(\n                    request,\n                    \"\u26a0\ufe0f Square import completed, but no ingredient usage was detected to log.\",\n                )\n\n    except Exception as exc:  # pragma: no cover - defensive logging\n        messages.error(request, f\"\u274c Error importing Square CSV: {exc}\")\n\n    return redirect(\"imports_dashboard\")\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.confirm_modifiers_import","title":"<code>confirm_modifiers_import(request)</code>","text":"<p>Create RecipeModifier rows from the validated CSV preview.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\n@require_POST\ndef confirm_modifiers_import(request):\n    \"\"\"Create RecipeModifier rows from the validated CSV preview.\"\"\"\n    data_json = request.POST.get(\"valid_rows\") or request.body.decode(\"utf-8\")\n\n    try:\n        rows = json.loads(data_json)\n        if isinstance(rows, str):\n            rows = json.loads(rows)\n    except json.JSONDecodeError as exc:\n        return JsonResponse({\"status\": \"error\", \"message\": str(exc)}, status=400)\n\n    created, updated = 0, 0\n\n    with transaction.atomic():\n        for row in rows:\n            defaults = {\n                \"ingredient_type_id\": row[\"ingredient_type_id\"],\n                \"ingredient_id\": row[\"ingredient_id\"],\n                \"base_quantity\": Decimal(row[\"base_quantity\"]),\n                \"unit\": row[\"unit\"],\n                \"cost_per_unit\": Decimal(row[\"cost_per_unit\"]),\n                \"price_per_unit\": Decimal(row[\"price_per_unit\"]),\n            }\n\n            modifier, created_flag = RecipeModifier.objects.update_or_create(\n                name=row[\"name\"],\n                defaults=defaults,\n            )\n\n            created += int(created_flag)\n            updated += int(not created_flag)\n\n    message = f\"Imported {created} modifier(s); updated {updated}.\"\n    response = HttpResponse(status=204)\n    response[\"HX-Trigger\"] = json.dumps(\n        {\n            \"recipes:refresh\": True,\n            \"showMessage\": {\"text\": f\"\u2705 {message}\", \"level\": \"success\"},\n            \"closeModal\": True,\n        }\n    )\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.create_modifier","title":"<code>create_modifier(request)</code>","text":"<p>Persist a new RecipeModifier from modal form submissions.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\ndef create_modifier(request):\n    \"\"\"Persist a new RecipeModifier from modal form submissions.\"\"\"\n    if request.method != \"POST\":\n        return JsonResponse({\"error\": \"Method not allowed\"}, status=405)\n\n    name = (request.POST.get(\"create_name\") or \"\").strip()\n    modifier_type_id = request.POST.get(\"create_ingredient_type\")\n    ingredient_id = request.POST.get(\"create_ingredient\")\n    base_quantity_raw = request.POST.get(\"create_base_quantity\")\n    unit_type_id = request.POST.get(\"create_unit\")\n    cost_raw = request.POST.get(\"create_cost_per_unit\")\n    price_raw = request.POST.get(\"create_price_per_unit\")\n\n    errors = {}\n\n    if not name:\n        errors[\"name\"] = \"Name is required.\"\n\n    if not modifier_type_id:\n        errors[\"ingredient_type\"] = \"Type is required.\"\n\n    ingredient_type = None\n    if modifier_type_id:\n        try:\n            ingredient_type = IngredientType.objects.get(pk=modifier_type_id)\n        except (ValueError, IngredientType.DoesNotExist):\n            errors[\"ingredient_type\"] = \"Selected type could not be found.\"\n\n    ingredient = None\n    if not ingredient_id:\n        errors[\"ingredient\"] = \"Ingredient is required.\"\n    else:\n        try:\n            ingredient = Ingredient.objects.get(pk=ingredient_id)\n        except Ingredient.DoesNotExist:\n            errors[\"ingredient\"] = \"Selected ingredient could not be found.\"\n\n    base_quantity = None\n    if not base_quantity_raw:\n        errors[\"base_quantity\"] = \"Base quantity is required.\"\n    else:\n        try:\n            base_quantity = Decimal(base_quantity_raw)\n        except (InvalidOperation, TypeError):\n            errors[\"base_quantity\"] = \"Enter a valid quantity.\"\n\n    unit_type = None\n    if not unit_type_id:\n        errors[\"unit\"] = \"Unit is required.\"\n    else:\n        try:\n            unit_type = UnitType.objects.get(pk=unit_type_id)\n        except UnitType.DoesNotExist:\n            errors[\"unit\"] = \"Selected unit is not available.\"\n\n    cost_per_unit = Decimal(\"0.00\")\n    if cost_raw:\n        try:\n            cost_per_unit = Decimal(cost_raw)\n        except (InvalidOperation, TypeError):\n            errors[\"cost_per_unit\"] = \"Enter a valid cost.\"\n\n    price_per_unit = Decimal(\"0.00\")\n    if price_raw:\n        try:\n            price_per_unit = Decimal(price_raw)\n        except (InvalidOperation, TypeError):\n            errors[\"price_per_unit\"] = \"Enter a valid price.\"\n\n    initial_data = {\n        \"name\": name,\n        \"ingredient_type\": modifier_type_id,\n        \"ingredient\": ingredient_id,\n        \"base_quantity\": base_quantity_raw,\n        \"unit\": unit_type_id,\n        \"cost_per_unit\": cost_raw,\n        \"price_per_unit\": price_raw,\n    }\n\n    if errors:\n        return _render_modifier_modal(\n            request,\n            context_overrides={\n                \"new_modifier_errors\": errors,\n                \"new_modifier_data\": initial_data,\n                \"new_modifier_open\": True,\n            },\n        )\n\n    try:\n        modifier = RecipeModifier.objects.create(\n            name=name,\n            ingredient_type=ingredient_type,\n            ingredient=ingredient,\n            base_quantity=base_quantity,\n            unit=unit_type.abbreviation or unit_type.name,\n            behavior=RecipeModifier.ModifierBehavior.ADD,\n            quantity_factor=Decimal(\"1.0\"),\n            cost_per_unit=cost_per_unit,\n            price_per_unit=price_per_unit,\n        )\n    except IntegrityError:\n        errors[\"name\"] = \"A modifier with this name already exists.\"\n        return _render_modifier_modal(\n            request,\n            context_overrides={\n                \"new_modifier_errors\": errors,\n                \"new_modifier_data\": initial_data,\n                \"new_modifier_open\": True,\n            },\n        )\n\n    trigger = {\n        \"showMessage\": {\"text\": f\"Created modifier {modifier.name}.\", \"level\": \"success\"}\n    }\n    return _render_modifier_modal(\n        request,\n        context_overrides={\"selected_modifier_id\": modifier.id},\n        trigger=trigger,\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.create_modifier_alias","title":"<code>create_modifier_alias(request)</code>","text":"<p>Handle alias creation requests from the explorer UI.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\n@require_POST\ndef create_modifier_alias(request):\n    \"\"\"Handle alias creation requests from the explorer UI.\"\"\"\n    modifier_id = request.POST.get('modifier_id')\n    raw_label = (request.POST.get('raw_label') or '').strip()\n    classification = request.POST.get('classification') or ''\n    search_term = request.POST.get('q') or ''\n\n    include_known_products_raw = request.POST.get('include_known_products')\n    include_known_products = include_known_products_raw == 'true'\n\n    if not modifier_id or not raw_label:\n        messages.error(request, 'Select a RecipeModifier and provide an alias label.')\n        return redirect(\n            _modifier_explorer_redirect(\n                classification,\n                search_term,\n                include_known_products if include_known_products_raw is not None else None,\n            )\n        )\n\n    modifier = get_object_or_404(RecipeModifier, pk=modifier_id)\n    normalized = normalize_modifier(raw_label)\n\n    alias, created = RecipeModifierAlias.objects.update_or_create(\n        normalized_label=normalized,\n        defaults={'modifier': modifier, 'raw_label': raw_label},\n    )\n\n    if created:\n        messages.success(request, f'\u2705 Created alias \"{raw_label}\" for {modifier.name}.')\n    else:\n        messages.success(request, f'\u2705 Updated alias \"{raw_label}\" to {modifier.name}.')\n\n    return redirect(\n        _modifier_explorer_redirect(\n            classification,\n            search_term,\n            include_known_products if include_known_products_raw is not None else None,\n        )\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.download_modifiers_template","title":"<code>download_modifiers_template(request)</code>","text":"<p>Provide the canonical CSV template required for imports.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.view_recipemodifier\", raise_exception=True)\ndef download_modifiers_template(request):\n    \"\"\"Provide the canonical CSV template required for imports.\"\"\"\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"modifiers_template.csv\"'\n    writer = csv.writer(response)\n    writer.writerow(\n        [\n            \"Name\",\n            \"Type\",\n            \"Ingredient\",\n            \"Base Quantity\",\n            \"Unit\",\n            \"Cost per Unit\",\n            \"Price per Unit\",\n        ]\n    )\n    writer.writerow(\n        [\n            \"# Sample Modifier (remove)\",\n            \"Milk\",\n            \"Whole Milk\",\n            \"1.00\",\n            \"oz\",\n            \"0.25\",\n            \"0.75\",\n        ]\n    )\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.edit_modifier_extra_view","title":"<code>edit_modifier_extra_view(request, modifier_id)</code>","text":"<p>Display an edit form for modifier extras such as target selectors.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\ndef edit_modifier_extra_view(request, modifier_id):\n    \"\"\"Display an edit form for modifier extras such as target selectors.\"\"\"\n    modifier = get_object_or_404(RecipeModifier, pk=modifier_id)\n    # stub logic for now\n    if request.method == \"POST\":\n        multiplier = request.POST.get(\"multiplier\")\n        linked_ingredient_id = request.POST.get(\"linked_ingredient\") or None\n\n        if multiplier:\n            modifier.price_per_unit = multiplier  # or separate field if needed\n        if linked_ingredient_id:\n            modifier.ingredient_id = linked_ingredient_id\n        else:\n            modifier.ingredient = None\n\n        modifier.save()\n        return JsonResponse({\"status\": \"ok\", \"modifier\": modifier.name})\n\n    ingredients = Ingredient.objects.all().order_by(\"name\")\n    return render(request, \"modifiers/edit_extra_modal.html\", {\"modifier\": modifier, \"ingredients\": ingredients})\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.export_modifiers_csv","title":"<code>export_modifiers_csv(request)</code>","text":"<p>Stream all modifiers in a format compatible with the importer.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.view_recipemodifier\", raise_exception=True)\ndef export_modifiers_csv(request):\n    \"\"\"Stream all modifiers in a format compatible with the importer.\"\"\"\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"modifiers_export.csv\"'\n\n    writer = csv.writer(response)\n    writer.writerow(\n        [\n            \"Name\",\n            \"Type\",\n            \"Ingredient\",\n            \"Base Quantity\",\n            \"Unit\",\n            \"Cost per Unit\",\n            \"Price per Unit\",\n        ]\n    )\n\n    for modifier in RecipeModifier.objects.select_related(\"ingredient\", \"ingredient_type\").order_by(\"name\"):\n        writer.writerow(\n            [\n                modifier.name,\n                modifier.ingredient_type.name if modifier.ingredient_type else \"\",\n                modifier.ingredient.name if modifier.ingredient else \"\",\n                modifier.base_quantity,\n                modifier.unit,\n                modifier.cost_per_unit,\n                modifier.price_per_unit,\n            ]\n        )\n\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.import_modifiers_csv","title":"<code>import_modifiers_csv(request)</code>","text":"<p>Validate a modifier CSV upload and present preview results.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\n@require_POST\ndef import_modifiers_csv(request):\n    \"\"\"Validate a modifier CSV upload and present preview results.\"\"\"\n    csv_file = request.FILES.get(\"file\")\n    if not csv_file:\n        return render(\n            request,\n            \"modifiers/_import_modifiers.html\",\n            {\"error\": \"Please upload a CSV file.\"},\n            status=400,\n        )\n\n    decoded = csv_file.read().decode(\"utf-8-sig\")\n    reader = csv.DictReader(io.StringIO(decoded))\n\n    if not reader.fieldnames:\n        return render(\n            request,\n            \"modifiers/_import_modifiers.html\",\n            {\"error\": \"The uploaded CSV is missing a header row.\"},\n            status=400,\n        )\n\n    headers = [header.strip().lower() for header in reader.fieldnames if header]\n    missing = [column for column in REQUIRED_MODIFIER_COLUMNS if column not in headers]\n    if missing:\n        return render(\n            request,\n            \"modifiers/_import_modifiers.html\",\n            {\n                \"error\": \"Missing required columns: \" + \", \".join(missing),\n            },\n            status=400,\n        )\n\n    valid_rows: list[dict] = []\n    invalid_rows: list[dict] = []\n\n    for index, row in enumerate(reader, start=2):\n        normalized = {\n            (key or \"\").strip().lower(): (value or \"\").strip()\n            for key, value in row.items()\n        }\n\n        if not any(normalized.values()):\n            continue\n\n        name = normalized.get(\"name\", \"\")\n        if not name:\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": normalized.get(\"type\", \"\"),\n                    \"ingredient\": normalized.get(\"ingredient\", \"\"),\n                    \"error\": \"Name is required.\",\n                }\n            )\n            continue\n\n        if name.startswith(\"#\"):\n            continue\n\n        type_name = normalized.get(\"type\", \"\")\n        ingredient_name = normalized.get(\"ingredient\", \"\")\n        unit = normalized.get(\"unit\", \"\")\n        base_quantity_raw = normalized.get(\"base quantity\", \"\")\n        cost_raw = normalized.get(\"cost per unit\", \"\")\n        price_raw = normalized.get(\"price per unit\", \"\")\n\n        ingredient_type = IngredientType.objects.filter(name__iexact=type_name).first()\n        if not ingredient_type:\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Type not found.\",\n                }\n            )\n            continue\n\n        ingredient = Ingredient.objects.filter(name__iexact=ingredient_name).first()\n        if not ingredient:\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Ingredient not found.\",\n                }\n            )\n            continue\n\n        if not unit:\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Unit is required.\",\n                }\n            )\n            continue\n\n        try:\n            base_quantity = Decimal(base_quantity_raw)\n        except (InvalidOperation, TypeError):\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Invalid base quantity.\",\n                }\n            )\n            continue\n\n        try:\n            cost_per_unit = Decimal(cost_raw or \"0\")\n        except (InvalidOperation, TypeError):\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Invalid cost per unit.\",\n                }\n            )\n            continue\n\n        try:\n            price_per_unit = Decimal(price_raw or \"0\")\n        except (InvalidOperation, TypeError):\n            invalid_rows.append(\n                {\n                    \"row\": index,\n                    \"name\": name,\n                    \"type\": type_name,\n                    \"ingredient\": ingredient_name,\n                    \"error\": \"Invalid price per unit.\",\n                }\n            )\n            continue\n\n        valid_rows.append(\n            {\n                \"row\": index,\n                \"name\": name,\n                \"ingredient_type_id\": ingredient_type.id,\n                \"ingredient_type_name\": ingredient_type.name,\n                \"ingredient_id\": ingredient.id,\n                \"ingredient_name\": ingredient.name,\n                \"base_quantity\": str(base_quantity),\n                \"unit\": unit,\n                \"cost_per_unit\": str(cost_per_unit),\n                \"price_per_unit\": str(price_per_unit),\n            }\n        )\n\n    context = {\n        \"valid_rows\": valid_rows,\n        \"invalid_rows\": invalid_rows,\n        \"count_valid\": len(valid_rows),\n        \"count_invalid\": len(invalid_rows),\n        \"valid_rows_json\": json.dumps(valid_rows),\n    }\n\n    return render(request, \"modifiers/_import_modifiers_preview.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.import_modifiers_modal","title":"<code>import_modifiers_modal(request)</code>","text":"<p>Render the modal where CSV uploads can be initiated.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\ndef import_modifiers_modal(request):\n    \"\"\"Render the modal where CSV uploads can be initiated.\"\"\"\n    return render(request, \"modifiers/_import_modifiers.html\")\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.modifier_explorer_view","title":"<code>modifier_explorer_view(request)</code>","text":"<p>Render the interactive modifier explorer with filtering tools.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.view_recipemodifier\", raise_exception=True)\ndef modifier_explorer_view(request):\n    \"\"\"Render the interactive modifier explorer with filtering tools.\"\"\"\n    analyzer = ModifierExplorerAnalyzer()\n    report = analyzer.analyze()\n\n    include_known_products = (request.GET.get('include_known_products') or '').lower() == 'true'\n    classification = (request.GET.get('classification') or 'all').lower()\n    search_term_raw = (request.GET.get('q') or '').strip()\n    search_term = search_term_raw.lower()\n    export_format = (request.GET.get('format') or '').lower()\n\n    product_lookup = {\n        normalize_modifier(name): name\n        for name in Product.objects.values_list('name', flat=True)\n    }\n    matched_unknown_product_count = 0\n    for insight in report.insights.values():\n        match = product_lookup.get(insight.normalized)\n        insight.product_match_name = match\n        if match and insight.classification == 'unknown':\n            matched_unknown_product_count += 1\n\n    insights = sorted(report.insights.values(), key=lambda insight: insight.total_count, reverse=True)\n    group_keys = ['known', 'alias', 'fuzzy', 'unknown']\n\n    totals_by_classification = {key: 0 for key in group_keys}\n    for insight in insights:\n        key = insight.classification if insight.classification in totals_by_classification else 'unknown'\n        if (\n            key == 'unknown'\n            and not include_known_products\n            and insight.matches_product\n        ):\n            continue\n        totals_by_classification[key] += 1\n\n    def matches_filters(insight):\n        if classification in group_keys and insight.classification != classification:\n            return False\n        if (\n            classification == 'unknown'\n            and not include_known_products\n            and insight.classification == 'unknown'\n            and insight.matches_product\n        ):\n            return False\n        if search_term:\n            haystack = [\n                insight.normalized,\n                insight.modifier_name or '',\n                insight.alias_label or '',\n            ]\n            haystack.extend(insight.raw_labels.keys())\n            haystack.extend(insight.items.keys())\n            return any(search_term in (token or '').lower() for token in haystack if token)\n        return True\n\n    filtered = [insight for insight in insights if matches_filters(insight)]\n\n    if export_format == 'csv':\n        fieldnames = [\n            'normalized',\n            'total_count',\n            'classification',\n            'modifier_id',\n            'modifier_name',\n            'modifier_behavior',\n            'alias_label',\n            'top_raw_labels',\n            'top_items',\n        ]\n        response = HttpResponse(content_type='text/csv')\n        response['Content-Disposition'] = 'attachment; filename=\"modifier_explorer.csv\"'\n        writer = csv.DictWriter(response, fieldnames=fieldnames)\n        writer.writeheader()\n        for insight in filtered:\n            writer.writerow(insight.to_csv_row())\n        return response\n\n    grouped = {key: [] for key in group_keys}\n    for insight in filtered:\n        key = insight.classification if insight.classification in grouped else 'unknown'\n        grouped[key].append(insight)\n\n    for bucket in grouped.values():\n        bucket.sort(key=lambda insight: insight.total_count, reverse=True)\n\n    co_occurrence_rows = [\n        {\n            'left': left,\n            'right': right,\n            'count': count,\n        }\n        for (left, right), count in sorted(\n            report.co_occurrence_pairs.items(),\n            key=lambda item: item[1],\n            reverse=True,\n        )[:25]\n    ]\n\n    recipe_modifiers = RecipeModifier.objects.order_by('name').only('id', 'name')\n\n    context = {\n        'classification': classification,\n        'search_term': search_term_raw,\n        'grouped': grouped,\n        'total_modifiers': len(filtered),\n        'total_available': len(insights),\n        'classification_totals': totals_by_classification,\n        'filtered_counts': {key: len(value) for key, value in grouped.items()},\n        'source_files': report.source_files,\n        'co_occurrence_rows': co_occurrence_rows,\n        'recipe_modifiers': recipe_modifiers,\n        'include_known_products': include_known_products,\n        'matched_unknown_product_count': matched_unknown_product_count,\n    }\n\n    return render(request, 'modifiers/explorer.html', context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.modifiers.modifier_rules_modal","title":"<code>modifier_rules_modal(request)</code>","text":"<p>Handle GET/POST traffic for the modal that edits modifier rules.</p> Source code in <code>mscrInventory/views/modifiers.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipemodifier\", raise_exception=True)\ndef modifier_rules_modal(request):\n    \"\"\"Handle GET/POST traffic for the modal that edits modifier rules.\"\"\"\n    if request.method == \"POST\":\n        modifier_id = request.POST.get(\"modifier_id\")\n        modifier = get_object_or_404(RecipeModifier, pk=modifier_id)\n\n        behavior = request.POST.get(\"behavior\") or modifier.behavior\n        quantity_factor_raw = request.POST.get(\"quantity_factor\")\n        by_type_raw = [value for value in request.POST.getlist(\"target_by_type\") if value]\n        by_type: list[int] = []\n        for raw in by_type_raw:\n            try:\n                by_type.append(int(raw))\n            except (TypeError, ValueError):\n                lookup = IngredientType.objects.filter(name__iexact=raw).values_list(\"id\", flat=True).first()\n                if lookup:\n                    by_type.append(int(lookup))\n        by_name = [value for value in request.POST.getlist(\"target_by_name\") if value]\n        replacement_names = request.POST.getlist(\"replacement_name\")\n        replacement_qtys = request.POST.getlist(\"replacement_qty\")\n        expands_to_ids = [int(pk) for pk in request.POST.getlist(\"expands_to\") if pk]\n\n        modifier.behavior = behavior\n\n        if quantity_factor_raw:\n            try:\n                modifier.quantity_factor = Decimal(quantity_factor_raw)\n            except (InvalidOperation, TypeError):\n                pass\n\n        modifier.target_selector = (\n            {\"by_type\": by_type, \"by_name\": by_name}\n            if (by_type or by_name)\n            else None\n        )\n\n        replacements = []\n        for name, qty in zip(replacement_names, replacement_qtys):\n            if not name:\n                continue\n            try:\n                qty_value = Decimal(qty)\n            except (InvalidOperation, TypeError):\n                qty_value = Decimal(\"1\")\n            replacements.append([name, float(qty_value)])\n\n        modifier.replaces = {\"to\": replacements} if replacements else None\n\n        modifier.save()\n        modifier.expands_to.set(expands_to_ids)\n\n        trigger = {\n            \"showMessage\": {\"text\": f\"Updated rules for {modifier.name}.\", \"level\": \"success\"}\n        }\n        return _render_modifier_modal(\n            request,\n            context_overrides={\"selected_modifier_id\": modifier.id},\n            trigger=trigger,\n        )\n\n    return _render_modifier_modal(request)\n</code></pre>"},{"location":"16_API/views/#inventory-and-ingredients","title":"Inventory and ingredients","text":"<p>Views and helpers for working with inventory dashboards and HTMX modals.</p> <p>Ingredient CRUD flow views, CSV import/export, and HTMX helpers.</p>"},{"location":"16_API/views/#mscrInventory.views.inventory.add_case","title":"<code>add_case(request, pk)</code>","text":"<p>Adds one case to stock using case_size and average_cost_per_unit.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef add_case(request, pk):\n    \"\"\"Adds one case to stock using case_size and average_cost_per_unit.\"\"\"\n    ing = Ingredient.objects.get(pk=pk)\n    if not ing.case_size:\n        return JsonResponse({\"error\": \"No case size defined.\"}, status=400)\n    StockEntry.objects.create(\n        ingredient=ing,\n        quantity_added=ing.case_size,\n        cost_per_unit=ing.average_cost_per_unit,\n        source=\"manual\",\n        note=\"Added case from dashboard\",\n    )\n    ing.refresh_from_db()\n    return render(request, \"inventory/_ingredient_row.html\", {\"i\": ing})\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.bulk_add_modal","title":"<code>bulk_add_modal(request)</code>","text":"<p>Render the bulk stock modal.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef bulk_add_modal(request):\n    \"\"\"Render the bulk stock modal.\"\"\"\n    all_ingredients = Ingredient.objects.select_related(\"type\", \"unit_type\").order_by(\"type__name\", \"name\")\n    unit_types = UnitType.objects.order_by(\"name\")\n    return render(\n        request,\n        \"inventory/_bulk_add_modal.html\",\n        {\"all_ingredients\": all_ingredients, \"unit_types\": unit_types},\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.bulk_add_stock","title":"<code>bulk_add_stock(request)</code>","text":"<p>Create multiple StockEntry records and refresh dashboard via HTMX triggers.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef bulk_add_stock(request):\n    \"\"\"Create multiple StockEntry records and refresh dashboard via HTMX triggers.\"\"\"\n    data = request.POST\n\n    reason = data.get(\"reason\") or \"Bulk Add\"\n    note = data.get(\"note\") or \"Added via bulk add modal\"\n    # Use Row* lists if present; otherwise fall back to Modal*\n    qty_list = data.getlist(\"Rowquantity_added\") or data.getlist(\"Modalquantity_added\")\n    cost_list = data.getlist(\"Rowcost_per_unit\") or data.getlist(\"Modalcost_per_unit\")\n    case_list = data.getlist(\"Rowcase_size\") or data.getlist(\"Modalcase_size\")\n    lead_list = data.getlist(\"Rowlead_time\") or data.getlist(\"Modallead_time\")\n    reorder_list = data.getlist(\"Rowreorder_point\") or []\n    unit_list = data.getlist(\"Rowunit_type\") or data.getlist(\"Modalunit_type\")\n\n    # Clean empty strings\n    ingredients = [i for i in data.getlist(\"ingredient\") if i.strip()]\n\n    items = zip_longest(\n        ingredients,\n        qty_list,\n        cost_list,\n        case_list,\n        lead_list,\n        reorder_list,\n        unit_list,\n        fillvalue=None,\n    )\n\n    created = 0\n\n    with transaction.atomic():\n        for ing_id, qty, cost, case, lead, reorder, unit in items:\n            if not ing_id or qty in (None, \"\", \" \"):\n                continue\n\n            try:\n                ing = Ingredient.objects.get(pk=ing_id)\n                qty_val = Decimal(str(qty).strip())\n                cost_val = Decimal(str(cost or \"0\").strip())\n            except (Ingredient.DoesNotExist, InvalidOperation):\n                continue\n\n            qty_val, cost_val = _convert_to_ingredient_units(\n                qty_val, cost_val, ing, _clean_int(unit)\n            )\n\n            # \u2705 Create the StockEntry (allow negatives)\n            StockEntry.objects.create(\n                ingredient=ing,\n                quantity_added=qty_val,\n                cost_per_unit=cost_val,\n                source=reason.lower(),\n                note=note,\n            )\n\n            ing.refresh_from_db()\n\n            case_value = _clean_int(case)\n            lead_value = _clean_int(lead)\n            reorder_value = _clean_decimal(reorder)\n\n            update_fields = [\"last_updated\"]\n            if case_value is not None:\n                ing.case_size = case_value\n                update_fields.append(\"case_size\")\n            if lead_value is not None:\n                ing.lead_time = lead_value\n                update_fields.append(\"lead_time\")\n            if reorder_value is not None:\n                ing.reorder_point = reorder_value\n                update_fields.append(\"reorder_point\")\n\n            ing.save(update_fields=update_fields)\n\n            created += 1\n\n        # \u2705 Use HX-Trigger to refresh tables and show a message (no modal re-render)\n        response = JsonResponse({\"status\": \"success\"})\n        response[\"HX-Trigger\"] = json.dumps({\n            \"inventory:refresh\": True,\n            \"showMessage\": {\n                \"text\": (\n                    f\"\u2705 {created} stock entries added successfully!\"\n                    if created else \"\u26a0\ufe0f No valid stock entries were added.\"\n                ),\n                \"level\": \"success\" if created else \"warning\",\n            }\n        })\n        return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.confirm_inventory_import","title":"<code>confirm_inventory_import(request)</code>","text":"<p>Apply validated import rows via bulk_add_stock().</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef confirm_inventory_import(request):\n    \"\"\"Apply validated import rows via bulk_add_stock().\"\"\"\n    try:\n        payload = json.loads(request.body)\n    except json.JSONDecodeError:\n        return JsonResponse({\"status\": \"error\", \"message\": \"Invalid JSON payload.\"}, status=400)\n\n    # Build a QueryDict to mimic a POST and keep row values aligned for bulk_add_stock()\n    qd = QueryDict(mutable=True)\n    for r in payload:\n        qd.appendlist(\"ingredient\", str(r[\"ingredient\"]))\n        qd.appendlist(\"Rowquantity_added\", str(r[\"quantity_added\"]))\n        qd.appendlist(\"Rowcost_per_unit\", str(r.get(\"cost_per_unit\") or 0))\n        qd.appendlist(\"Rowcase_size\", str(r.get(\"case_size\") or \"\"))\n        qd.appendlist(\"Rowlead_time\", str(r.get(\"lead_time\") or \"\"))\n        qd.appendlist(\"Rowreorder_point\", str(r.get(\"reorder_point\") or \"\"))\n\n    request.POST = qd\n    return bulk_add_stock(request)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.download_inventory_csv_template","title":"<code>download_inventory_csv_template(request)</code>","text":"<p>Generate and download a blank CSV template with required headers.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef download_inventory_csv_template(request):\n    \"\"\"Generate and download a blank CSV template with required headers.\"\"\"\n\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"inventory_import_template.csv\"'\n    writer = csv.writer(response)\n    writer.writerow(REQUIRED_HEADERS)\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.export_inventory_csv","title":"<code>export_inventory_csv(request)</code>","text":"<p>Download a point-in-time snapshot of all Ingredients. File: inventory_snapshot.csv Columns are intentionally simple and stable for round-tripping.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef export_inventory_csv(request):\n    \"\"\"\n    Download a point-in-time snapshot of all Ingredients.\n    File: inventory_snapshot.csv\n    Columns are intentionally simple and stable for round-tripping.\n    \"\"\"\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = f'attachment; filename=inventory_snapshot_{timezone.now():%Y%m%d_%H%M}.csv'\n    writer = csv.writer(response)\n    writer.writerow(REQUIRED_HEADERS)\n\n    last_quantity_subquery = (\n        StockEntry.objects.filter(ingredient=OuterRef(\"pk\"))\n        .order_by(\"-date_received\")\n        .values(\"quantity_added\")[:1]\n    )\n\n    qs = (\n        Ingredient.objects.select_related(\"type\")\n        .annotate(last_quantity_added=Subquery(last_quantity_subquery))\n        .order_by(\"name\")\n    )\n    for i in qs:\n        writer.writerow([\n            i.id,\n            i.name,\n            getattr(i.type, \"name\", \"\"),\n            i.last_quantity_added if i.last_quantity_added is not None else 0,\n            i.current_stock,\n            i.case_size,\n            i.reorder_point,\n            i.average_cost_per_unit,\n            i.lead_time,\n        ])\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.import_inventory_csv","title":"<code>import_inventory_csv(request)</code>","text":"<p>Validate a CSV upload and split rows into valid/invalid lists.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef import_inventory_csv(request):\n    \"\"\"Validate a CSV upload and split rows into valid/invalid lists.\"\"\"\n    csv_file = request.FILES.get(\"file\")\n    if not csv_file:\n        return render(\n            request,\n            \"inventory/_import_inventory.html\",\n            {\n                \"error\": \"\u26a0\ufe0f No file selected.\",\n                \"stage\": \"upload\",\n                \"required_headers\": REQUIRED_HEADERS,\n            },\n        )\n\n    import io, csv\n    decoded = csv_file.read().decode(\"utf-8\")\n    reader = csv.DictReader(io.StringIO(decoded))\n\n    valid_rows, invalid_rows = [], []\n\n    for line_no, row in enumerate(reader, start=2):\n        row_errors = []\n        try:\n            ing = Ingredient.objects.get(pk=int(row.get(\"id\")))\n        except (Ingredient.DoesNotExist, ValueError, TypeError):\n            row_errors.append(\"Invalid Ingredient ID.\")\n            invalid_rows.append({**row, \"line\": line_no, \"error\": \"; \".join(row_errors)})\n            continue\n\n        # Parse quantity_added and current_stock\n        qty_added = row.get(\"quantity_added\")\n        current_stock_csv = row.get(\"current_stock\")\n\n        try:\n            qty_added = Decimal(qty_added) if qty_added not in (None, \"\", \" \") else None\n        except InvalidOperation:\n            qty_added = None\n            row_errors.append(\"quantity_added not numeric.\")\n\n        try:\n            current_stock_csv = Decimal(current_stock_csv) if current_stock_csv not in (None, \"\", \" \") else None\n        except InvalidOperation:\n            current_stock_csv = None\n            row_errors.append(\"current_stock not numeric.\")\n\n        cost_raw = row.get(\"average_cost_per_unit\")\n        try:\n            cost_per_unit = (\n                Decimal(str(cost_raw).strip())\n                if cost_raw not in (None, \"\", \" \")\n                else Decimal(\"0\")\n            )\n        except (InvalidOperation, AttributeError):\n            cost_per_unit = None\n            row_errors.append(\"average_cost_per_unit not numeric.\")\n\n        # Derive delta if no explicit quantity_added\n        if qty_added is None and current_stock_csv is not None:\n            delta = current_stock_csv - (ing.current_stock or Decimal(0))\n            if delta &gt; 0:\n                qty_added = delta\n            else:\n                row_errors.append(\"No stock increase detected.\")\n\n        if qty_added is None or \"\":\n            row_errors.append(\"Quantity must be positive or computable delta.\")\n\n        if row_errors:\n            invalid_rows.append({**row, \"line\": line_no, \"error\": \"; \".join(row_errors)})\n            continue\n\n        # Build valid entry\n        current_stock_display = (\n            str(current_stock_csv)\n            if current_stock_csv is not None\n            else (row.get(\"current_stock\") or \"\")\n        )\n        valid_rows.append({\n            \"ingredient\": ing.id,\n            \"name\": ing.name,\n            \"quantity_added\": str(qty_added),\n            \"current_stock\": current_stock_display,\n            \"cost_per_unit\": str(cost_per_unit) if cost_per_unit is not None else \"0\",\n            \"case_size\": row.get(\"case_size\") or \"\",\n            \"lead_time\": row.get(\"lead_time\") or \"\",\n            \"reorder_point\": row.get(\"reorder_point\") or \"\",\n        })\n\n    return render(request, \"inventory/_import_inventory.html\", {\n        \"valid_rows\": valid_rows,\n        \"invalid_rows\": invalid_rows,\n        \"valid_count\": len(valid_rows),\n        \"invalid_count\": len(invalid_rows),\n        \"required_headers\": REQUIRED_HEADERS,\n    })\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.import_inventory_modal","title":"<code>import_inventory_modal(request)</code>","text":"<p>Render the initial upload form for the inventory importer modal.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef import_inventory_modal(request):\n    \"\"\"Render the initial upload form for the inventory importer modal.\"\"\"\n    return render(\n        request,\n        \"inventory/_import_inventory.html\",\n        {\n            \"stage\": \"upload\",\n            \"required_headers\": REQUIRED_HEADERS,\n        },\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.ingredient_details","title":"<code>ingredient_details(request, pk)</code>","text":"<p>Return JSON with current stock data for the selected ingredient.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>def ingredient_details(request, pk):\n    \"\"\"Return JSON with current stock data for the selected ingredient.\"\"\"\n    ing = Ingredient.objects.filter(pk=pk).select_related(\"type\", \"unit_type\").first()\n    if not ing:\n        return JsonResponse({\"error\": \"Ingredient not found\"}, status=404)\n\n    data = {\n        \"case_size\": ing.case_size or 0,\n        \"lead_time\": ing.lead_time or 0,\n        \"average_cost_per_unit\": str(ing.average_cost_per_unit or \"\"),\n        #\"unit_type\": ing.unit_type.name if ing.unit_type else \"\",\n    }\n    return JsonResponse(data)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.inventory_all_ingredients_partial","title":"<code>inventory_all_ingredients_partial(request)</code>","text":"<p>Return the all-ingredients table partial.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>def inventory_all_ingredients_partial(request):\n    \"\"\"Return the all-ingredients table partial.\"\"\"\n    qs = _inventory_queryset().select_related(\"type\")\n    type_id = request.GET.get(\"type\")\n    search = request.GET.get(\"q\")\n\n    if type_id:\n        qs = qs.filter(type_id=type_id)\n    if search:\n        qs = qs.filter(name__icontains=search)\n\n    sort_map = {\n        \"name\": \"name\",\n        \"category\": \"type__name\",\n        \"current_stock\": \"current_stock\",\n        \"case_size\": \"case_size\",\n        \"reorder_point\": \"reorder_point\",\n        \"avg_cost\": \"average_cost_per_unit\",\n    }\n\n    sort_key = request.GET.get(\"sort\", \"name\")\n    if sort_key not in sort_map:\n        sort_key = \"name\"\n\n    direction = request.GET.get(\"direction\", \"asc\").lower()\n    if direction not in {\"asc\", \"desc\"}:\n        direction = \"asc\"\n\n    order_expr = sort_map[sort_key]\n    if direction == \"desc\":\n        order_expr = f\"-{order_expr}\"\n\n    qs = qs.order_by(order_expr, \"name\")\n\n    toggle_directions, sort_indicators = _build_sort_context(sort_key, direction, sort_map=sort_map)\n\n    context = {\n        \"all_ingredients\": qs,\n        \"current_sort\": sort_key,\n        \"current_direction\": direction,\n        \"toggle_directions\": toggle_directions,\n        \"sort_indicators\": sort_indicators,\n        \"search_query\": search or \"\",\n        \"active_type\": type_id or \"\",\n    }\n\n    return render(request, \"inventory/_all_ingredients.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.inventory_dashboard_view","title":"<code>inventory_dashboard_view(request)</code>","text":"<p>Display inventory with low stock, totals, and editable table.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef inventory_dashboard_view(request):\n    \"\"\"Display inventory with low stock, totals, and editable table.\"\"\"\n    base_qs = _inventory_queryset()\n\n    low_stock_ingredients = base_qs.filter(current_stock__lte=F(\"reorder_point\")).order_by(\"name\")\n    all_ingredients_qs = (\n        base_qs.select_related(\"type\", \"unit_type\")\n        .order_by(\"name\")\n    )\n\n    sort_map = {\n        \"name\": \"name\",\n        \"category\": \"type__name\",\n        \"current_stock\": \"current_stock\",\n        \"case_size\": \"case_size\",\n        \"reorder_point\": \"reorder_point\",\n        \"avg_cost\": \"average_cost_per_unit\",\n    }\n    toggle_directions, sort_indicators = _build_sort_context(\"name\", \"asc\", sort_map=sort_map)\n\n    total_ingredients = all_ingredients_qs.count()\n    total_low_stock = low_stock_ingredients.count()\n    total_cost = (\n        base_qs.aggregate(\n            total=Sum(F(\"current_stock\") * F(\"average_cost_per_unit\"))\n        )[\"total\"]\n        or 0\n    )\n    ingredient_types = IngredientType.objects.exclude(name__iexact=\"extra\").order_by(\"name\")\n    unresolved_count = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).count()\n\n    context = {\n        \"total_ingredients\": total_ingredients,\n        \"total_low_stock\": total_low_stock,\n        \"total_cost\": total_cost,\n        \"low_stock_ingredients\": low_stock_ingredients,\n        \"all_ingredients\": all_ingredients_qs,\n        \"current_sort\": \"name\",\n        \"current_direction\": \"asc\",\n        \"toggle_directions\": toggle_directions,\n        \"sort_indicators\": sort_indicators,\n        \"search_query\": \"\",\n        \"active_type\": \"\",\n        \"ingredient_types\": ingredient_types,\n        \"unresolved_count\": unresolved_count,\n    }\n    return render(request, \"inventory/dashboard.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.inventory_low_stock_partial","title":"<code>inventory_low_stock_partial(request)</code>","text":"<p>Return the low-stock table partial.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>def inventory_low_stock_partial(request):\n    \"\"\"Return the low-stock table partial.\"\"\"\n    low_stock_ingredients = (\n        _inventory_queryset()\n        .filter(current_stock__lte=F(\"reorder_point\"))\n        .order_by(\"name\")\n    )\n    return render(request, \"inventory/_low_stock.html\", {\"low_stock_ingredients\": low_stock_ingredients})\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.inventory.update_ingredient","title":"<code>update_ingredient(request, pk)</code>","text":"<p>Inline update for ingredient fields.</p> Source code in <code>mscrInventory/views/inventory.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef update_ingredient(request, pk):\n    \"\"\"Inline update for ingredient fields.\"\"\"\n    ing = Ingredient.objects.get(pk=pk)\n    fields = [\"current_stock\", \"case_size\", \"reorder_point\", \"average_cost_per_unit\"]\n    for f in fields:\n        if f in request.POST:\n            val = request.POST.get(f)\n            if val not in (\"\", None):\n                setattr(ing, f, val)\n    ing.save(update_fields=fields + [\"last_updated\"])\n    return render(request, \"inventory/_ingredient_row.html\", {\"i\": ing})\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.confirm_ingredients_import","title":"<code>confirm_ingredients_import(request)</code>","text":"<p>Persist validated ingredient rows from the preview.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef confirm_ingredients_import(request):\n    \"\"\"Persist validated ingredient rows from the preview.\"\"\"\n\n    payload = request.POST.get(\"valid_rows\") or request.body.decode(\"utf-8\")\n    try:\n        rows = json.loads(payload)\n        if isinstance(rows, str):\n            rows = json.loads(rows)\n    except Exception as exc:  # pragma: no cover - defensive\n        return JsonResponse({\"status\": \"error\", \"message\": str(exc)}, status=400)\n\n    created, updated = 0, 0\n\n    with transaction.atomic():\n        for row in rows:\n            ingredient = None\n            if row.get(\"id\"):\n                ingredient = Ingredient.objects.filter(pk=row[\"id\"]).first()\n\n            if ingredient is None:\n                ingredient, created_flag = Ingredient.objects.get_or_create(name=row[\"name\"].strip())\n                created += int(created_flag)\n            else:\n                updated += 1\n\n            type_obj = None\n            if row.get(\"type_id\"):\n                type_obj = IngredientType.objects.filter(pk=row[\"type_id\"]).first()\n            elif row.get(\"type_name\"):\n                type_obj = IngredientType.objects.filter(name__iexact=row[\"type_name\"].strip()).first()\n\n            unit_type_obj = None\n            if row.get(\"unit_type_id\"):\n                unit_type_obj = UnitType.objects.filter(pk=row[\"unit_type_id\"]).first()\n            elif row.get(\"unit_type_name\"):\n                unit_type_obj = UnitType.objects.filter(name__iexact=row[\"unit_type_name\"].strip()).first()\n\n            ingredient.type = type_obj\n            ingredient.unit_type = unit_type_obj\n\n            if row.get(\"case_size\") not in (\"\", None):\n                ingredient.case_size = int(row[\"case_size\"])\n            if row.get(\"reorder_point\") not in (\"\", None):\n                ingredient.reorder_point = Decimal(str(row[\"reorder_point\"]))\n            if row.get(\"average_cost_per_unit\") not in (\"\", None):\n                ingredient.average_cost_per_unit = Decimal(str(row[\"average_cost_per_unit\"]))\n            if row.get(\"lead_time\") not in (\"\", None):\n                ingredient.lead_time = int(row[\"lead_time\"])\n            ingredient.notes = row.get(\"notes\") or \"\"\n            ingredient.save()\n\n    response = JsonResponse({\"status\": \"success\"})\n    response[\"HX-Trigger\"] = json.dumps(\n        {\n            \"ingredient:refresh\": True,\n            \"showMessage\": {\n                \"text\": f\"\u2705 {created} created, {updated} updated from CSV.\",\n                \"level\": \"success\",\n            },\n        }\n    )\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.download_ingredients_template","title":"<code>download_ingredients_template(request)</code>","text":"<p>Download a clean CSV template matching the ingredient importer headers.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef download_ingredients_template(request):\n    \"\"\"Download a clean CSV template matching the ingredient importer headers.\"\"\"\n\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"ingredients_template.csv\"'\n    writer = csv.writer(response)\n    writer.writerow(INGREDIENT_IMPORT_HEADERS)\n    writer.writerow([\"\", \"New Ingredient\", \"\", \"Beans\", \"\", \"Ounce\", \"12\", \"2.5\", \"1.2500\", \"7\", \"Optional notes\"])\n    writer.writerow([\"101\", \"Existing Milk\", \"3\", \"Dairy\", \"1\", \"Fluid Ounce\", \"24\", \"1.0\", \"0.7500\", \"3\", \"Leave id to update\"])\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.export_ingredients_csv","title":"<code>export_ingredients_csv(request)</code>","text":"<p>Export ingredient details in a round-trippable CSV.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef export_ingredients_csv(request):\n    \"\"\"Export ingredient details in a round-trippable CSV.\"\"\"\n\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = (\n        f'attachment; filename=\"ingredients_export_{timezone.now():%Y%m%d_%H%M}.csv\"'\n    )\n    writer = csv.writer(response)\n    writer.writerow(INGREDIENT_IMPORT_HEADERS)\n\n    queryset = Ingredient.objects.select_related(\"type\", \"unit_type\").order_by(\"name\")\n    for ing in queryset:\n        writer.writerow(\n            [\n                ing.id,\n                ing.name,\n                getattr(ing.type, \"id\", \"\"),\n                getattr(ing.type, \"name\", \"\"),\n                getattr(ing.unit_type, \"id\", \"\"),\n                getattr(ing.unit_type, \"name\", \"\"),\n                ing.case_size or \"\",\n                ing.reorder_point or \"\",\n                ing.average_cost_per_unit or \"\",\n                ing.lead_time or \"\",\n                (ing.notes or \"\").replace(\"\\n\", \" \").strip(),\n            ]\n        )\n\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.import_ingredients_csv","title":"<code>import_ingredients_csv(request)</code>","text":"<p>Validate uploaded ingredient CSV rows and render a preview.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\n@require_POST\ndef import_ingredients_csv(request):\n    \"\"\"Validate uploaded ingredient CSV rows and render a preview.\"\"\"\n\n    csv_file = request.FILES.get(\"file\")\n    if not csv_file:\n        messages.error(request, \"\u26a0\ufe0f No file uploaded.\")\n        return import_ingredients_modal(request)\n\n    decoded = csv_file.read().decode(\"utf-8\")\n    reader = csv.DictReader(io.StringIO(decoded))\n\n    valid_rows: list[dict[str, str | int | None]] = []\n    invalid_rows: list[dict[str, str]] = []\n\n    for line_no, row in enumerate(reader, start=2):\n        errors: list[str] = []\n\n        ing_id_raw = (row.get(\"id\") or \"\").strip()\n        name = (row.get(\"name\") or \"\").strip()\n        type_id = _parse_int(row.get(\"type_id\"), \"type_id\", errors)\n        unit_type_id = _parse_int(row.get(\"unit_type_id\"), \"unit_type_id\", errors)\n        case_size = _parse_int(row.get(\"case_size\"), \"case_size\", errors)\n        reorder_point = _parse_decimal(row.get(\"reorder_point\"), \"reorder_point\", errors)\n        average_cost = _parse_decimal(\n            row.get(\"average_cost_per_unit\"), \"average_cost_per_unit\", errors\n        )\n        lead_time = _parse_int(row.get(\"lead_time\"), \"lead_time\", errors)\n        notes = (row.get(\"notes\") or \"\").strip()\n\n        if not name:\n            errors.append(\"Name is required.\")\n\n        ingredient = None\n        if ing_id_raw:\n            try:\n                ingredient = Ingredient.objects.get(pk=int(ing_id_raw))\n            except (Ingredient.DoesNotExist, ValueError):\n                errors.append(\"Ingredient id not found.\")\n\n        if ingredient is None and name:\n            ingredient = Ingredient.objects.filter(name__iexact=name).first()\n\n        type_obj = None\n        if type_id is not None:\n            type_obj = IngredientType.objects.filter(pk=type_id).first()\n            if type_obj is None:\n                errors.append(\"type_id not found.\")\n        elif row.get(\"type_name\"):\n            type_obj = IngredientType.objects.filter(name__iexact=row[\"type_name\"].strip()).first()\n            if type_obj is None:\n                errors.append(\"type_name not recognized.\")\n\n        unit_type_obj = None\n        if unit_type_id is not None:\n            unit_type_obj = UnitType.objects.filter(pk=unit_type_id).first()\n            if unit_type_obj is None:\n                errors.append(\"unit_type_id not found.\")\n        elif row.get(\"unit_type_name\"):\n            unit_type_obj = UnitType.objects.filter(name__iexact=row[\"unit_type_name\"].strip()).first()\n            if unit_type_obj is None:\n                errors.append(\"unit_type_name not recognized.\")\n\n        if errors:\n            invalid_rows.append({**row, \"line\": line_no, \"error\": \"; \".join(errors)})\n            continue\n\n        operation = \"update\" if ingredient else \"create\"\n\n        valid_rows.append(\n            {\n                \"id\": ingredient.id if ingredient else None,\n                \"name\": name,\n                \"type_id\": type_obj.id if type_obj else None,\n                \"type_name\": type_obj.name if type_obj else (row.get(\"type_name\") or \"\"),\n                \"unit_type_id\": unit_type_obj.id if unit_type_obj else None,\n                \"unit_type_name\": unit_type_obj.name if unit_type_obj else (row.get(\"unit_type_name\") or \"\"),\n                \"case_size\": case_size if case_size is not None else \"\",\n                \"reorder_point\": str(reorder_point) if reorder_point is not None else \"\",\n                \"average_cost_per_unit\": str(average_cost) if average_cost is not None else \"\",\n                \"lead_time\": lead_time if lead_time is not None else \"\",\n                \"notes\": notes,\n                \"operation\": operation,\n            }\n        )\n\n    context = {\n        \"valid_rows\": valid_rows,\n        \"invalid_rows\": invalid_rows,\n        \"count_valid\": len(valid_rows),\n        \"count_invalid\": len(invalid_rows),\n        \"collapse_valid\": len(valid_rows) &gt; 50,\n        \"valid_rows_json\": json.dumps(valid_rows),\n        \"required_headers\": INGREDIENT_IMPORT_HEADERS,\n    }\n\n    return render(request, \"ingredients/_import_ingredients_preview.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.import_ingredients_modal","title":"<code>import_ingredients_modal(request)</code>","text":"<p>Render the upload modal for ingredient CSV imports.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef import_ingredients_modal(request):\n    \"\"\"Render the upload modal for ingredient CSV imports.\"\"\"\n\n    return render(\n        request,\n        \"ingredients/_import_ingredients.html\",\n        {\"required_headers\": INGREDIENT_IMPORT_HEADERS},\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.ingredient_create_modal","title":"<code>ingredient_create_modal(request)</code>","text":"<p>Handle the create modal submission for a new ingredient.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef ingredient_create_modal(request):\n    \"\"\"Handle the create modal submission for a new ingredient.\"\"\"\n    return _render_ingredient_modal(\n        request,\n        ingredient=None,\n        title=\"Create Ingredient\",\n        submit_label=\"Create\",\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.ingredient_edit_modal","title":"<code>ingredient_edit_modal(request, pk)</code>","text":"<p>Handle modal updates for an existing ingredient.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.change_ingredient\", raise_exception=True)\ndef ingredient_edit_modal(request, pk: int):\n    \"\"\"Handle modal updates for an existing ingredient.\"\"\"\n    ingredient = get_object_or_404(Ingredient, pk=pk)\n    return _render_ingredient_modal(\n        request,\n        ingredient=ingredient,\n        title=f\"Edit {ingredient.name}\",\n        submit_label=\"Save Changes\",\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.ingredients_dashboard_view","title":"<code>ingredients_dashboard_view(request)</code>","text":"<p>Render the ingredient dashboard or its HTMX table as needed.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef ingredients_dashboard_view(request):\n    \"\"\"Render the ingredient dashboard or its HTMX table as needed.\"\"\"\n    ingredient_types = IngredientType.objects.exclude(name__iexact=\"extra\").order_by(\"name\")\n    unresolved_count = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).count()\n\n    context = {\n        \"ingredient_types\": ingredient_types,\n        \"search_query\": request.GET.get(\"q\", \"\").strip(),\n        \"active_type\": request.GET.get(\"type\", \"\").strip(),\n        \"unresolved_count\": unresolved_count,\n    }\n\n    if request.headers.get(\"HX-Request\"):\n        return ingredients_table_partial(request)\n\n    return render(request, \"ingredients/dashboard.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.ingredients.ingredients_table_partial","title":"<code>ingredients_table_partial(request)</code>","text":"<p>Return the sortable table partial for the ingredient dashboard.</p> Source code in <code>mscrInventory/views/ingredients.py</code> <pre><code>@permission_required(\"mscrInventory.view_ingredient\", raise_exception=True)\ndef ingredients_table_partial(request):\n    \"\"\"Return the sortable table partial for the ingredient dashboard.\"\"\"\n    search_query = request.GET.get(\"q\", \"\").strip()\n    active_type = request.GET.get(\"type\", \"\").strip()\n    sort_key = request.GET.get(\"sort\", \"name\")\n    direction = request.GET.get(\"direction\", \"asc\")\n\n    sort_map = {\n        \"name\": \"name\",\n        \"category\": \"type__name\",\n        \"current_stock\": \"current_stock\",\n        \"case_size\": \"case_size\",\n        \"reorder_point\": \"reorder_point\",\n        \"avg_cost\": \"average_cost_per_unit\",\n    }\n\n    if sort_key not in sort_map:\n        sort_key = \"name\"\n    if direction not in {\"asc\", \"desc\"}:\n        direction = \"asc\"\n\n    order_by = sort_map[sort_key]\n    if direction == \"desc\":\n        order_by = f\"-{order_by}\"\n\n    qs = _inventory_queryset().select_related(\"type\", \"unit_type\")\n\n    if active_type:\n        if active_type.isdigit():\n            qs = qs.filter(type_id=int(active_type))\n        else:\n            qs = qs.filter(type__name__iexact=active_type)\n\n    if search_query:\n        qs = qs.filter(Q(name__icontains=search_query) | Q(type__name__icontains=search_query))\n\n    qs = qs.order_by(order_by)\n\n    toggle_directions, sort_indicators = _build_sort_context(sort_key, direction, sort_map=sort_map)\n\n    context = {\n        \"all_ingredients\": qs,\n        \"toggle_directions\": toggle_directions,\n        \"sort_indicators\": sort_indicators,\n        \"search_query\": search_query,\n        \"active_type\": active_type,\n    }\n\n    return TemplateResponse(request, \"ingredients/_table.html\", context)\n</code></pre>"},{"location":"16_API/views/#orders-and-recipes","title":"Orders and recipes","text":"<p>Orders dashboard filters and helper utilities.</p> <p>Recipes dashboard, modal helpers, and CSV import/export endpoints.</p>"},{"location":"16_API/views/#mscrInventory.views.orders.DateRange","title":"<code>DateRange(start, end, start_date, end_date)</code>  <code>dataclass</code>","text":"<p>Resolved date range plus original dates for UI.</p>"},{"location":"16_API/views/#mscrInventory.views.orders.orders_dashboard_view","title":"<code>orders_dashboard_view(request)</code>","text":"<p>Display imported orders with filtering, sorting, and pagination.</p> Source code in <code>mscrInventory/views/orders.py</code> <pre><code>@login_required\ndef orders_dashboard_view(request: HttpRequest) -&gt; HttpResponse:\n    \"\"\"Display imported orders with filtering, sorting, and pagination.\"\"\"\n    preset = request.GET.get(\"preset\", \"14\")\n    platform = request.GET.get(\"platform\", \"all\")\n    search_term = request.GET.get(\"q\", \"\").strip()\n    sort_param = request.GET.get(\"sort\", \"order_date\")\n    direction = request.GET.get(\"direction\", \"desc\").lower()\n    date_range = _resolve_date_range(preset, request.GET.get(\"start\"), request.GET.get(\"end\"))\n\n    orders_qs = (\n        Order.objects.filter(order_date__range=(date_range.start, date_range.end))\n        .prefetch_related(\"items\", \"items__product\")\n    )\n    if platform and platform.lower() != \"all\":\n        orders_qs = orders_qs.filter(platform__iexact=platform)\n\n    if search_term:\n        search_filters = (\n            Q(order_id__icontains=search_term)\n            | Q(items__product__name__icontains=search_term)\n            | Q(items__variant_info__icontains=search_term)\n        )\n        try:\n            decimal_value = Decimal(search_term)\n        except (InvalidOperation, TypeError):\n            decimal_value = None\n        if decimal_value is not None:\n            search_filters |= Q(total_amount=decimal_value)\n        orders_qs = orders_qs.filter(search_filters)\n\n    orders_qs = orders_qs.annotate(total_items=Coalesce(Sum(\"items__quantity\"), 0))\n\n    sort_field = _SORT_OPTIONS.get(sort_param, \"order_date\")\n    if direction not in {\"asc\", \"desc\"}:\n        direction = \"desc\"\n    sort_prefix = \"-\" if direction == \"desc\" else \"\"\n    orders_qs = orders_qs.order_by(f\"{sort_prefix}{sort_field}\")\n\n    paginator = Paginator(orders_qs, 25)\n    page_number = request.GET.get(\"page\")\n    page_obj = paginator.get_page(page_number)\n\n    preserved_params = request.GET.copy()\n    preserved_params.pop(\"page\", None)\n    querystring = urlencode({k: v for k, v in preserved_params.items() if v})\n\n    context = {\n        \"page_obj\": page_obj,\n        \"orders\": page_obj.object_list,\n        \"selected_preset\": preset if preset in _PRESET_WINDOWS or preset == \"custom\" else \"14\",\n        \"selected_platform\": platform.lower() if platform else \"all\",\n        \"search_term\": search_term,\n        \"sort\": sort_param if sort_param in _SORT_OPTIONS else \"order_date\",\n        \"direction\": direction,\n        \"start_date\": date_range.start_date,\n        \"end_date\": date_range.end_date,\n        \"show_custom_range\": preset == \"custom\",\n        \"querystring\": f\"&amp;{querystring}\" if querystring else \"\",\n        \"preset_options\": [\n            (\"7\", \"Last 7 days\"),\n            (\"14\", \"Last 14 days\"),\n            (\"30\", \"Last 30 days\"),\n            (\"90\", \"Last 90 days\"),\n            (\"custom\", \"Custom\"),\n        ],\n        \"platform_options\": [\n            (\"all\", \"All Platforms\"),\n            (\"shopify\", \"Shopify\"),\n            (\"square\", \"Square\"),\n        ],\n    }\n    return render(request, \"orders/dashboard.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.add_recipe_ingredient","title":"<code>add_recipe_ingredient(request, pk)</code>","text":"<p>Adds a new ingredient to a recipe (via HTMX inline form).</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_http_methods([\"POST\"])\n@transaction.atomic\ndef add_recipe_ingredient(request, pk):\n    \"\"\"\n    Adds a new ingredient to a recipe (via HTMX inline form).\n    \"\"\"\n    product = get_object_or_404(Product, pk=pk)\n    try:\n        ingredient_id = request.POST.get(\"ingredient_id\")\n        quantity = request.POST.get(\"quantity\")\n        unit = request.POST.get(\"unit\") or \"unit\"\n\n        if not ingredient_id or not quantity:\n            return JsonResponse({\"error\": \"Missing ingredient or quantity\"}, status=400)\n\n        ingredient = get_object_or_404(Ingredient, pk=ingredient_id)\n\n        item = RecipeItem.objects.create(\n            product=product,\n            ingredient=ingredient,\n            quantity=Decimal(quantity),\n            unit=unit,\n        )\n\n        # Return rendered row so HTMX can insert it immediately\n        ctx = {\"item\": item, \"product\": product}\n        html = render_to_string(\"recipes/_edit_ingredient_row.html\", ctx, request=request)\n        return HttpResponse(html)\n\n    except Exception:  # pragma: no cover - defensive catch for HTMX response\n        logger.exception(\"Failed to add ingredient to recipe %s\", product.pk)\n        return JsonResponse({\"error\": \"Unable to add ingredient right now.\"}, status=400)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.confirm_recipes_import","title":"<code>confirm_recipes_import(request)</code>","text":"<p>Write validated CSV rows into RecipeItems.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_POST\ndef confirm_recipes_import(request):\n    \"\"\"Write validated CSV rows into RecipeItems.\"\"\"\n    data_json = request.POST.get(\"valid_rows\") or request.body.decode(\"utf-8\")\n\n    try:\n        # Some browsers double-encode JSON through hx-vals\n        rows = json.loads(data_json)\n        # If it\u2019s a string again (nested JSON), decode one more level\n        if isinstance(rows, str):\n            rows = json.loads(rows)\n    except Exception as e:\n        return JsonResponse(\n            {\"status\": \"error\", \"message\": f\"Invalid JSON payload: {e}\"},\n            status=400,\n        )\n\n    created, updated = 0, 0\n\n    with transaction.atomic():\n        for row in rows:\n            try:\n                product = Product.objects.get(pk=row[\"product_id\"])\n                ingredient = Ingredient.objects.get(pk=row[\"ingredient_id\"])\n                qty_val = Decimal(row[\"quantity\"])\n\n                obj, created_flag = RecipeItem.objects.update_or_create(\n                    product=product,\n                    ingredient=ingredient,\n                    defaults={\"quantity\": qty_val},\n                )\n                created += int(created_flag)\n                updated += int(not created_flag)\n            except Exception as e:\n                # you can log or skip bad rows silently for now\n                continue\n\n    response = JsonResponse({\"status\": \"success\"})\n\n    log_import(\n        \"IMPORT\",\n        f\"{created} created, {updated} updated by {request.user if request.user.is_authenticated else 'anonymous'}\"\n    )\n\n    response[\"HX-Trigger\"] = json.dumps({\n        \"recipes:refresh\": True,\n        \"showMessage\": {\n            \"text\": f\"\u2705 {created} created, {updated} updated from CSV.\",\n            \"level\": \"success\",\n        },\n    })\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.create_product_modal","title":"<code>create_product_modal(request)</code>","text":"<p>Modal workflow for creating a new Product.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_product\", raise_exception=True)\n@require_http_methods([\"GET\", \"POST\"])\ndef create_product_modal(request):\n    \"\"\"Modal workflow for creating a new Product.\"\"\"\n    if request.method == \"POST\":\n        form = ProductForm(request.POST)\n        if form.is_valid():\n            product = form.save()\n            return _product_modal_response(f\"Created product {product.name}.\")\n    else:\n        form = ProductForm()\n\n    return _render_product_form_modal(\n        request,\n        form,\n        title=\"Create Product\",\n        submit_label=\"Create Product\",\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.delete_recipe_ingredient","title":"<code>delete_recipe_ingredient(request, product_id, item_id)</code>","text":"<p>Remove an ingredient row from a recipe and rerender the table body.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_http_methods([\"DELETE\"])\n@transaction.atomic\ndef delete_recipe_ingredient(request, product_id, item_id):\n    \"\"\"Remove an ingredient row from a recipe and rerender the table body.\"\"\"\n    product = get_object_or_404(Product, pk=product_id)\n    item = get_object_or_404(RecipeItem, pk=item_id, product=product)\n    item.delete()\n\n    # Re-render the ingredient table body\n    recipe_items = RecipeItem.objects.filter(product=product)\n    ctx = {\"recipe_items\": recipe_items, \"product\": product}\n    html = render_to_string(\"recipes/_edit_ingredient_body.html\", ctx, request=request)\n    return HttpResponse(html)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.download_recipes_template","title":"<code>download_recipes_template(request)</code>","text":"<p>Generate a blank CSV template for recipe imports.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.view_recipeitem\", raise_exception=True)\ndef download_recipes_template(request):\n    \"\"\"Generate a blank CSV template for recipe imports.\"\"\"\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"recipes_template.csv\"'\n    writer = csv.writer(response)\n    writer.writerow([\"product_id\", \"product_name\", \"ingredient_id\", \"ingredient_name\", \"quantity\"])\n    writer.writerow([\"101\", \"Demo Latte\", \"12\", \"Espresso\", \"2.0\"])\n    writer.writerow([\"101\", \"Demo Latte\", \"14\", \"Milk\", \"1.0\"])\n    writer.writerow([\"102\", \"Hot Brew\", \"22\", \"Cold Brew Base\", \"1.0\"])\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.edit_product_modal","title":"<code>edit_product_modal(request, pk)</code>","text":"<p>Modal workflow for updating a Product record from the recipes dashboard.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_product\", raise_exception=True)\n@require_http_methods([\"GET\", \"POST\"])\ndef edit_product_modal(request, pk):\n    \"\"\"Modal workflow for updating a Product record from the recipes dashboard.\"\"\"\n    product = get_object_or_404(Product, pk=pk)\n\n    if request.method == \"POST\":\n        form = ProductForm(request.POST, instance=product)\n        if form.is_valid():\n            updated = form.save()\n            return _product_modal_response(f\"Updated product {updated.name}.\")\n    else:\n        form = ProductForm(instance=product)\n\n    return _render_product_form_modal(\n        request,\n        form,\n        title=\"Edit Product\",\n        submit_label=\"Save Changes\",\n    )\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.edit_recipe_modal","title":"<code>edit_recipe_modal(request, pk)</code>","text":"<p>Return the recipe edit modal (HTML fragment for HTMX).</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@require_http_methods([\"GET\"])\ndef edit_recipe_modal(request, pk):\n    \"\"\"Return the recipe edit modal (HTML fragment for HTMX).\"\"\"\n    product = get_object_or_404(Product, pk=pk)\n    context = {\n        \"product\": product,\n        \"recipe_items\": product.recipe_items.select_related(\"ingredient\").all(),\n        #\"all_ingredients\": Ingredient.objects.all().order_by(\"name\"),\n        \"all_ingredients\": Ingredient.objects.select_related(\"type\").order_by(\"type__name\", \"name\"),\n        \"all_modifiers\": RecipeModifier.objects.select_related(\"ingredient_type\").order_by(\"ingredient_type__name\", \"name\"),\n        \"current_modifiers\": list(product.modifiers.values_list(\"id\", flat=True)) if hasattr(product, \"modifiers\") else [],\n    }\n    return render(request, \"recipes/_edit_modal.html\", context)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.edit_recipe_view","title":"<code>edit_recipe_view(request, pk)</code>","text":"<p>Full-page variant of the recipe editor.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@require_http_methods([\"GET\"])\ndef edit_recipe_view(request, pk):\n    \"\"\"Full-page variant of the recipe editor.\"\"\"\n    product = get_object_or_404(Product, pk=pk)\n\n    # existing ingredients on this recipe\n    recipe_items = (\n        RecipeItem.objects\n        .filter(product=product)\n        .select_related(\"ingredient\", \"product\")\n        .order_by(\"ingredient__name\")\n    )\n\n    # all ingredients for selector, grouped by unit_type then name\n    all_ingredients = Ingredient.objects.select_related(\"type\").order_by(\"type__name\", \"name\")\n\n    # distinct unit \u201ctypes\u201d (since your model has unit_type, not type/unit)\n    units = (\n        Ingredient.objects\n        .values_list(\"unit_type\", flat=True)\n        .distinct()\n        .order_by(\"unit_type\")\n    )\n\n    # existing modifiers FOR THIS PRODUCT (since there is no base Modifier model)\n    #recipe_modifiers = RecipeModifier.objects.all().order_by(\"type\", \"name\") #commenting out old version\n\n    base_items = _active_products_queryset().filter(\n        categories__name__icontains=\"base\"\n    ).order_by(\"name\")\n\n    # Build a dict {recipe_modifier_id: quantity} for prefill convenience (optional)\n    #current_modifiers = {rm.id: rm.base_quantity for rm in recipe_modifiers} #commenting out old version\n\n    ctx = {\n        \"product\": product,\n        \"recipe_items\": recipe_items,\n        \"all_ingredients\": all_ingredients,\n        \"units\": units,                                # e.g. [\u201cweight\u201d, \u201cvolume\u201d, \u201ccount\u201d, \u2026]\n        #\"recipe_modifiers\": recipe_modifiers,          # the ONLY modifier source you have\n        #\"current_modifiers\": current_modifiers,        # {id: qty} for prefill\n        \"base_items\": base_items,\n    }\n    return render(request, \"recipes/_edit_modal.html\", ctx)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.export_recipes_csv","title":"<code>export_recipes_csv(request)</code>","text":"<p>Export all recipes and their ingredient breakdowns as CSV.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>def export_recipes_csv(request):\n    \"\"\"Export all recipes and their ingredient breakdowns as CSV.\"\"\"\n    response = HttpResponse(content_type=\"text/csv\")\n    response[\"Content-Disposition\"] = 'attachment; filename=\"recipes_export.csv\"'\n    writer = csv.writer(response)\n\n    writer.writerow([\n        \"product_id\",\n        \"product_name\",\n        \"categories\",\n        \"ingredient_id\",\n        \"ingredient_name\",\n        \"quantity\",\n        \"average_cost_per_unit\",\n        \"cogs_subtotal\",\n    ])\n\n    # Iterate through all recipes with prefetch for performance\n    recipes = Product.objects.prefetch_related(\"recipe_items__ingredient\", \"categories\").all().order_by(\"name\")\n\n    for product in recipes:\n        categories = \", \".join([c.name for c in product.categories.all()])\n        for item in product.recipe_items.all():\n            ingredient = item.ingredient\n            if not ingredient:\n                continue\n            qty = Decimal(item.quantity or 0)\n            cost = Decimal(ingredient.average_cost_per_unit or 0)\n            subtotal = qty * cost\n            writer.writerow([\n                product.id,\n                product.name,\n                categories,\n                ingredient.id,\n                ingredient.name,\n                qty,\n                cost,\n                subtotal.quantize(Decimal(\"0.0001\")),\n            ])\n\n    return response\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.extend_recipe","title":"<code>extend_recipe(request, pk)</code>","text":"<p>Copy recipe items from another product into the target product.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@require_http_methods([\"POST\"])\ndef extend_recipe(request, pk):\n    \"\"\"Copy recipe items from another product into the target product.\"\"\"\n    product = get_object_or_404(Product, pk=pk)\n    source_id = request.POST.get(\"source_recipe_id\")\n\n    if not source_id:\n        return HttpResponseBadRequest(\"No source recipe selected.\")\n\n    source_recipe = get_object_or_404(Product, pk=source_id)\n\n    # Clone recipe items\n    for item in RecipeItem.objects.filter(product=source_recipe):\n        RecipeItem.objects.create(\n            product=product,\n            ingredient=item.ingredient,\n            quantity=item.quantity,\n            unit=item.unit,\n        )\n\n    # Return updated modal content\n    recipe_items = RecipeItem.objects.filter(product=product)\n    ctx = {\n        \"product\": product,\n        \"recipe_items\": recipe_items,\n        \"all_ingredients\": Ingredient.objects.all(),\n        \"base_items\": _active_products_queryset().filter(\n            categories__name__icontains=\"base\"\n        ),\n    }\n    return render(request, \"recipes/_edit_modal.html\", ctx)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.import_recipes_csv","title":"<code>import_recipes_csv(request)</code>","text":"<p>Parse CSV, validate rows, show preview (supports dry-run).</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_POST\ndef import_recipes_csv(request):\n    \"\"\"Parse CSV, validate rows, show preview (supports dry-run).\"\"\"\n    csv_file = request.FILES.get(\"file\")\n    dry_run = request.POST.get(\"dry_run\") == \"on\"\n\n    if not csv_file:\n        messages.error(request, \"\u26a0\ufe0f No file uploaded.\")\n        return redirect(\"recipes_dashboard\")\n\n    decoded = csv_file.read().decode(\"utf-8\")\n    reader = csv.DictReader(io.StringIO(decoded))\n\n    valid_rows, invalid_rows = [], []\n\n    for row in reader:\n        product_id = row.get(\"product_id\") or \"\"\n        ingredient_id = row.get(\"ingredient_id\") or \"\"\n        qty = row.get(\"quantity\") or \"\"\n\n        if not product_id or not ingredient_id:\n            invalid_rows.append({**row, \"error\": \"Missing product_id or ingredient_id\"})\n            continue\n\n        try:\n            product = Product.objects.get(pk=product_id)\n        except Product.DoesNotExist:\n            invalid_rows.append({**row, \"error\": \"Product not found\"})\n            continue\n\n        try:\n            ingredient = Ingredient.objects.get(pk=ingredient_id)\n        except Ingredient.DoesNotExist:\n            invalid_rows.append({**row, \"error\": \"Ingredient not found\"})\n            continue\n\n        try:\n            qty_val = Decimal(qty or \"0\")\n        except Exception:\n            invalid_rows.append({**row, \"error\": \"Invalid quantity\"})\n            continue\n\n        valid_rows.append({\n            \"product_id\": product.id,\n            \"product_name\": product.name,\n            \"ingredient_id\": ingredient.id,\n            \"ingredient_name\": ingredient.name,\n            \"quantity\": str(qty_val),\n        })\n\n    if dry_run:\n        dry_log = LOG_DIR / f\"import_recipes_dryrun_{timezone.now():%Y%m%d}.txt\"\n        dry_log.write_text(json.dumps(valid_rows, indent=2))\n    else:\n        log_import(\n            \"DRY-RUN\" if dry_run else \"PREVIEW\",\n            f\"{len(valid_rows)} valid, {len(invalid_rows)} invalid uploaded by {request.user if request.user.is_authenticated else 'anonymous'}\"\n        )\n\n    ctx = {\n    \"valid_rows\": valid_rows,\n    \"invalid_rows\": invalid_rows,\n    \"count_valid\": len(valid_rows),\n    \"count_invalid\": len(invalid_rows),\n    \"dry_run\": dry_run,\n    \"collapse_valid\": len(valid_rows) &gt; 50,\n    \"valid_rows_json\": json.dumps(valid_rows),  # \u2705 add this\n    }\n    return render(request, \"recipes/_import_recipes_preview.html\", ctx)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.import_recipes_modal","title":"<code>import_recipes_modal(request)</code>","text":"<p>Render upload modal.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\ndef import_recipes_modal(request):\n    \"\"\"Render upload modal.\"\"\"\n    return render(request, \"recipes/_import_recipes.html\")\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.log_import","title":"<code>log_import(action, message)</code>","text":"<p>Append an entry to the recipe import log.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>def log_import(action: str, message: str):\n    \"\"\"Append an entry to the recipe import log.\"\"\"\n    timestamp = timezone.now().strftime(\"%Y-%m-%d %H:%M:%S\")\n    LOG_FILE.parent.mkdir(parents=True, exist_ok=True)\n    with LOG_FILE.open(\"a\", encoding=\"utf-8\") as handle:\n        handle.write(f\"[{timestamp}] {action}: {message}\\n\")\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.recipes_dashboard_view","title":"<code>recipes_dashboard_view(request)</code>","text":"<p>Render the recipes dashboard or respond with the HTMX table fragment.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.view_product\", raise_exception=True)\ndef recipes_dashboard_view(request):\n    \"\"\"Render the recipes dashboard or respond with the HTMX table fragment.\"\"\"\n    table_context = _build_recipes_table_context(request)\n\n    categories = (\n        _active_products_queryset()\n        .values(\"categories__id\", \"categories__name\")\n        .distinct()\n        .order_by(\"categories__name\")\n    )\n\n    base_items = _active_products_queryset().filter(\n        categories__name__iexact=\"Base Item\"\n    ).order_by(\"name\")\n\n    unresolved_count = SquareUnmappedItem.objects.filter(resolved=False, ignored=False).count()\n\n    ctx = {\n        **table_context,\n        \"categories\": categories,\n        \"base_items\": base_items,\n        \"unresolved_count\": unresolved_count,\n    }\n\n\n    # \ud83e\udde9 HTMX support: only return the table partial when requested\n    if request.headers.get(\"HX-Request\"):\n        return TemplateResponse(request, \"recipes/_table.html\", table_context)\n\n    return render(request, \"recipes/dashboard.html\", ctx)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.recipes_table_fragment","title":"<code>recipes_table_fragment(request)</code>","text":"<p>HTMX endpoint returning the filtered recipe table.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.view_product\", raise_exception=True)\ndef recipes_table_fragment(request):\n    \"\"\"HTMX endpoint returning the filtered recipe table.\"\"\"\n    ctx = _build_recipes_table_context(request)\n\n    # \u2705 Always return an HttpResponse\n    return render(request, \"recipes/_table.html\", ctx)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.save_recipe_modifiers","title":"<code>save_recipe_modifiers(request, pk)</code>","text":"<p>Persist selected modifiers for a recipe.</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_http_methods([\"POST\"])\n@transaction.atomic\ndef save_recipe_modifiers(request, pk):\n    \"\"\"Persist selected modifiers for a recipe.\"\"\"\n    product = get_object_or_404(Product, pk=pk)\n    try:\n        selected_ids = request.POST.getlist(\"modifiers\")\n        modifiers = RecipeModifier.objects.filter(id__in=selected_ids)\n        product.modifiers.set(modifiers)\n        product.save(update_fields=[\"modified\"])\n        return HttpResponse(status=204)\n    except Exception:  # pragma: no cover - defensive catch for HTMX response\n        logger.exception(\"Failed to save modifiers for recipe %s\", product.pk)\n        return JsonResponse({\"error\": \"Unable to save modifiers right now.\"}, status=400)\n</code></pre>"},{"location":"16_API/views/#mscrInventory.views.recipe_modal.update_recipe_item","title":"<code>update_recipe_item(request, pk)</code>","text":"<p>Inline update for RecipeItem (quantity).</p> Source code in <code>mscrInventory/views/recipe_modal.py</code> <pre><code>@permission_required(\"mscrInventory.change_recipeitem\", raise_exception=True)\n@require_POST\ndef update_recipe_item(request, pk):\n    \"\"\"Inline update for RecipeItem (quantity).\"\"\"\n    item = get_object_or_404(RecipeItem, pk=pk)\n    product = item.product\n\n    qty = request.POST.get(\"quantity\")\n    if qty is not None:\n        item.quantity = Decimal(qty)\n        item.save(update_fields=[\"quantity\"])\n\n    return render(\n        request,\n        \"recipes/_edit_ingredient_row.html\",\n        {\"item\": item, \"product\": product},  # \ud83d\udc48 Include product in context\n    )\n</code></pre>"}]}