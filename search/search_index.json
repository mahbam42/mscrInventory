{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"MSCR Inventory App Documentation","text":"<p>Welcome to the official documentation for the MSCR Inventory App \u2014 a streamlined, relational, highly customizable inventory and recipe management system built for caf\u00e9s, beverage programs, and specialty operations.</p> <p>This guide includes everything you need to:</p> <ul> <li>Manage ingredients, recipes, and inventory  </li> <li>Import data from Square and Shopify  </li> <li>Reconcile unmapped items  </li> <li>Configure modifier behavior  </li> <li>Generate reports and forecasting insights  </li> <li>Administer user roles and permissions  </li> </ul>"},{"location":"#quick-start","title":"\ud83d\ude80 Quick Start","text":"<p>Get up and running with the core features:</p> <ul> <li>Quick Start Overview</li> <li>Dashboard Layout</li> <li>Adding &amp; Editing Ingredients</li> <li>Creating &amp; Editing Recipes</li> <li>Upload Square CSV</li> </ul>"},{"location":"#daily-operations","title":"\ud83d\udcca Daily Operations","text":"<ul> <li>View low-stock items  </li> <li>Perform bulk stock updates  </li> <li>Review modifiers and recipes  </li> <li>Reconcile unmapped imports  </li> <li>Monitor orders from Square and Shopify  </li> </ul> <p>Key sections:</p> <ul> <li>Ingredients </li> <li>Recipes </li> <li>Inventory </li> <li>Orders Dashboard</li> </ul>"},{"location":"#power-features","title":"\ud83e\uddf0 Power Features","text":""},{"location":"#imports-mapping","title":"Imports &amp; Mapping","text":"<p>The app includes a robust matching engine with support for:</p> <ul> <li>Square CSVs  </li> <li>Shopify data  </li> <li>Modifier analysis and aliasing  </li> <li>Unmapped-item reconciliation  </li> <li>Bulk creation and linking  </li> </ul> <p>\u27a1\ufe0f View: Unmapped Items Dashboard</p>"},{"location":"#reporting-analytics","title":"\ud83d\udcc8 Reporting &amp; Analytics","text":"<p>Gain clarity on:</p> <ul> <li>Cost of Goods Sold (COGS)  </li> <li>Ingredient usage trends  </li> <li>Inventory valuation  </li> <li>Exportable CSV insights  </li> </ul> <p>Start here: Reporting Overview</p>"},{"location":"#user-management","title":"\ud83d\udc64 User Management","text":"<p>Assign granular permission groups:</p> <ul> <li>Admin  </li> <li>Manager  </li> <li>Barista  </li> <li>Inventory  </li> <li>Pending  </li> </ul> <p>\u27a1\ufe0f Manage users: User Administration</p>"},{"location":"#admin-tools","title":"\ud83d\udee0 Admin Tools","text":"<p>Access advanced features (restricted):</p> <ul> <li>Raw data tables  </li> <li>Import logs  </li> <li>Direct object editing  </li> </ul> <p>\u27a1\ufe0f Django Admin (Restricted Access)</p>"},{"location":"#appendices","title":"\ud83e\udde9 Appendices","text":"<ul> <li>Appendix A: Manual Testing </li> <li>Appendix B: Unmapped Items Usage </li> <li>Appendix C: Platform Comparison</li> </ul>"},{"location":"#future-roadmap","title":"\ud83d\uddfa Future Roadmap","text":"<p>Explore upcoming planned features:</p> <ul> <li>DoorDash integration  </li> <li>Square API sync  </li> <li>Improved reporting dashboards  </li> <li>Vendor automation support  </li> </ul> <p>\u27a1\ufe0f Read the Roadmap</p>"},{"location":"01_Introduction/01_introduction/","title":"Introduction","text":"<p>The MSCR Inventory App provides a unified, streamlined workflow for managing ingredients, recipes, products, orders, inventory, and imports across caf\u00e9 and retail environments. It is designed to support both daily operations and long-term data accuracy, while remaining accessible to non-technical staff.</p> <p>This manual describes the operational workflow for managers and authorized users who handle inventory updates, recipe maintenance, product management, user permissions, and data reconciliation through the web interface.</p> <p>This guide is written for general staff, supervisors, and managers. Developer-only setup, installation, and technical notes have been removed from the main body of the manual and placed into the appendices. The intent is to keep the core documentation focused, practical, and easy to reference during daily operations.</p>"},{"location":"01_Introduction/01_introduction/#architecture-design-notes","title":"Architecture &amp; Design Notes","text":"<p>The MSCR Inventory App is built with Django, HTMX, and Bootstrap, emphasizing clarity, maintainability, and minimal dependencies. These architectural choices allow the system to remain fast, flexible, and stable across multiple environments.</p> <p>Key design principles:</p> <ul> <li> <p>Minimal Dependencies:   Uses Django, HTMX, and Bootstrap \u2014 no frontend frameworks required.  </p> </li> <li> <p>Relational, Structured Data Model:   Ingredients, products, recipes, modifiers, and packaging are fully relational to ensure consistent reporting and precise cost calculations.</p> </li> <li> <p>CSV-Driven Integration:   CSV import/export serves both as operational tooling and an internal API for external systems (automation scripts, third-party integrations).</p> </li> <li> <p>Square &amp; Shopify Integration:   Shopify integration is complete; DoorDash integration is in progress.   Direct Square and DoorDash API syncing (beyond CSV uploads) is planned.</p> </li> <li> <p>Role-Based Views:   Users only see relevant features based on their assigned permission group, keeping the UI clean and reducing confusion.</p> </li> <li> <p>HTMX-Based UI:   High-responsiveness without page reloads: edits, modals, updates, and lists refresh dynamically for a modern, lightweight interface.</p> </li> </ul>"},{"location":"01_Introduction/01_introduction/#about-this-manual","title":"About This Manual","text":"<p>This manual is organized into the following major parts:</p> <ol> <li>Daily Operations &amp; Dashboards \u2013 overview of the dashboard, navigation systems, and daily workflows.  </li> <li>Core Data Management \u2013 instructions for maintaining ingredients, recipes, products, and stock levels.  </li> <li>Imports &amp; Data Reconciliation \u2013 Square/Shopify import flows, unmapped item resolution, and modifier tools.  </li> <li>Advanced Tools \u2013 reporting, user management, admin access.  </li> <li>Appendices \u2013 manual testing, detailed unmapped item documentation, comparisons, and roadmap.</li> </ol> <p>Each section is written to be self-contained, so users can jump directly to the workflow they're performing.</p>"},{"location":"01_Introduction/01_introduction/#audience","title":"Audience","text":"<p>This manual is intended for:</p> <ul> <li>Managers &amp; Supervisors \u2014 inventory, product, and recipe changes; review reports; manage users.</li> <li>Baristas &amp; Staff \u2014 view-only access; limited editing for ingredients, recipes, and inventory (depending on assigned role).</li> <li>Inventory Personnel \u2014 stock counts, adjustments, and purchasing prep.</li> <li>Admins \u2014 full access including Django Admin.</li> </ul> <p>New users should begin with the Quick Start Overview for a high-level summary of daily responsibilities.</p>"},{"location":"01_Introduction/01_introduction/#responsibilities-safety-notes","title":"Responsibilities &amp; Safety Notes","text":"<p>This application directly influences cost calculations, product-recipe mapping, and overall reporting accuracy. When making updates:</p> <ul> <li>Double-check ingredient names and units before saving.</li> <li>Avoid deleting items that are used elsewhere (use Archive instead).</li> <li>Use Dry Runs when processing imports until you\u2019re confident in the file.</li> <li>Complete or cancel modals before navigating to avoid data loss.</li> <li>Maintain consistent naming conventions for clean imports and reporting.</li> </ul> <p>Following these guidelines ensures clean imports, accurate cost reporting, and smooth cross-system integration.</p>"},{"location":"02_Quickstart/01_Quickstart/","title":"Quick Start Overview \u2013 Daily Tasks","text":"<p>The Quick Start section highlights the most common day-to-day workflows for managers, baristas, and inventory staff. Each task can be completed quickly using the dashboard or the main navigation menus.</p> <p>Use this section as a rapid reference guide when performing routine updates.</p>"},{"location":"02_Quickstart/01_Quickstart/#daily-tasks","title":"Daily Tasks","text":"Task Steps Check inventory levels 1. Open the Dashboard tab.  2. Review the Inventory Summary panel for low-stock or out-of-stock alerts.  3. Click any ingredient name to view or update its stock levels. Add or edit an ingredient 1. Go to Inventory \u2192 Ingredients.  2. Click Add Ingredient or select an existing ingredient.  3. Update name, type, or unit cost.  4. Click Save Changes. Adjust recipe quantities 1. Go to Recipes \u2192 Manage Recipes.  2. Select a recipe and click Edit.  3. Adjust ingredient amounts as needed.  4. Click Save Recipe. Check or update product pricing 1. Go to Products \u2192 Product List.  2. Select a product and choose Edit.  3. Adjust its linked recipe or retail price.  4. Click Save. Review unmapped imports 1. Go to Imports \u2192 Unmapped Items.  2. Review any flagged entries.  3. Match each entry to an existing ingredient, product, or recipe \u2014 or create a new item.  4. Confirm mappings and close the modal."},{"location":"02_Quickstart/01_Quickstart/#notes-best-practices","title":"Notes &amp; Best Practices","text":"<p>NOTE: Changes to a recipe immediately update all products that use that recipe.</p> <p>CAUTION: Avoid deleting ingredients that are used in recipes or products \u2014 deletion can break linked data. Use Archive instead.</p> <p>TIP: Use consistent naming conventions. For example\u2014 \u201cWhole Milk (16oz)\u201d is easier for the importer to match than \u201cMilk - Whole Large Bag\u201d.</p>"},{"location":"02_Quickstart/01_Quickstart/#when-to-use-the-dashboard-vs-navigation-menu","title":"When to Use the Dashboard vs. Navigation Menu","text":"<ul> <li>Use the Dashboard for:</li> <li>Quick adjustments  </li> <li>Recently changed items  </li> <li>Low-stock alerts  </li> <li> <p>Import summaries  </p> </li> <li> <p>Use the Navigation Menu when:</p> </li> <li>Performing structured edits  </li> <li>Searching for specific records  </li> <li>Reviewing full tables of ingredients, recipes, or products  </li> <li>Managing user permissions  </li> </ul>"},{"location":"02_Quickstart/01_Quickstart/#recommended-daily-flow","title":"Recommended Daily Flow","text":"<ol> <li> <p>Log in and check dashboard alerts    Low-stock warnings, unmapped items, recent changes.</p> </li> <li> <p>Review inventory adjustments    Enter new stock from deliveries or update depleted ingredients.</p> </li> <li> <p>Check product and recipe accuracy    Ensure new items imported from Square or Shopify are mapped correctly.</p> </li> <li> <p>Look for cost discrepancies    Ingredients with unusual cost shifts may require updates.</p> </li> <li> <p>Review orders (optional)    Use the Orders Dashboard to review trends, especially custom/named drinks.</p> </li> </ol>"},{"location":"02_Quickstart/01_Quickstart/#who-uses-this-section","title":"Who Uses This Section","text":"<p>This section is most helpful for:</p> <ul> <li>Managers \u2014 ensuring data stays clean and consistent  </li> <li>Inventory staff \u2014 adjusting stock and reviewing deliveries  </li> <li>Baristas \u2014 checking recipe details or confirming ingredient availability  </li> </ul>"},{"location":"03_Navigation/01_DashboardLayout/","title":"Dashboard Layout","text":"<p>The Dashboard is the landing page after login. It summarizes recent activity and highlights key areas that may require attention.</p> <ul> <li>Inventory Summary: Displays total ingredient count and alerts for low-stock or unmapped items.</li> <li>Top Name-Your-Drink links directly into the Orders Dashboard filtered by the correct preset. Use this feature to: - Identify popular recurring custom drink names - Validate whether new recipes or modifiers should be created - Spot trends in seasonal or special\u2011request beverages</li> <li>Recent Imports: Shows the latest CSV, Square, or Shopify import sessions with timestamps and status indicators.  </li> <li>Quick Actions Panel: Shortcuts for adding ingredients, updating recipes, or opening import modals.  </li> <li>Search Bar: Filters items by name, type, or category throughout the app.  </li> <li>Notifications Banner: Displays system messages, successful saves, or warnings about incomplete data.  </li> </ul> <p>NOTE: Items highlighted in red indicate missing data or mapping conflicts. Clicking an item opens its detail view.</p>"},{"location":"03_Navigation/02_NavigationMenu/","title":"Navigation Menu","text":"<p>The navigation menu appears at the top of the screen and contains the primary sections of the app. By default every signed-in user sees the following links:</p> Menu Purpose Dashboard Summaries and quick links to recent activity. Imports Run import sessions, resolve unmapped items, and explore modifiers. Orders Unified Shopify + Square order history. Recipes View and edit recipe structures. Ingredients Manage ingredient definitions and costing inputs. Inventory Review inventory dashboards, counts, and archive history. <p>Additional entries, appear based on permissions, rendered inside the secondary admin menu when a user has the appropriate Django permissions:</p> Menu Purpose Reporting visible when the user has the <code>mscrInventory.change_order</code> permission (granted to users who need access to aggregate sales and usage reporting). Manage Users Add Users or assign permission groups Admin Access the Django Admin console to make changes directly to the database. <p>CAUTION: The Admin area should only be used by managers or technical staff.</p>"},{"location":"03_Navigation/03_ModalsDialogs/","title":"Modals and Dialogs","text":"<p>Most actions occur through modal dialogs instead of full page reloads, which keeps the workflow fast and focused.</p>"},{"location":"03_Navigation/03_ModalsDialogs/#common-modal-types","title":"Common Modal Types","text":"<ul> <li>Add / Edit Modals: Create or edit ingredients, recipes, products, and inventory entries.  </li> <li>Unmapped Items Modal: Displays unresolved import entries requiring manual review.  </li> <li>Edit Modifier Rules Modal: Manage allowed modifiers, replacements, and pricing behavior.  </li> </ul> <p>TIP: Always complete or cancel a modal before navigating elsewhere to avoid losing unsaved changes.</p>"},{"location":"03_Navigation/04_ColorIcons/","title":"Color and Icon Conventions","text":"<p>The app uses consistent visual language to indicate the status of items:</p> Color / Icon Meaning Red Error or required attention (unmapped, missing data, low stock). Yellow Pending review or incomplete information. Green Successfully saved or verified. Blue \u201c+\u201d icon Add a new record. Edit (\u270e) Edit an existing entry. <p>These conventions appear consistently across tables, forms, and dashboards.</p>"},{"location":"03_Navigation/05_SearchFilters/","title":"Search and Filters","text":"<p>Use the global search or per-table filters to locate items quickly. Filters may be combined\u2014for example, searching by name and narrowing by ingredient type.</p> <p>NOTE: Filters persist between navigation actions until manually cleared.</p> <p>When working with large inventories or recipe libraries, filters significantly reduce the time needed to locate and update records.</p>"},{"location":"04_Ingredients/01_Overview/","title":"Ingredients Overview","text":"<p>Ingredients form the foundation of all recipes and products. Each ingredient record stores its name, type, unit of measure, unit cost, and optional descriptive fields such as roast level or bag size.</p> <p>Ingredients must be maintained carefully, as they drive recipe accuracy, cost calculations, inventory counts, and reporting.</p> <p>Key capabilities: - Add, edit, or archive ingredients - Assign ingredient types - Track cost per unit - Associate packaging (cups, lids, sleeves, etc.) - Search and filter by category or status  </p>"},{"location":"04_Ingredients/02_AddingEditing/","title":"Adding or Editing Ingredients","text":""},{"location":"04_Ingredients/02_AddingEditing/#add-a-new-ingredient","title":"Add a New Ingredient","text":"<ol> <li>Navigate to Inventory \u2192 Ingredients.  </li> <li>Click Add Ingredient (+).  </li> <li>Enter the ingredient name, type, unit, and cost per unit.  </li> <li>(Optional) Add details such as roast, grind, or bag size.  </li> <li>Click Save.</li> </ol>"},{"location":"04_Ingredients/02_AddingEditing/#edit-an-existing-ingredient","title":"Edit an Existing Ingredient","text":"<ol> <li>Open the Ingredients list.  </li> <li>Click the Edit (\u270e) icon next to the ingredient.  </li> <li>Update cost, type, or metadata.  </li> <li>Save changes.</li> </ol>"},{"location":"04_Ingredients/02_AddingEditing/#archiving-ingredients","title":"Archiving Ingredients","text":"<ul> <li>Use Archive instead of Delete.  </li> <li>Archived ingredients are hidden from active lists but preserved in historical records.</li> </ul> <p>CAUTION: Do not delete ingredients used in recipes.</p>"},{"location":"04_Ingredients/03_Fields/","title":"Ingredient Fields","text":"Field Description Name Display name used throughout the app Ingredient Type Category such as Milk, Syrup, Roast, Bagel, etc. Unit of Measure oz, ml, g, bag, scoop, etc. Cost per Unit Used to calculate COGS and inventory valuation Bag Size / Roast / Grind Auto-displayed for coffee and similar items Active Whether the ingredient is currently in use <p>TIP: Ensure cost is always entered per unit, not per package.</p>"},{"location":"04_Ingredients/04_BestPractices/","title":"Ingredient Best Practices","text":"<ul> <li>Capitalize the first letter of each ingredient name.  </li> <li>Avoid brand names unless necessary.  </li> <li>Use consistent naming patterns (e.g., \u201cWhole Milk (16oz)\u201d).  </li> <li>Keep inactive or seasonal ingredients archived.  </li> <li>Audit ingredient costs regularly for accurate COGS.</li> </ul> <p>NOTE: Consistent naming helps the importer match items correctly.</p>"},{"location":"04_Ingredients/05_CSV/","title":"Bulk Editing and CSV Import (In Development)","text":"<p>Large ingredient updates can be made with the Ingredient CSV Importer.</p>"},{"location":"04_Ingredients/05_CSV/#workflow","title":"Workflow","text":"<ol> <li>On the Ingredients Dashboard download the current ingredients with Export CSV button.  </li> <li>Upload your CSV using the standard template.  </li> <li>Review the mapping preview.  </li> <li>Confirm to apply updates.</li> </ol>"},{"location":"04_Ingredients/05_CSV/#best-uses","title":"Best Uses","text":"<ul> <li>Updating multiple costs  </li> <li>Adding new seasonal items  </li> <li>Cleaning up inconsistent naming  </li> <li>Correcting units or types</li> </ul> <p>CAUTION: Rows with identical names overwrite existing ingredients.</p>"},{"location":"04_Ingredients/06_Troubleshooting/","title":"Ingredients Troubleshooting","text":""},{"location":"04_Ingredients/06_Troubleshooting/#ingredient-not-appearing","title":"Ingredient Not Appearing","text":"<ul> <li>Check if the ingredient is Active.</li> <li>Verify the ingredient type is correct.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#cost-not-updating","title":"Cost Not Updating","text":"<ul> <li>Re-save the recipe that uses the ingredient.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#duplicate-warnings","title":"Duplicate Warnings","text":"<ul> <li>Clean up ingredient naming conventions.</li> <li>Archive old or unused entries.</li> </ul>"},{"location":"04_Ingredients/06_Troubleshooting/#missing-packaging-options","title":"Missing Packaging Options","text":"<ul> <li>Ensure packaging types are active in the Packaging section.</li> </ul>"},{"location":"05_Recipes/01_Overview/","title":"Recipes Overview","text":"<p>Recipes define how ingredients combine to form products. Every product in the MSCR Inventory App is linked to a recipe, and recipe accuracy directly affects cost calculations, scaling, and modifier behavior.</p> <p>Recipes are stored as structured ingredient lists with quantities, units, and optional modifier rules. Updates to a recipe immediately cascade to all linked products.</p> <p>Key functions: - Create new recipes - Edit existing ones - Scale ingredient ratios for multiple sizes - Extend Recipes from <code>'base_items'</code>  - Configure modifier behavior  </p>"},{"location":"05_Recipes/02_CreateEdit/","title":"Creating or Editing Recipes","text":""},{"location":"05_Recipes/02_CreateEdit/#creating-a-new-recipe","title":"Creating a New Recipe","text":"<ol> <li>Go to Recipes \u2192 Manage Recipes.  </li> <li>Click Add Recipe.  </li> <li>Enter the recipe name, category, and base size (typically Small / 12oz).   NOTE: All Drink Recipes should be entered assuming a 12oz Capacity for Dynamic Scaling to work </li> <li>Add ingredients by selecting them from the dropdown and entering quantities.  </li> <li>Save the recipe.</li> </ol>"},{"location":"05_Recipes/02_CreateEdit/#editing-an-existing-recipe","title":"Editing an Existing Recipe","text":"<ol> <li>Navigate to Manage Recipes.  </li> <li>Find the recipe and click Edit (\u270e).  </li> <li>Adjust ingredient amounts or add/remove components.  </li> <li>Save changes.</li> </ol>"},{"location":"05_Recipes/02_CreateEdit/#copying-ingredients-from-another-recipe","title":"Copying Ingredients From Another Recipe","text":"<p>Use the Extend Recipe workflow inside the edit modal to copy ingredient lines:</p> <ol> <li>Open the target recipe (or product) and click Edit (\u270e) to launch the recipe modal.</li> <li>In the Extend From Recipe field, choose the source recipe whose ingredients you want to reuse (for example, a base latte or a seasonal variant).</li> <li>Confirm the prompt to import the selected recipe\u2019s ingredients into the current form.</li> <li>Adjust quantities or remove any lines that do not apply, then save.</li> </ol> <p>This copies the ingredient list into the current recipe while keeping the original unchanged. Editing a recipe immediately updates all linked products, so review quantities before saving.</p>"},{"location":"05_Recipes/03_Scaling/","title":"Understanding Dynamic Scaling","text":"<p>The app uses scaling ratios to automatically calculate ingredient quantities for different sizes.</p>"},{"location":"05_Recipes/03_Scaling/#example-latte-milk","title":"Example (Latte \u2013 Milk):","text":"Size Ratio Milk Amount Hot Small (12oz) 1.0 8 oz Iced Small (16oz) 1.34 11 oz Hot Large/XL (20oz) 1.66 13.3 oz Iced XL (32oz) 2.68 21 oz <p>Scaling ensures consistency and reduces repetitive data entry.</p> <p>Ingredients like Milk and Coldbrew are dynamically scaled based on Modifiers added to a drink</p> <p>TIP: Avoid rounding values prematurely \u2014 the system handles precision internally.</p>"},{"location":"05_Recipes/04_Fields/","title":"Recipe Fields","text":"Field Description Name Name of the recipe, usually matching the menu item Category Groups the recipe (Drinks, Bakery, etc.) Ingredients List of ingredients with quantities and units Active Determines whether the recipe is currently in use <p>These fields collectively determine how products are constructed from recipes.</p>"},{"location":"05_Recipes/05_AddIngredients/","title":"Adding Ingredients to Recipes","text":"<ol> <li>In the recipe editor, click Add Ingredient.  </li> <li>Choose an ingredient from the dropdown list.  </li> <li>Enter the quantity (e.g., <code>2 oz</code>, <code>1 unit</code>).  </li> <li>Repeat for additional ingredients.  </li> <li>Save the recipe.</li> </ol> <p>NOTE: Ingredients must be marked Active to appear in dropdowns.</p>"},{"location":"05_Recipes/05_AddIngredients/#removing-ingredients","title":"Removing Ingredients","text":"<ul> <li>Via the Admin by Administrators or Managers only</li> </ul>"},{"location":"05_Recipes/05_AddIngredients/#reordering-ingredients","title":"Reordering Ingredients","text":"<p>Ingredient order is automatically managed and does not affect functionality.</p>"},{"location":"05_Recipes/06_Modifiers/","title":"Modifiers and Optional Ingredients","text":"<p>Modifiers allow customers to customize drinks and food items without altering the base recipe.</p>"},{"location":"05_Recipes/06_Modifiers/#common-modifier-types","title":"Common Modifier Types","text":"<ul> <li>Milk Options: oat, soy, almond, whole, skim  </li> <li>Syrups &amp; Flavor Shots: vanilla, caramel, hazelnut  </li> <li>Size / Temperature Options: iced, large, extra hot  </li> <li>Add-ons: extra shot, whipped cream  </li> </ul> <p>Modifiers work alongside recipe ingredients but do not replace them unless specifically configured.</p>"},{"location":"05_Recipes/07_ModifierRules/","title":"Edit Modifier Rules","text":"<p>The Edit Modifier Rules modal controls how a recipe responds to customizations.</p>"},{"location":"05_Recipes/07_ModifierRules/#you-can-configure","title":"You can configure:","text":"<ul> <li>Allowed modifiers  </li> <li>Replacement behavior (e.g., replace whole milk with oat milk)  </li> <li>Additive behavior (e.g., add 0.5 oz syrup)  </li> <li>Temperature rules (hot/iced logic)  </li> <li>Additional costs or upgrades  </li> </ul> <p>Changes apply to all products linked to the recipe.</p> <p>CAUTION: Incorrect modifier rules can create mismatches during imports.</p>"},{"location":"05_Recipes/08_BestPractices/","title":"Recipe Best Practices","text":"<ul> <li>Recipes should be portioned to 12oz for Dynamic Scaling.  </li> <li>Avoid hardcoding multiple size versions \u2014 rely on scaling.  </li> <li>Audit ingredient costs regularly for accurate product pricing.   </li> <li>Archive recipes instead of deleting them.</li> </ul> <p>TIP: Keep recipe names clear to support Square/Shopify import matching.</p>"},{"location":"05_Recipes/09_Troubleshooting/","title":"Recipe Troubleshooting","text":""},{"location":"05_Recipes/09_Troubleshooting/#scaling-seems-incorrect","title":"Scaling Seems Incorrect","text":"<ul> <li>Check the recipe base size.  </li> <li>Review ingredient units for mismatches.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#ingredient-missing-from-dropdown","title":"Ingredient Missing from Dropdown","text":"<ul> <li>Ensure the ingredient is Active.  </li> <li>Confirm its type is correct.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#cost-doesnt-update","title":"Cost Doesn\u2019t Update","text":"<ul> <li>Re-save the recipe to trigger recalculation.</li> </ul>"},{"location":"05_Recipes/09_Troubleshooting/#imported-items-not-matching-recipe","title":"Imported Items Not Matching Recipe","text":"<ul> <li>Review modifier rules.  </li> <li>Check for naming inconsistencies.  </li> </ul>"},{"location":"06_Imports/01_Overview/","title":"Imports Overview","text":"<p>The Imports section manages all inbound data from Square, Shopify, and CSV-based internal tools. It is the central hub for maintaining accurate mappings, reconciling mismatched items, and keeping the inventory and recipe systems aligned with real-world sales.</p> <p>Imports support:</p> <ul> <li>Square CSV uploads  </li> <li>Shopify imports   </li> <li>Bulk import history review  </li> <li>Modifier classification and analysis  </li> <li>Unmapped item resolution (with modal or full-page dashboard)</li> </ul> <p>Additional CSV Imports are handled on Dashboards: - Ingredient CSV uploads - Inventory CSV updates \u2202</p> <p>Accurate imports ensure:</p> <ul> <li>Correct recipe and product usage reporting  </li> <li>Clean naming conventions  </li> <li>Accurate cost-of-goods tracking  </li> <li>Smooth cross-platform data sync  </li> </ul>"},{"location":"06_Imports/02_UploadSquare/","title":"Upload Square CSV","text":"<p>The Square Importer is one of the most frequently used tools in the app. It processes item-level sales data exported from Square.</p>"},{"location":"06_Imports/02_UploadSquare/#how-to-run-a-square-import","title":"How to Run a Square Import","text":"<ol> <li>Navigate to Imports \u2192 Square Import.  </li> <li>Upload a Square CSV file.  </li> <li>(Optional) Check Dry Run to simulate the import.  </li> <li>Click Upload.  </li> <li>Review the import summary including created, updated, skipped, or unmapped rows.</li> </ol>"},{"location":"06_Imports/02_UploadSquare/#dry-run-mode","title":"Dry Run Mode","text":"<ul> <li>Parses the full CSV  </li> <li>Performs all matching logic  </li> <li>Logs warnings and unmapped items  </li> <li>Does not write anything to the database  </li> </ul> <p>This is ideal for checking file structure before running a full import.</p>"},{"location":"06_Imports/02_UploadSquare/#import-results-summary","title":"Import Results Summary","text":"<p>After processing a file, the importer displays:</p> <ul> <li>Number of products matched  </li> <li>Number of modifiers detected  </li> <li>Items created or updated  </li> <li>Items skipped or ignored  </li> <li>Total unmapped items (with button to resolve)</li> <li>Any warnings or validation errors</li> </ul> <p>TIP: Always perform a Dry Run for new menus or seasonal items.</p>"},{"location":"06_Imports/03_Unmapped_Items/","title":"Unmapped Items Dashboard","text":"<p>Unmapped items appear when the importer cannot match a Square or Shopify row to an existing product, ingredient, or modifier.</p> <p>Common reasons include:</p> <ul> <li>Misspellings  </li> <li>New seasonal drinks  </li> <li>Visibility differences between Square and the Inventory App  </li> <li>Price-point variants not recognized by the system  </li> <li>Missing modifier groups or recipe definitions  </li> </ul>"},{"location":"06_Imports/03_Unmapped_Items/#how-to-resolve-unmapped-items","title":"How to Resolve Unmapped Items","text":"<ol> <li>Go to Imports \u2192 Unmapped Items.  </li> <li>Review the list (modal or full-page).  </li> <li>For each unmapped row:</li> <li>Link to Existing product/ingredient/modifier  </li> <li>Create New record  </li> <li>Mark as Ignored if not relevant  </li> <li>Confirm your action.  </li> <li>Unmapped count updates immediately.</li> </ol>"},{"location":"06_Imports/03_Unmapped_Items/#unmapped-items-modal","title":"Unmapped Items Modal","text":"<p>The modal presents: - Source (Square or Shopify) - Item type (Product, Ingredient, Modifier) - Raw name from import - Suggested matches (if any) - Link/Create actions  </p>"},{"location":"06_Imports/03_Unmapped_Items/#full-unmapped-items-dashboard","title":"Full Unmapped Items Dashboard","text":"<p>Includes: - Filters (type/source/date) - Pagination - Bulk actions - Links to record creation - \u201cOpen in Modal\u201d options  </p>"},{"location":"06_Imports/03_Unmapped_Items/#technical-internals","title":"Technical Internals","text":"<p>For a complete explanation of: - how unmapped items are normalized - how duplicates are prevented - when rows reopen after being resolved - how occurrence tracking works - how Ignore/Resolve/Create logic behaves  </p> <p>See Appendix B \u2013 Unmapped Items Usage.</p>"},{"location":"06_Imports/04_ModifierExplorer/","title":"Modifier Explorer","text":"<p>The Modifier Explorer helps you analyze and standardize modifier behavior across imported data. It groups modifiers into categories based on how they match existing records.</p> <p>Modifier categories include:</p> <ul> <li>Known: Clean matches to existing modifiers  </li> <li>Alias: Equivalent labels (e.g., \u201cOatmilk\u201d \u2192 \u201cOat Milk\u201d)  </li> <li>Fuzzy Match: Similar but not identical names  </li> <li>Unknown: Unrecognized or new modifiers  </li> <li>Co-occurrence Pairs: Common combinations that frequently appear together  </li> </ul>"},{"location":"06_Imports/04_ModifierExplorer/#what-you-can-do-in-modifier-explorer","title":"What You Can Do in Modifier Explorer","text":"<ul> <li>Review each category\u2019s items  </li> <li>Assign aliases to unify inconsistent naming  </li> <li>Promote or demote modifiers  </li> <li>Identify missing variants in recipes or product setups  </li> <li>Export modifier insights as CSV for deeper analysis  </li> </ul> <p>TIP: Resolve modifier inconsistencies before importing large batches to reduce unmapped items.</p>"},{"location":"06_Imports/05_ImportHistory/","title":"Import History","text":"<p>The Import History table provides a chronological view of all data imports across the system, including:</p> <ul> <li>Square CSV uploads  </li> <li>Shopify imports  </li> <li>Ingredient CSV imports  </li> <li>Inventory CSV adjustments  </li> </ul> <p>Each entry displays: - Timestamp - Source (Square/Shopify/CSV) - Run type (Dry Run or Live) - Count of created, updated, or skipped items - Links to warnings or unmapped items  </p>"},{"location":"06_Imports/05_ImportHistory/#when-to-use-import-history","title":"When to Use Import History","text":"<ul> <li>Audit previous import runs  </li> <li>Verify if a file was processed successfully  </li> <li>Confirm whether an issue came from Square or the Inventory App  </li> <li>Track changes over time  </li> </ul> <p>Import History helps identify patterns such as: - Repeated unmapped items - Inconsistent naming between systems - Products missing cost or ingredient data  </p>"},{"location":"06_Imports/06_Fetch_Shopify/","title":"Fetch Shopify CSV","text":"<p>The Shopify Importer is one of the most frequently used tools in the app. It pulls item-level sales data exported from Shopify via API, keeping recipes, products, and inventory aligned with what actually sold in the shop.</p>"},{"location":"06_Imports/06_Fetch_Shopify/#how-to-run-a-shopify-import","title":"How to Run a Shopify Import","text":"<ol> <li>Navigate to Imports \u2192 Fetch Shopify.  </li> <li>Select the Date Range you need; the importer uses the start and end dates to pull every order in that window.</li> <li>Click <code>Fetch Shopify</code>. The modal stays open with a progress indicator while the background task fetches the orders.</li> <li>After completion, check the import log for any unmapped SKUs or modifiers that need resolution. Unmapped items render a warning inside the modal so you can link them with the right ingredients or recipes before the next sync.</li> </ol>"},{"location":"06_Imports/06_Fetch_Shopify/#follow-up","title":"Follow-up","text":"<ul> <li>Review the imported data on the Imports History screen to confirm totals and export the batch if you need a CSV backup.  </li> <li>If inventory quantities shift, refresh the Inventory dashboard so HTMX partials rerender with the updated on-hand amounts.  </li> <li>Schedule Shopify imports daily or weekly to keep pricing and modifier usage accurate for costing and purchasing workflows.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/","title":"Orders Dashboard","text":"<p>The Orders Dashboard consolidates recent Shopify and Square orders into a single, unified view. It helps teams quickly review customer activity, custom drink trends, and imported item behavior.</p>"},{"location":"07_Orders/01_OrdersDashboard/#key-features","title":"Key Features","text":""},{"location":"07_Orders/01_OrdersDashboard/#unified-order-stream","title":"Unified Order Stream","text":"<ul> <li>Displays both Square and Shopify orders.</li> <li>Combined view by default; platform filters allow narrowing to one source.</li> <li>Customizable date range with standard presets:</li> <li>Last 7 days</li> <li>Last 14 days</li> <li>Last 30 days</li> <li>Last 90 days</li> <li>Custom date window (reveals the from/to inputs so you can set any specific range)</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#filters-and-search","title":"Filters and Search","text":"<ul> <li>Filter by platform (Square / Shopify)</li> <li>Search by product name or custom drink text</li> <li>Identify \u201cName Your Drink\u201d items that appear frequently</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#order-details","title":"Order Details","text":"<p>Each order entry includes: - Order timestamp - Source (Square / Shopify) - List of items with quantities - Modifiers applied to each item - Total item count (annotated for clarity)</p>"},{"location":"07_Orders/01_OrdersDashboard/#pagination","title":"Pagination","text":"<ul> <li>Large order volumes automatically paginate</li> <li>Navigation links preserve filter parameters</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#name-your-drink-integration","title":"\u201cName Your Drink\u201d Integration","text":"<p>The Dashboard widget for Top Name-Your-Drink links directly into the Orders Dashboard filtered by the correct preset.</p> <p>Use this feature to: - Identify popular recurring custom drink names - Validate whether new recipes or modifiers should be created - Spot trends in seasonal or special\u2011request beverages</p>"},{"location":"07_Orders/01_OrdersDashboard/#use-cases","title":"Use Cases","text":"<ul> <li>Reviewing unusual modifiers before running mapping updates</li> <li>Checking Square/Shopify consistency for newly added menu items</li> <li>Tracing the origin of unmapped or mis\u2011mapped items in imports</li> <li>Monitoring custom drink naming and usage frequency</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#troubleshooting","title":"Troubleshooting","text":""},{"location":"07_Orders/01_OrdersDashboard/#missing-orders","title":"Missing Orders?","text":"<ul> <li>Confirm selected date range.</li> <li>Ensure platform filters are not hiding results.</li> <li>Check Shopify and Square export configurations.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#unknown-modifier-appearing","title":"Unknown Modifier Appearing?","text":"<ul> <li>Visit Imports \u2192 Modifier Explorer for classification.</li> <li>Review the associated product\u2019s modifier groups.</li> <li>Check for spelling variations or Square menu discrepancies.</li> </ul>"},{"location":"07_Orders/01_OrdersDashboard/#duplicate-orders","title":"Duplicate Orders?","text":"<ul> <li>Ensure the same platform is not being imported twice.</li> <li>Verify the date range does not overlap across import sessions.</li> </ul>"},{"location":"08_Inventory/01_LowStock/","title":"Low Stock Ingredients","text":"<p>The Low Stock view highlights ingredients that have fallen below their reorder point. These warnings appear both on the Dashboard and in the Inventory module.</p>"},{"location":"08_Inventory/01_LowStock/#what-triggers-low-stock","title":"What Triggers Low Stock","text":"<ul> <li>An ingredient\u2019s calculated current stock drops below its <code>reorder_point</code> value. Or <code>usage</code> from last import times <code>lead time</code> will exceed <code>reorder_point</code>.</li> <li>Manual adjustments, bulk updates, or imports that reduce stock.</li> <li>Negative or inconsistent stock counts after CSV import.</li> </ul>"},{"location":"08_Inventory/01_LowStock/#how-to-use-low-stock-alerts","title":"How to Use Low Stock Alerts","text":"<ol> <li>Open the Dashboard or Inventory \u2192 Low Stock (if available).  </li> <li>Review the list of flagged ingredients.  </li> <li>Click an ingredient name to open its detail modal.  </li> <li>Enter new stock (e.g., after receiving a delivery).  </li> <li>Save to update current inventory counts.</li> </ol>"},{"location":"08_Inventory/01_LowStock/#best-practices","title":"Best Practices","text":"<ul> <li>Review low-stock items at the start of each shift.  </li> <li>Update stock as soon as new items arrive.  </li> <li>Keep reorder points realistic\u2014too low creates risk, too high inflates spent budget.  </li> </ul> <p>TIP: Low-stock items often overlap with unmapped import issues. Always verify both.  </p>"},{"location":"08_Inventory/02_BulkAdd/","title":"Bulk Add Stock","text":"<p>The Bulk Add Stock tool allows you to add multiple stock entries in a single workflow. This is faster and more reliable than updating each ingredient individually.</p>"},{"location":"08_Inventory/02_BulkAdd/#how-to-use-bulk-add-stock","title":"How to Use Bulk Add Stock","text":"<ol> <li>Open the tool from the Inventory Dashboard or Dashboard Quick Actions.  </li> <li>Add a row for each ingredient you received.  </li> <li>Enter the quantity received and cost.  </li> <li>(Optional) Include notes (lot number, supplier, etc.).  </li> <li>Submit all entries at once.</li> </ol>"},{"location":"08_Inventory/02_BulkAdd/#behind-the-scenes","title":"Behind the Scenes","text":"<ul> <li>Each entry generates a StockEntry record.  </li> <li>The ingredient\u2019s current stock is recalculated.  </li> <li>Average cost is updated based on weighted inputs.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#when-to-use-bulk-add","title":"When to Use Bulk Add","text":"<ul> <li>Daily receiving  </li> <li>Weekly deliveries  </li> <li>Adjusting multiple items after inventory count  </li> <li>Updating costs after vendor price changes  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#troubleshooting","title":"Troubleshooting","text":""},{"location":"08_Inventory/02_BulkAdd/#stock-not-updating","title":"Stock Not Updating?","text":"<ul> <li>Ingredient may be archived.  </li> <li>Ensure units match the ingredient\u2019s defined UoM.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#average-cost-looks-wrong","title":"Average Cost Looks Wrong?","text":"<ul> <li>Check if a previous entry had incorrect cost.  </li> <li>Re-run bulk update with corrected values.  </li> </ul>"},{"location":"08_Inventory/02_BulkAdd/#duplicate-stock-entries","title":"Duplicate Stock Entries?","text":"<ul> <li>Confirm entries before submitting.  </li> <li>Use CSV Import for large structured updates.  </li> </ul>"},{"location":"08_Inventory/03_Overview/","title":"Inventory Dashboard Overview","text":"<p>The Inventory dashboard centralizes ingredient, recipe, and stock data so the team can spot shortages, track inflow/outflow, and make purchasing decisions without leaving the dashboard. It highlights current on\u2011hand amounts and links each row to the underlying recipes and modifiers that drive those totals.</p> <p>Two controls keep the workflow focused:</p> <ul> <li>Add Case: opens the modal that brings a new purchase case into the system, letting you specify the supplier, quantity, and cost while automatically updating linked inventory levels.</li> <li>Update Row: lets you refresh an existing entry when a quick adjustment is needed\u2014such as a count correction or unit conversion\u2014so the dashboard remains the single source of truth.</li> </ul> <p>Because the Inventory dashboard is HTMX-driven, each control applies its change instantly and rerenders the relevant partial, keeping the rest of the page responsive and in sync.</p>"},{"location":"09_Reporting/01_Reporting/","title":"Reporting","text":"<p>The Reporting module provides visibility into ingredient usage, cost of goods (COGS), inventory valuation, and operational insights across your caf\u00e9 or retail environment. These reports help managers make data\u2011driven decisions regarding purchasing, pricing, inventory, and recipe management.</p> <p>Reporting pulls from: - Ingredient records - Recipe structures - Inventory stock entries - Order histories - Square and Shopify imports  </p> <p>Accurate reporting depends on clean recipes, well\u2011maintained ingredients, and properly resolved imports.</p>"},{"location":"09_Reporting/02_UsageReports/","title":"Ingredient Usage Reports","text":"<p>Ingredient usage reports calculate how much of each ingredient has been consumed over a specific date range.</p>"},{"location":"09_Reporting/02_UsageReports/#how-usage-is-calculated","title":"How Usage Is Calculated","text":"<p>Usage is derived from: 1. Order data imported from Square and Shopify. 2. Recipe definitions, which determine ingredient quantities per product. 3. Scaling rules (for multiple product sizes). 4. Modifier adjustments (e.g., almond milk replacements).  </p> <p>For each order, the system multiplies: <code>ingredient quantity \u00d7 number of items sold \u00d7 size scaling</code></p>"},{"location":"09_Reporting/02_UsageReports/#use-cases","title":"Use Cases","text":"<ul> <li>Forecast purchasing needs  </li> <li>Identify high\u2011usage ingredients  </li> <li>Track cost changes over time  </li> <li>Validate recipe accuracy  </li> </ul> <p>TIP: Usage anomalies often indicate a mismatch in recipe scaling or modifier rules.</p>"},{"location":"09_Reporting/03_COGS/","title":"Cost of Goods Sold (COGS)","text":"<p>The COGS report provides estimated ingredient cost per product sold over time.</p>"},{"location":"09_Reporting/03_COGS/#how-cogs-is-computed","title":"How COGS Is Computed","text":"<ol> <li>Pull ingredient costs from the Inventory module  </li> <li>Apply recipe ingredient quantities  </li> <li>Apply size scaling  </li> <li>Add modifier cost effects  </li> <li>Aggregate totals across orders  </li> </ol>"},{"location":"09_Reporting/03_COGS/#why-cogs-matters","title":"Why COGS Matters","text":"<ul> <li>Helps refine menu pricing  </li> <li>Highlights low\u2011margin products  </li> <li>Identifies cost inefficiencies  </li> <li>Supports financial reporting  </li> </ul> <p>CAUTION: If ingredient costs are outdated, COGS results will be inaccurate. Update costs regularly.</p>"},{"location":"09_Reporting/04_InventoryValuation/","title":"Inventory Valuation","text":"<p>Inventory valuation reports show the monetary value of all active ingredients in stock.</p>"},{"location":"09_Reporting/04_InventoryValuation/#components-of-valuation","title":"Components of Valuation","text":"<ul> <li>Current stock quantity  </li> <li>Average cost per unit  </li> <li>Ingredient type and category  </li> </ul>"},{"location":"09_Reporting/04_InventoryValuation/#best-practices","title":"Best Practices","text":"<ul> <li>Run valuation reports monthly for financial accuracy  </li> <li>Use Bulk Add Stock to maintain stable cost calculations  </li> <li>Archive unused ingredients to simplify reporting  </li> </ul>"},{"location":"09_Reporting/05_ExportingReports/","title":"Exporting Reports (In Development)","text":"<p>The reporting dashboard is currently an interactive, on-screen experience. Views such as usage, COGS, and inventory snapshots re nder charts and cards that respond to the selected date window, but they do not provide CSV downloads yet.</p>"},{"location":"09_Reporting/05_ExportingReports/#current-workflow","title":"Current Workflow","text":"<ol> <li>Open the reporting dashboard.</li> <li>Adjust the date filters or presets to show the period you need.</li> <li>Review the widgets/cards directly in the browser.</li> </ol> <p>If you need to perform spreadsheet analysis, copy the on-screen values or take screenshots until CSV export endpoints are implem ented.</p>"},{"location":"09_Reporting/05_ExportingReports/#roadmap","title":"Roadmap","text":"<ul> <li>CSV export buttons will appear once dedicated download views are added to <code>mscrInventory/views/reporting.py</code>.</li> <li>When available, exports will include the same precision as the on-screen metrics (ingredient units, extended costs, etc.).</li> </ul>"},{"location":"10_manage_users/01_ManageUsers/","title":"Manage Users","text":"<p>The Manage Users section allows managers and administrators to create, update, and organize user accounts within the MSCR Inventory App. User roles determine access to recipes, inventory, reports, and administrative tools.</p> <p>This section centralizes: - New user creation - Updating user information - Assigning or changing permission groups - Reviewing account status (active, pending, archived)  </p> <p>Only users with elevated permissions (Manager or Admin) can access this area.</p>"},{"location":"10_manage_users/02_Permissions/","title":"Permission Groups","text":"<p>Permissions control what each user can see and do. Assign the appropriate group based on responsibilities.</p>"},{"location":"10_manage_users/02_Permissions/#available-permission-groups","title":"Available Permission Groups","text":""},{"location":"10_manage_users/02_Permissions/#admin","title":"Admin","text":"<ul> <li>Full system access  </li> <li>Can manage all data, users, imports, and Django Admin  </li> <li>Intended for technical staff or leadership  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#manager","title":"Manager","text":"<ul> <li>Nearly full access to the system  </li> <li>Can manage users, imports, inventory, and recipes  </li> <li>Limited access to developer-only Django Admin actions  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#barista","title":"Barista","text":"<ul> <li>View-only access for most areas  </li> <li>Can manage recipes, ingredients, and inventory  </li> <li>Cannot access: Reports, Manage Users, or Admin  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#inventory","title":"Inventory","text":"<ul> <li>Focused on stock management  </li> <li>Can adjust inventory and costs  </li> <li>Cannot access advanced reporting, user management, or Admin  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#pending","title":"Pending","text":"<ul> <li>Automatically assigned to newly created accounts  </li> <li>Must be elevated by a Manager before gaining access  </li> <li>Cannot perform any editing actions  </li> </ul>"},{"location":"10_manage_users/02_Permissions/#how-to-assign-permissions","title":"How to Assign Permissions","text":"<ol> <li>Go to Manage Users.  </li> <li>Select the user you want to update.  </li> <li>Choose the correct permission group from the dropdown.  </li> <li>Save changes.</li> </ol> <p>TIP: Keep at least one Admin and two Managers assigned at all times.</p>"},{"location":"11_Admin/01_Admin/","title":"Admin (Restricted Access)","text":"<p>The Admin section refers specifically to the Django Admin interface bundled with the MSCR Inventory App. This area provides direct access to the underlying database models and is intended only for trained Managers and Admins.</p> <p>Because changes made here bypass some of the safety checks and convenience tools in the main UI, access is intentionally limited.</p>"},{"location":"11_Admin/01_Admin/#what-you-can-do-in-the-admin-area","title":"What You Can Do in the Admin Area","text":"<p>The Django Admin exposes raw records for: - Ingredients - Products - Recipes - Recipe Modifiers - Ingredient Types - Stock Entries - Import Logs - Square Unmapped Items - Users and Groups (Permissions)</p> <p>From here you can: - Correct data inconsistencies - Perform bulk edits not yet supported in the main interface - Review historical logs - Diagnose issues during import reconciliation - Inspect raw relationships between objects  </p>"},{"location":"11_Admin/01_Admin/#when-to-use-django-admin","title":"When to Use Django Admin","text":"<p>Use Admin for: - Troubleshooting unusual data inconsistencies - Cleaning up legacy entries - Reviewing unmapped items directly - Viewing ImportLog objects and raw CSV storage - Quick data inspection during development or QA  </p> <p>Avoid using Admin for: - Day\u2011to\u2011day ingredient or recipe updates - Product creation - Inventory adjustments - User creation (use Manage Users instead)</p>"},{"location":"11_Admin/01_Admin/#safety-notes","title":"Safety Notes","text":"<p>WARNING: Actions taken in Django Admin update the database immediately and permanently.</p> <p>To ensure data integrity:</p> <ul> <li>Do not delete ingredients or recipes that appear in orders or imports  </li> <li>Avoid editing primary keys or relational links unless you fully understand downstream effects  </li> <li>Use Archive instead of Delete wherever possible  </li> <li>Double\u2011check ingredient type, units, and cost fields before saving  </li> <li>Review all changes in the main UI after editing records in Admin</li> </ul>"},{"location":"11_Admin/01_Admin/#access-requirements","title":"Access Requirements","text":"<p>Only users in the following groups may access Admin:</p> <ul> <li>Admin: Full access  </li> <li>Manager: Limited, read\u2011oriented access depending on configuration  </li> </ul> <p>Barista, Inventory, and Pending users cannot enter the Django Admin interface.</p>"},{"location":"11_Admin/01_Admin/#troubleshooting","title":"Troubleshooting","text":""},{"location":"11_Admin/01_Admin/#access-denied","title":"Access Denied?","text":"<ul> <li>Ensure your user account is assigned to Admin or Manager.</li> <li>Reload the page after permissions update.</li> <li>Log out and back in if the session does not refresh.</li> </ul>"},{"location":"11_Admin/01_Admin/#changes-not-appearing-in-main-ui","title":"Changes Not Appearing in Main UI?","text":"<ul> <li>Some cached views require reload.</li> <li>Verify your edits match expected model fields.</li> <li>Inspect ImportLog or ingredient relationships if mappings seem incorrect.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/","title":"Appendix A \u2013 Manual Testing","text":""},{"location":"12_Appendix_A_Testing/01_ManualTests/#manual-test-plan","title":"Manual Test Plan","text":"<p>Use this as a high-level smoke/regression checklist. Unless otherwise noted, start from a fresh <code>python manage.py migrate</code> + demo data and remain logged in as a user with edit permissions.</p>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#authentication-session-guardrails","title":"Authentication &amp; Session Guardrails","text":"<ul> <li>Log out, visit <code>/recipes/</code>, and confirm you are redirected to the login page; then log in and ensure you return to the requested URL.</li> <li>Attempt to POST to an HTMX endpoint (e.g., add ingredient to a recipe) while logged out; verify a 403 response with the expected \u201cForbidden\u201d message.</li> <li>Confirm permission scoping: a user with <code>view_recipemodifier</code> but no ingredient permissions can open Modifier Explorer but cannot edit ingredients or save aliases.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#dashboard-overview","title":"Dashboard Overview (<code>/</code>)","text":"<ul> <li>Widgets populate: Active Products, Tracked Ingredients, Recent Imports, Recent Changes, Top Name-Your-Drink, Recent Warnings, Shortcuts, Quick Add/Import cards.</li> <li>Low stock + import failures raise warnings: create an ingredient below its reorder point and a failed import log, reload, and confirm both warnings appear.</li> <li>\u201cTop Name-Your-Drink\u201d tile links to orders search (URL contains <code>orders/?preset=</code>) and shows at least one named drink entry.</li> <li>Recent imports tile shows unmatched Square items when present.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#orders-dashboard-orders","title":"Orders Dashboard (<code>/orders/</code>)","text":"<ul> <li>Default preset is 14 days and combines Square + Shopify orders.</li> <li>Platform filter: selecting Shopify hides Square orders; switching back restores both.</li> <li>Custom date range: choose preset \u201cCustom,\u201d set a start/end window that includes only mid-range orders, and verify only those appear; banner should note the custom window.</li> <li>Pagination: load with &gt;25 orders, verify page 1 has 25, navigate to page 2 and confirm querystring retains filters.</li> <li>Open any order row and confirm <code>total_items</code> annotation equals the sum of item quantities.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#recipes-dashboard-recipes","title":"Recipes Dashboard (<code>/recipes/</code>)","text":"<ul> <li>Grid renders columns including product temperature. Search for \u201cmilk\u201d and confirm matches bubble to the top while categories collapse appropriately.</li> <li>Edit modal opens from \u201cEdit\u201d and lists all ingredients with current quantities and units.</li> <li>Add an ingredient: choose from dropdown, enter quantity, click <code>+</code>; ingredient row appears immediately via HTMX without full page reload.</li> <li>Delete an ingredient: click \u2715, accept confirmation, and ensure the row disappears instantly.</li> <li>Extend recipe: pick a base recipe in the modal, submit, and confirm ingredients clone into the current recipe.</li> <li>Live-reload: while server running, edit a template referenced by the page and verify auto-refresh.</li> <li>CSRF handling: repeat an add/delete while logged out to confirm safe 403 responses (no partial writes).</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#recipe-csv-exportimport","title":"Recipe CSV Export/Import","text":"<ul> <li>Export CSV: click \u201c\ud83d\udce4 Export Recipes CSV,\u201d open the file, and confirm each product appears once per ingredient with category name and COGS subtotal columns populated.</li> <li>Import (two-step modal if enabled): upload a CSV with valid + invalid rows, run dry-run, confirm invalid rows are reported without DB writes; rerun without dry-run to commit and verify recipe grid updates.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#modifier-explorer-modifier-explorer","title":"Modifier Explorer (<code>/modifier-explorer/</code>)","text":"<ul> <li>Load page with a <code>view_recipemodifier</code> user; confirm sections for Known, Alias token, Fuzzy, Unknown, and co-occurrence pairs.</li> <li>Classification filter: choose \u201cUnknown\u201d and verify matching products are hidden with a \u201cHiding N matching product(s)\u201d banner; toggle \u201cinclude known products\u201d to reveal matches.</li> <li>Alias management: for an alias row, pick a mapped modifier from the select box and save; confirm selection persists after refresh.</li> <li>CSV export: load with sample data and request <code>?format=csv</code>; verify the response downloads with header containing <code>alias_label</code> and rows for each modifier insight.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#inventory-management","title":"Inventory Management","text":"<ul> <li>Bulk Add modal: open from inventory dashboard, add multiple stock entries, submit, and confirm StockEntry records and current stock totals update correctly.</li> <li>Inventory CSV export: trigger export, open file, and confirm ingredients, quantities, costs, and units are present.</li> <li>Inventory CSV import: upload a modified CSV, run in dry-run to view summary and validation errors, then import for real and check ingredient quantities and average cost adjustments reflect the file.</li> <li>Reorder point alert: set an ingredient below reorder level and ensure it appears in dashboard warnings and any \u201cInventory running low\u201d lists.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#imports-dashboard-squareshopify-integration","title":"Imports Dashboard &amp; Square/Shopify Integration","text":"<ul> <li>Square CSV upload: submit a sample file with \u201cDry run\u201d checked; expect redirect to imports dashboard, creation of a <code>square</code> ImportLog marked <code>dry-run</code>, stored file name ending in <code>-square.csv</code>, and buffered output displayed in the log detail.</li> <li>Secure temp file handling: verify uploaded Square CSV is stored in the configured <code>squareCSVs/</code> directory and removed after processing when appropriate.</li> <li>Unmapped Square items: after a Square import containing unknown items, open the \u201cUnmapped items\u201d tab, link an item to an existing product via \u201cLink existing,\u201d then create a new product using \u201cCreate from unmapped\u201d; ensure mappings persist and import warnings decrease.</li> <li>Shopify sync/dry-run (if enabled): run the import or dry-run flow and confirm ImportLog captures run type, counts, and any unmatched items; verify no DB writes on dry-run.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#reporting-analytics","title":"Reporting &amp; Analytics","text":"<ul> <li>Ingredient usage aggregation: trigger the report that rolls up ingredient usage across recipes/orders and confirm totals match expected counts.</li> <li>Dashboard metrics: verify calculated COGS and metric cards update after adjusting ingredient costs or recipe quantities.</li> <li>Export inventory/recipe/usage reports to CSV and ensure numerical columns retain precision (e.g., Decimal costs).</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#admin-user-management","title":"Admin &amp; User Management","text":"<ul> <li>Admin access: log in as superuser, open Django admin, and confirm core models (Ingredient, Product, Recipe, RecipeModifier, ImportLog, Order) are visible.</li> <li>Permission enforcement: create a user without <code>change_ingredient</code> and confirm edit/delete buttons disappear while view-only pages still load.</li> <li>User creation: add a new user through the app\u2019s user management flow, set a password, and verify login/logout works.</li> </ul>"},{"location":"12_Appendix_A_Testing/01_ManualTests/#permissions-testing","title":"Permissions Testing","text":"Group Can View Can Add/Edit Can Import Can Export Can Access /admin Can Delete Superuser \u2705 \u2705 \u2705 \u2705 \u2705 \u2705 Manager \u2705 \u2705 \u2705 \u2705 \u2705 \u274c Barista \u2705 \u2705 (recipes, mods, ingredients, inventory) \u274c \u274c \u274c \u274c Inventory \u2705 (inventory only) \u2705 (inventory) \u274c \u274c \u274c \u274c"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/","title":"Appendix B \u2013 Unmapped Items Usage","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#overview","title":"Overview","text":"<p>Unmapped items are created when SquareImporter or ShopifyImporter cannot associate an incoming row with an existing product, ingredient, or modifier. This system is designed not only to catch inconsistencies in imports, but also to intelligently retain history and prevent duplicates.</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#unmapped-item-flow","title":"Unmapped-Item Flow","text":"<p>The importer performs the following steps:</p> <ol> <li>Initialize a fresh run state</li> <li>Each import session maintains a per-run log and counters.</li> <li>All tracking resets at the start of each file.</li> <li> <p>When <code>dry_run=True</code>, all writes are rolled back, but the importer still performs all matching logic and logging.</p> </li> <li> <p>Row processing</p> </li> <li>Each row is logged with contextual details.</li> <li>The importer calls <code>_find_best_product_match</code>.</li> <li> <p>If no match is found, the system funnels into <code>_record_unmapped_item</code>.</p> </li> <li> <p>Price-point and shell item handling</p> </li> <li>Generic menu shells such as \u201cBarista\u2019s Choice\u201d are treated as unmatched unless pricing clarifies the intended product.</li> <li> <p>Seasonal or experimental variations properly surface as unmapped.</p> </li> <li> <p>Recording the unmapped item</p> </li> <li>The importer normalizes its item/price-point pair.</li> <li>Deduping occurs at both the per-run level and persistent DB level.</li> <li>On live imports, normalization keys are used with <code>get_or_create</code> to avoid duplicates.</li> <li> <p>Reappearances update:</p> <ul> <li><code>last_seen</code></li> <li><code>seen_count</code></li> <li>captured modifiers</li> <li>resolution status</li> </ul> </li> <li> <p>Reopening resolved entries</p> </li> <li>If an item previously resolved appears again with new context, the importer may reopen it rather than create a new entry.</li> <li>This keeps history tidy but complete.</li> </ol>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#data-model-persistence","title":"Data Model &amp; Persistence","text":"<p><code>SquareUnmappedItem</code> includes:</p> <ul> <li>Source (Square/Shopify)</li> <li>Item type (Product, Ingredient, Modifier)</li> <li>Raw label values</li> <li>Normalized keys (for grouping)</li> <li>Snapshot of applied modifiers</li> <li>Reason for unmapped status</li> <li>Timestamps (<code>first_seen</code>, <code>last_seen</code>)</li> <li>Occurrence count</li> <li>Resolution metadata:</li> <li>ignored status</li> <li>link to actual Product/Ingredient/Modifier (if resolved)</li> </ul> <p>Uniqueness constraint: One row per normalized item/variant ensures no duplicates are created.</p> <p>Helper methods encapsulate: - resolving - reopening - ignoring - normalization logic</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#dashboard-modal-experience","title":"Dashboard &amp; Modal Experience","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#dashboard-behavior","title":"Dashboard Behavior","text":"<ul> <li>The Imports dashboard shows a warning button displaying the number of unresolved items.</li> <li>If no unmapped items exist, an \u201cAll items mapped\u201d indicator is displayed.</li> </ul>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#modal-and-full-dashboard","title":"Modal and Full Dashboard","text":"<p>The same underlying view powers: - the lightweight HTMX modal - the full-page dashboard at <code>/dashboard/unmapped/</code></p> <p>These views include: - filter controls - per-item actions - create/link forms - pagination (for full view)</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#modal-features","title":"Modal Features","text":"<ul> <li>Quick summary of unresolved items</li> <li>Inline link/create forms</li> <li>\u201cView Full Dashboard\u201d for bulk actions or extended review</li> </ul>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#table-output","title":"Table Output","text":"<p>The shared table partial includes: - Source - Type - Raw Name - First/Last Seen - Occurrences - Actions (Link, Create, Ignore)</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#mapping-actions-validation","title":"Mapping Actions &amp; Validation","text":""},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#linking","title":"Linking","text":"<p><code>LinkUnmappedItemForm</code> allows associating an item with: - existing product - existing ingredient - existing modifier  </p> <p>Upon save: - <code>mark_resolved</code> is called - updated metadata is returned - the dashboard refreshes via HTMX</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#creating-new-items","title":"Creating New Items","text":"<p><code>CreateFromUnmappedItemForm</code>: - tailors fields based on item type - generates default SKUs when needed - handles IntegrityErrors gracefully   - duplicate names trigger user-friendly validation messages</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#bulk-actions","title":"Bulk Actions","text":"<p>Bulk modes allow staff to: - resolve all filtered items - ignore all filtered items - create placeholder records for batches</p> <p>Bulk actions reuse: - SKU generation helpers - <code>get_or_create</code> for ingredients - shared validation logic</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#admin-coverage","title":"Admin &amp; Coverage","text":"<p>In Django Admin, staff can view: - All unmapped items - Filters (source, type, ignored/resolved) - Read-only historical fields - Link/autocomplete relationships - Custom admin actions:   - resolve   - ignore   - reopen</p> <p>ImportLog objects also include: - summary previews - stored file metadata - associated warnings</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#regression-test-coverage","title":"Regression Test Coverage","text":"<p>Automated tests include: - dry-run safety - handling variant unmapped items - idempotent re-runs - deduping behavior - modal rendering - full-page dashboard output - bulk creation flows - upload logging - integration with ImportLog and related models</p> <p>This ensures stable behavior across updates.</p>"},{"location":"13_Appendix_B_Unmapped_Items_Usage/01_UnmappedUsage/#expected-behavior-recap","title":"Expected Behavior Recap","text":"<ol> <li>Run a Square import (use a Dry Run first).</li> <li>Rows that cannot be matched become unmapped.</li> <li>Live runs update:</li> <li>occurrence count</li> <li>timestamps</li> <li>reopened vs. newly created entries</li> <li>Staff review unmapped items using modal or dashboard.</li> <li>Items are resolved by:</li> <li>linking</li> <li>creating a new record</li> <li>marking as ignored</li> <li>Bulk actions support efficient cleanup.</li> <li>Admin provides a fallback UI for deeper workflow management.</li> </ol> <p>Unmapped items ensure that all Square/Shopify data ultimately maps to a clean, unified dataset in the inventory system.</p>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/","title":"Appendix C \u2013 Inventory Management Platform Comparison","text":"<p>This appendix compares mscrInventory to major commercial inventory platforms used in caf\u00e9s and retail environments. It highlights strengths, limitations, pricing expectations, and unique differentiators.</p>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#options-at-a-glance","title":"Options at a Glance","text":"Platform Strengths Limitations Typical Pricing Thrive Simple, lightweight, good for small caf\u00e9s Limited advanced analytics $$ MarketMan Vendor management, invoice scanning, multi\u2011location tools Complex setup, higher cost $$$$ MarginEdge Strong financial reporting, invoice processing Less granular ingredient modeling $$$$ BevSpot Excellent for beverage cost tracking Not food\u2011focused, limited recipe depth $$$ mscrInventory Fully customizable, relational recipe system, integrated Square/Shopify imports DIY hosting/maintenance, requires initial setup $ (self\u2011hosted)"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#detailed-comparison","title":"Detailed Comparison","text":""},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#thrive","title":"Thrive","text":"<ul> <li>Good for smaller operations  </li> <li>Simple stock workflows  </li> <li>Limited visibility into recipe\u2011level cost structures  </li> <li>Lacks advanced import reconciliation tools  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#marketman","title":"MarketMan","text":"<ul> <li>Great vendor and purchasing modules  </li> <li>Automated invoice scanning  </li> <li>Robust multi\u2011unit controls  </li> <li>High subscription costs  </li> <li>Requires adaptation to MarketMan\u2019s data modeling  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#marginedge","title":"MarginEdge","text":"<ul> <li>Finance\u2011driven system powering COGS and AP workflows  </li> <li>Strong invoice uploading and accounting integrations  </li> <li>Recipe modeling is functional but less flexible  </li> <li>Not designed for granular ingredient/packaging tracking  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#bevspot","title":"BevSpot","text":"<ul> <li>Beverage\u2011oriented inventory  </li> <li>Solid for bars or drink\u2011forward businesses  </li> <li>Recipe and food tracking minimal  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#mscrinventory","title":"mscrInventory","text":"<ul> <li>Fully relational ingredient \u2192 recipe \u2192 product workflow  </li> <li>Deep Square/Shopify integration  </li> <li>Clean UI with HTMX responsiveness  </li> <li>Does not require third\u2011party vendor onboarding  </li> <li>Agile and customizable for non\u2011standard workflows  </li> <li>Extremely low cost for long\u2011term maintenance  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#why-mscrinventory","title":"Why mscrInventory?","text":"<ol> <li>Direct control \u2014 tailor recipes, ingredients, and modifiers exactly to your menu.  </li> <li>Integrated parsing logic \u2014 Square and Shopify naming differences are handled gracefully.  </li> <li>Deep relational modeling \u2014 packaging, recipes, modifiers, and inventory map tightly.  </li> <li>Transparent pricing \u2014 no subscription required for self\u2011hosted deployments.  </li> <li>Operational clarity \u2014 clean dashboards, unmapped item workflows, and powerful filters.</li> </ol>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#when-to-choose-a-commercial-tool-instead","title":"When to Choose a Commercial Tool Instead","text":"<ul> <li>If you require automated invoice OCR (MarketMan, MarginEdge).  </li> <li>If you have multi\u2011unit corporate purchasing teams needing standardized PO systems.  </li> <li>If accounting/AP is your primary goal rather than recipe accuracy.  </li> </ul>"},{"location":"14_Appendix_C_Comparison_Review/01_Comparison/#summary","title":"Summary","text":"<p>mscrInventory excels in: - caf\u00e9s with custom drink workflows - environments with many modifiers or seasonal items - teams that want direct control over ingredients and recipes - operations where cost and accuracy matter more than big\u2011vendor ecosystems  </p> <p>Commercial platforms may excel for: - large multi\u2011unit operations - accounting\u2011heavy workflows - organizations needing AP automation  </p> <p>Each option suits different needs, but mscrInventory offers exceptional flexibility, cost savings, and precision for ingredient\u2011driven caf\u00e9s.</p>"},{"location":"15_roadmap/01_Roadmap/","title":"Future Roadmap","text":"<p>The MSCR Inventory App continues to evolve based on operational needs, user feedback, and integration opportunities. This roadmap outlines major upcoming features, improvements, and long\u2011term goals.</p>"},{"location":"15_roadmap/01_Roadmap/#near-term-roadmap-high-priority","title":"Near-Term Roadmap (High Priority)","text":""},{"location":"15_roadmap/01_Roadmap/#direct-doordash-integration","title":"Direct DoorDash Integration","text":"<ul> <li>Replace the \u201cvia Square\u201d workflow with native DoorDash API sync.</li> <li>Support menu import, modifier synchronization, and order ingestion.</li> <li>Reduce unmapped items from DoorDash-specific naming.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#square-api-integration","title":"Square API Integration","text":"<ul> <li>Move beyond CSV uploads for Square.</li> <li>Real\u2011time or scheduled syncing for:</li> <li>Orders  </li> <li>Menu items  </li> <li>Modifiers  </li> <li>Categories  </li> <li>More accurate variant and price\u2011point mapping.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#improved-reporting","title":"Improved Reporting","text":"<ul> <li>Expanded dashboard widgets with:</li> <li>Category-level COGS  </li> <li>Supplier-level valuations  </li> <li>Trend lines over time  </li> <li>Multi-location aggregator support (if needed later).</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#automatedscheduled-syncing","title":"Automated/Scheduled Syncing","text":"<ul> <li>Nightly sync jobs for Square/Shopify imports.</li> <li>Optional \u201cauto\u2011map safe matches\u201d mode.</li> <li>Email-based import summaries.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#mid-term-roadmap-planned-enhancements","title":"Mid-Term Roadmap (Planned Enhancements)","text":""},{"location":"15_roadmap/01_Roadmap/#email-logs-stock-alerts","title":"Email Logs &amp; Stock Alerts","text":"<ul> <li>Low-stock warnings sent to managers.</li> <li>Import error summaries delivered automatically.</li> <li>Optional \u201cdaily operations digest.\u201d</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#vendor-automation-support","title":"Vendor Automation Support","text":"<ul> <li>Integrate cost updates from vendor CSVs.</li> <li>Auto-create purchase suggestions:</li> <li>Based on usage trends  </li> <li>Based on minimum reorder points  </li> <li>Future potential: direct purchase\u2011order workflow.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#enhanced-inventory-tools","title":"Enhanced Inventory Tools","text":"<ul> <li>Multi-location stock separation.</li> <li>Batch SKU assignment tools.</li> <li>Richer packaging logic for combination items.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#long-term-vision","title":"Long-Term Vision","text":""},{"location":"15_roadmap/01_Roadmap/#fully-automated-operations-loop","title":"Fully Automated Operations Loop","text":"<ul> <li>Orders \u2192 Usage \u2192 Purchasing \u2192 Replenishment  </li> <li>True closed-loop forecasting and inventory control.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#crossplatform-menu-intelligence","title":"Cross\u2011Platform Menu Intelligence","text":"<ul> <li>Unified menu detection across Square, Shopify, DoorDash, and others.</li> <li>Modifier frequency analysis for recipe optimization.</li> <li>Support for predictive seasonal planning.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#deep-analytics-portal","title":"Deep Analytics Portal","text":"<ul> <li>Advanced dashboards for:</li> <li>Profitability  </li> <li>Ingredient volatility  </li> <li>Labor x ingredient cost modeling  </li> <li>Export-friendly BI data layers.</li> </ul>"},{"location":"15_roadmap/01_Roadmap/#development-philosophy","title":"Development Philosophy","text":"<p>The project continues to follow these principles:</p> <ul> <li> <p>Minimal Dependencies   Simple, stable, maintainable tech stack.</p> </li> <li> <p>Human-Centric Workflows   Designed for baristas, supervisors, and managers\u2014not engineers.</p> </li> <li> <p>Transparent Operations   CSV import/export always available as a fallback or manual override.</p> </li> <li> <p>Incremental Enhancements   Each release focuses on refining the real workflows used daily.</p> </li> </ul>"},{"location":"15_roadmap/01_Roadmap/#summary","title":"Summary","text":"<p>The MSCR Inventory App aims to provide: - A deeply reliable inventory and recipe system - Dead-simple daily workflows - Strong integrations - Extremely low long-term cost - Flexibility for any caf\u00e9 or specialty drinks environment  </p> <p>This roadmap ensures that the system continues improving while preserving its core strengths: accuracy, clarity, and efficiency.</p>"},{"location":"16_API/","title":"API Reference","text":"<p>This section documents the internal Python modules that power the MSCR Inventory App.</p> <p>All pages auto-generate content from the actual source code using <code>mkdocstrings</code>.</p>"},{"location":"16_API/#available-modules","title":"Available Modules","text":"<ul> <li>Models</li> <li>Views</li> <li>Admin</li> <li>Forms</li> <li>Importers</li> <li>Management Commands</li> <li>Utilities</li> </ul>"},{"location":"16_API/admin/","title":"Admin API","text":"<p>import docs.django_setup </p> <p>Admin customizations for managing inventory, recipes, and imports.</p>"},{"location":"16_API/admin/#mscrInventory.admin.CategoryAdmin","title":"<code>CategoryAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Basic admin listing for taxonomy categories.</p>"},{"location":"16_API/admin/#mscrInventory.admin.ContainerTypeAdmin","title":"<code>ContainerTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>CRUD interface for reusable container definitions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.ImportLogAdmin","title":"<code>ImportLogAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Show high-level stats for each import run.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientAdmin","title":"<code>IngredientAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Main ingredient admin including stock history and inline helpers.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientTypeAdmin","title":"<code>IngredientTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage ingredient type classifications.</p>"},{"location":"16_API/admin/#mscrInventory.admin.IngredientUsageLogAdmin","title":"<code>IngredientUsageLogAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Expose aggregated usage rows for auditing deductions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderAdmin","title":"<code>OrderAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Expose imported orders with related line items.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderItemAdmin","title":"<code>OrderItemAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Allow inspection of imported order items independently.</p>"},{"location":"16_API/admin/#mscrInventory.admin.OrderItemInline","title":"<code>OrderItemInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Show associated order items under an Order.</p>"},{"location":"16_API/admin/#mscrInventory.admin.PackagingInline","title":"<code>PackagingInline</code>","text":"<p>               Bases: <code>StackedInline</code></p> <p>Allow packaging metadata to be edited alongside an Ingredient.</p>"},{"location":"16_API/admin/#mscrInventory.admin.PackagingInline.filter_horizontal","title":"<code>filter_horizontal = ('expands_to',)</code>  <code>class-attribute</code> <code>instance-attribute</code>","text":"<p>def formfield_for_manytomany(self, db_field, request, *kwargs): if db_field.name == \"expands_to\":     kwargs[\"queryset\"] = Packaging.objects.all() return super().formfield_for_manytomany(db_field, request, *kwargs)</p>"},{"location":"16_API/admin/#mscrInventory.admin.ProductAdmin","title":"<code>ProductAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Product admin with inline recipe rows and modifier chooser.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeItemInline","title":"<code>RecipeItemInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Allow recipe items to be edited inline on the product page.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeModifierAdmin","title":"<code>RecipeModifierAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Admin panel for curated modifier catalog.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RecipeModifierAliasInline","title":"<code>RecipeModifierAliasInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Inline editing for alias rows beneath a modifier.</p>"},{"location":"16_API/admin/#mscrInventory.admin.RoastProfileInline","title":"<code>RoastProfileInline</code>","text":"<p>               Bases: <code>StackedInline</code></p> <p>Inline editor for roast profile attributes on roast ingredients.</p>"},{"location":"16_API/admin/#mscrInventory.admin.SizeLabelAdmin","title":"<code>SizeLabelAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage the display names for packaging size labels.</p>"},{"location":"16_API/admin/#mscrInventory.admin.SquareUnmappedItemAdmin","title":"<code>SquareUnmappedItemAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Front-end to resolve unmapped Square items.</p>"},{"location":"16_API/admin/#mscrInventory.admin.StockEntryAdmin","title":"<code>StockEntryAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Read-only dashboard for verifying stock additions.</p>"},{"location":"16_API/admin/#mscrInventory.admin.StockEntryInline","title":"<code>StockEntryInline</code>","text":"<p>               Bases: <code>TabularInline</code></p> <p>Display historical stock entries on the ingredient detail page.</p>"},{"location":"16_API/admin/#mscrInventory.admin.UnitTypeAdmin","title":"<code>UnitTypeAdmin</code>","text":"<p>               Bases: <code>ModelAdmin</code></p> <p>Manage measurement units and conversion ratios.</p>"},{"location":"16_API/admin/#mscrInventory.admin.UnmappedProductFilter","title":"<code>UnmappedProductFilter</code>","text":"<p>               Bases: <code>SimpleListFilter</code></p> <p>Filter that separates mapped vs unmapped placeholder products.</p>"},{"location":"16_API/forms/","title":"Forms API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized </p> <p>Forms for managing catalog, inventory, and unmapped Square data.</p>"},{"location":"16_API/forms/#mscrInventory.forms.CreateFromUnmappedItemForm","title":"<code>CreateFromUnmappedItemForm(*args, item, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Create a new record directly from an unmapped entry.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, item: SquareUnmappedItem, **kwargs):\n    self.item = item\n    super().__init__(*args, **kwargs)\n\n    self.is_known_recipe = bool(getattr(item, \"is_known_recipe\", False))\n    self.effective_item_type = \"product\" if self.is_known_recipe else item.item_type\n\n    # Initialise defaults from the unmapped item\n    self.fields[\"name\"].initial = item.price_point_name or item.item_name\n    self.fields[\"filter_type\"].initial = kwargs.get(\"initial\", {}).get(\"filter_type\")\n\n    if self.effective_item_type == \"product\":\n        self.fields[\"sku\"].required = False\n        self.fields[\"sku\"].initial = self._generate_default_sku(item)\n    else:\n        self.fields.pop(\"sku\")\n\n    if self.effective_item_type == \"ingredient\":\n        self.fields[\"ingredient_type\"].required = False\n    else:\n        self.fields.pop(\"ingredient_type\")\n\n    if self.effective_item_type == \"modifier\":\n        self.fields[\"modifier_ingredient\"].required = True\n        self.fields[\"behavior\"].required = True\n        self.fields[\"behavior\"].initial = RecipeModifier.ModifierBehavior.ADD\n        self.fields[\"base_quantity\"].required = True\n        self.fields[\"unit\"].required = True\n    else:\n        for field in (\n            \"modifier_ingredient\",\n            \"modifier_type\",\n            \"behavior\",\n            \"base_quantity\",\n            \"unit\",\n        ):\n            self.fields.pop(field)\n\n    for name, field in self.fields.items():\n        if name == \"filter_type\":\n            continue\n        css_class = \"form-select\" if isinstance(field.widget, forms.Select) else \"form-control\"\n        field.widget.attrs.setdefault(\"class\", css_class)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm","title":"<code>IngredientForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Primary form for creating or editing Ingredient records.</p> <p>Apply consistent Bootstrap styling to all fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    \"\"\"Apply consistent Bootstrap styling to all fields.\"\"\"\n    super().__init__(*args, **kwargs)\n    for field_name, field in self.fields.items():\n        widget = field.widget\n        existing = widget.attrs.get(\"class\", \"\")\n        widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n        widget.attrs.setdefault(\"autocomplete\", \"off\")\n        if isinstance(widget, forms.Textarea):\n            widget.attrs.setdefault(\"rows\", 3)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm.requires_packaging_fields","title":"<code>requires_packaging_fields(type_obj)</code>  <code>classmethod</code>","text":"<p>Return True when packaging-specific fields should be shown.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>@classmethod\ndef requires_packaging_fields(cls, type_obj) -&gt; bool:\n    \"\"\"Return True when packaging-specific fields should be shown.\"\"\"\n    return cls._requires_type(type_obj, cls.PACKAGING_TYPE_NAMES)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.IngredientForm.requires_roast_fields","title":"<code>requires_roast_fields(type_obj)</code>  <code>classmethod</code>","text":"<p>Return True when roast-specific fields should be shown.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>@classmethod\ndef requires_roast_fields(cls, type_obj) -&gt; bool:\n    \"\"\"Return True when roast-specific fields should be shown.\"\"\"\n    return cls._requires_type(type_obj, cls.ROAST_TYPE_NAMES)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.LinkUnmappedItemForm","title":"<code>LinkUnmappedItemForm(*args, item, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Resolve an unmapped item by linking to an existing record.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, item: SquareUnmappedItem, **kwargs):\n    self.item = item\n    super().__init__(*args, **kwargs)\n\n    field_kwargs = {\"required\": True}\n    if getattr(item, \"is_known_recipe\", False):\n        field_kwargs[\"queryset\"] = Product.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Product\"\n    elif item.item_type == \"product\":\n        field_kwargs[\"queryset\"] = Product.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Product\"\n    elif item.item_type == \"ingredient\":\n        field_kwargs[\"queryset\"] = Ingredient.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Ingredient\"\n    else:\n        field_kwargs[\"queryset\"] = RecipeModifier.objects.order_by(\"name\")\n        field_kwargs[\"label\"] = \"Modifier\"\n\n    self.fields[\"target\"] = forms.ModelChoiceField(**field_kwargs)\n    css_class = \"form-select\" if isinstance(self.fields[\"target\"].widget, forms.Select) else \"form-control\"\n    self.fields[\"target\"].widget.attrs.setdefault(\"class\", css_class)\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PackagingForm","title":"<code>PackagingForm(*args, ingredient=None, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Collect packaging preferences for a given Ingredient.</p> <p>Pre-populate with saved Packaging data and style widgets.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, ingredient: Ingredient | None = None, **kwargs):\n    \"\"\"Pre-populate with saved Packaging data and style widgets.\"\"\"\n    super().__init__(*args, **kwargs)\n    packaging = None\n    if ingredient:\n        try:\n            packaging = ingredient.packaging\n        except Packaging.DoesNotExist:\n            packaging = None\n        expands_field = self.fields.get(\"expands_to\")\n        if expands_field is not None:\n            expands_field.queryset = expands_field.queryset.exclude(pk=ingredient.pk)\n\n    if not self.is_bound and packaging:\n        self.initial.setdefault(\"container\", packaging.container_id)\n        self.initial.setdefault(\"temp\", packaging.temp)\n        self.initial.setdefault(\"multiplier\", packaging.multiplier)\n        self.initial.setdefault(\n            \"size_labels\",\n            list(packaging.size_labels.values_list(\"pk\", flat=True)),\n        )\n        self.initial.setdefault(\n            \"expands_to\",\n            list(packaging.expands_to.values_list(\"pk\", flat=True)),\n        )\n\n    for field_name, field in self.fields.items():\n        widget = field.widget\n        existing = widget.attrs.get(\"class\", \"\")\n        if isinstance(field, forms.ModelMultipleChoiceField):\n            widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n            widget.attrs.setdefault(\"multiple\", True)\n            widget.attrs.setdefault(\"size\", 4)\n        elif isinstance(field, forms.ModelChoiceField) or isinstance(field, forms.ChoiceField):\n            widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n        else:\n            widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm","title":"<code>ProductForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Bootstrap-friendly CRUD form for Product records.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n\n    for field_name, field in self.fields.items():\n        if field_name == \"categories\":\n            field.widget = forms.SelectMultiple(attrs={\"class\": \"form-select\", \"size\": 6})\n        else:\n            existing = field.widget.attrs.get(\"class\", \"\")\n            field.widget.attrs[\"class\"] = (existing + \" form-control\").strip()\n        field.widget.attrs.setdefault(\"autocomplete\", \"off\")\n\n        if self.is_bound and field_name in self.errors:\n            css = field.widget.attrs.get(\"class\", \"\")\n            field.widget.attrs[\"class\"] = f\"{css} is-invalid\".strip()\n\n    self.fields[\"sku\"].required = False\n    self.fields[\"shopify_id\"].required = False\n    self.fields[\"square_id\"].required = False\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.clean_name","title":"<code>clean_name()</code>","text":"<p>Normalize whitespace around the submitted name.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean_name(self):\n    \"\"\"Normalize whitespace around the submitted name.\"\"\"\n    return (self.cleaned_data.get(\"name\") or \"\").strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.clean_sku","title":"<code>clean_sku()</code>","text":"<p>Ensure the SKU is unique and auto-generate one if omitted.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean_sku(self):\n    \"\"\"Ensure the SKU is unique and auto-generate one if omitted.\"\"\"\n    sku = (self.cleaned_data.get(\"sku\") or \"\").strip()\n\n    qs = Product.objects.all()\n    if self.instance.pk:\n        qs = qs.exclude(pk=self.instance.pk)\n\n    if not sku:\n        base_name = self.cleaned_data.get(\"name\") or getattr(self.instance, \"name\", \"\")\n        base_name = (base_name or \"product\").strip()\n\n        while True:\n            sku = generate_auto_sku(base_name)\n            if not qs.filter(sku__iexact=sku).exists():\n                break\n    else:\n        if qs.filter(sku__iexact=sku).exists():\n            raise forms.ValidationError(\"A product with this SKU already exists.\")\n\n    return sku\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.ProductForm.save","title":"<code>save(commit=True)</code>","text":"<p>Persist the product while normalizing key text fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Persist the product while normalizing key text fields.\"\"\"\n    instance = super().save(commit=False)\n    instance.name = (self.cleaned_data.get(\"name\") or \"\").strip()\n    instance.sku = (self.cleaned_data.get(\"sku\") or \"\").strip()\n    if commit:\n        instance.save()\n        self.save_m2m()\n    return instance\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm","title":"<code>PublicUserCreateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Self-service registration form used on the public site.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    for field in self.fields.values():\n        existing = field.widget.attrs.get(\"class\", \"\")\n        field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm.clean","title":"<code>clean()</code>","text":"<p>Validate that passwords match and meet strength requirements.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate that passwords match and meet strength requirements.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 != password2:\n        raise forms.ValidationError(\"Passwords do not match.\")\n    if password1:\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.PublicUserCreateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Create an inactive user pending admin approval.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Create an inactive user pending admin approval.\"\"\"\n    user = super().save(commit=False)\n    user.is_active = False\n    user.is_staff = False\n    user.set_password(self.cleaned_data[\"password1\"])\n    if commit:\n        user.save()\n    return user\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.RoastProfileForm","title":"<code>RoastProfileForm(*args, ingredient=None, **kwargs)</code>","text":"<p>               Bases: <code>Form</code></p> <p>Supplemental form for roast bag metadata.</p> <p>Prefill defaults from an existing RoastProfile (if any).</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, ingredient: Ingredient | None = None, **kwargs):\n    \"\"\"Prefill defaults from an existing RoastProfile (if any).\"\"\"\n    super().__init__(*args, **kwargs)\n    profile = None\n    if ingredient:\n        try:\n            profile = ingredient.roastprofile\n        except RoastProfile.DoesNotExist:\n            profile = None\n\n    if not self.is_bound:\n        self.initial.setdefault(\n            \"bag_size\",\n            profile.bag_size if profile else RoastProfile._meta.get_field(\"bag_size\").get_default(),\n        )\n        self.initial.setdefault(\n            \"grind\",\n            profile.grind if profile else RoastProfile._meta.get_field(\"grind\").get_default(),\n        )\n\n    for field in self.fields.values():\n        existing = field.widget.attrs.get(\"class\", \"\")\n        field.widget.attrs[\"class\"] = f\"{existing} form-select\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm","title":"<code>UserCreateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Internal admin form for provisioning a new Django user.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.fields[\"groups\"].queryset = Group.objects.order_by(\"name\")\n    if \"is_active\" in self.fields:\n        self.fields[\"is_active\"].initial = True\n    for name, field in self.fields.items():\n        if name == \"groups\":\n            continue\n        existing = field.widget.attrs.get(\"class\", \"\")\n        if isinstance(field.widget, forms.CheckboxInput):\n            field.widget.attrs[\"class\"] = f\"{existing} form-check-input\".strip()\n        else:\n            field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm.clean","title":"<code>clean()</code>","text":"<p>Validate matching passwords and run Django's password validators.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate matching passwords and run Django's password validators.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 != password2:\n        raise forms.ValidationError(\"Passwords do not match.\")\n    if password1:\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserCreateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Persist the user with the provided password.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Persist the user with the provided password.\"\"\"\n    user = super().save(commit=False)\n    user.set_password(self.cleaned_data[\"password1\"])\n    if commit:\n        user.save()\n        self.save_m2m()\n    return user\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm","title":"<code>UserUpdateForm(*args, **kwargs)</code>","text":"<p>               Bases: <code>ModelForm</code></p> <p>Admin form for updating an existing Django user.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.fields[\"groups\"].queryset = Group.objects.order_by(\"name\")\n    for name, field in self.fields.items():\n        if name == \"groups\":\n            continue\n        existing = field.widget.attrs.get(\"class\", \"\")\n        if isinstance(field.widget, forms.CheckboxInput):\n            field.widget.attrs[\"class\"] = f\"{existing} form-check-input\".strip()\n        else:\n            field.widget.attrs[\"class\"] = f\"{existing} form-control\".strip()\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm.clean","title":"<code>clean()</code>","text":"<p>Validate optional password change fields.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def clean(self):\n    \"\"\"Validate optional password change fields.\"\"\"\n    cleaned = super().clean()\n    password1 = cleaned.get(\"password1\")\n    password2 = cleaned.get(\"password2\")\n    if password1 or password2:\n        if password1 != password2:\n            raise forms.ValidationError(\"Passwords do not match.\")\n        try:\n            password_validation.validate_password(password1, self.instance)\n        except forms.ValidationError as exc:\n            self.add_error(\"password1\", exc)\n    return cleaned\n</code></pre>"},{"location":"16_API/forms/#mscrInventory.forms.UserUpdateForm.save","title":"<code>save(commit=True)</code>","text":"<p>Update user details and optionally reset the password.</p> Source code in <code>mscrInventory/forms.py</code> <pre><code>def save(self, commit=True):\n    \"\"\"Update user details and optionally reset the password.\"\"\"\n    user = super().save(commit=False)\n    password = self.cleaned_data.get(\"password1\")\n    if password:\n        user.set_password(password)\n    if commit:\n        user.save()\n        self.save_m2m()\n    return user\n</code></pre>"},{"location":"16_API/importers/","title":"Importers API","text":"<p>import docs.django_setup </p> <p>Importer package housing Square and Shopify ingestion logic.</p>"},{"location":"16_API/importers/#importers.ShopifyImporter","title":"<code>ShopifyImporter(*, dry_run=False, log_to_console=True, report=False, report_dir=None)</code>","text":"<p>               Bases: <code>BaseImporter</code></p> <p>Importer that fetches and persists Shopify orders.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def __init__(\n    self,\n    *,\n    dry_run: bool = False,\n    log_to_console: bool = True,\n    report: bool = False,\n    report_dir: str | None = None,\n):\n    super().__init__(\n        dry_run=dry_run,\n        log_to_console=log_to_console,\n        report=report,\n        report_dir=report_dir,\n    )\n    self.usage_totals: dict[int, Decimal] = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_breakdown: dict[int, dict[str, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self._retail_bag_product: Product | None = None\n    self.counters.setdefault(\"matched\", 0)\n\n    self._bag_weight_cache: dict[str, Decimal] = {\n        \"3oz\": Decimal(\"3\"),\n        \"11oz\": Decimal(\"11\"),\n        \"20oz\": Decimal(\"20\"),\n        \"5lb\": Decimal(\"80\"),\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.get_usage_breakdown","title":"<code>get_usage_breakdown()</code>","text":"<p>Return a copy of the usage breakdown keyed by ingredient name.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def get_usage_breakdown(self) -&gt; dict[str, dict[str, Decimal]]:\n    \"\"\"Return a copy of the usage breakdown keyed by ingredient name.\"\"\"\n\n    result: dict[str, dict[str, Decimal]] = {}\n    for ingredient_id, per_source in self.usage_breakdown.items():\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        result[name] = dict(per_source)\n    return result\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.import_window","title":"<code>import_window(start_utc, end_utc, *, orders=None)</code>","text":"<p>Import Shopify orders for the provided UTC window.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def import_window(\n    self,\n    start_utc: dt.datetime,\n    end_utc: dt.datetime,\n    *,\n    orders: Iterable[dict[str, Any]] | None = None,\n) -&gt; dict[int, Decimal]:\n    \"\"\"Import Shopify orders for the provided UTC window.\"\"\"\n\n    if start_utc.tzinfo is None or end_utc.tzinfo is None:\n        raise ValueError(\"start_utc and end_utc must be timezone-aware\")\n\n    if orders is None:\n        orders = self._fetch_orders(start_utc, end_utc)\n\n    self.log(\n        f\"Processing Shopify orders between {start_utc.isoformat()} and {end_utc.isoformat()}\",\n        \"\ud83d\ude9a\",\n    )\n\n    with transaction.atomic():\n        for raw_order in orders:\n            self.process_row(raw_order)\n\n    self.log_usage_breakdown()\n\n    self.summarize()\n    return dict(self.usage_totals)\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.log_usage_breakdown","title":"<code>log_usage_breakdown()</code>","text":"<p>Log a human-readable breakdown of ingredient usage per source.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def log_usage_breakdown(self) -&gt; None:\n    \"\"\"Log a human-readable breakdown of ingredient usage per source.\"\"\"\n    if not self.usage_totals:\n        return\n    lines = [\"Ingredient usage breakdown:\"]\n    for ingredient_id, total_qty in sorted(self.usage_totals.items(), key=lambda item: item[0]):\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        lines.append(f\"- {name}: {_format_decimal(total_qty)} total\")\n        breakdown = self.usage_breakdown.get(ingredient_id, {})\n        for source, qty in sorted(breakdown.items(), key=lambda item: item[0]):\n            lines.append(f\"    \u2022 {source}: {_format_decimal(qty)}\")\n    message = \"\\n\".join(lines)\n    self.log(message, \"\ud83d\udce6\")\n</code></pre>"},{"location":"16_API/importers/#importers.ShopifyImporter.process_row","title":"<code>process_row(raw_order)</code>","text":"<p>Normalize and persist a single Shopify order.</p> Source code in <code>importers/shopify_importer.py</code> <pre><code>def process_row(self, raw_order: dict[str, Any]) -&gt; None:  # type: ignore[override]\n    \"\"\"Normalize and persist a single Shopify order.\"\"\"\n\n    normalized = self._normalize_order(raw_order)\n    order_id = normalized[\"order_id\"]\n    line_items = normalized[\"items\"]\n\n    self.log(\n        f\"Order {order_id}: {len(line_items)} line item(s) totalling {normalized['total_amount']}\",\n        \"\ud83e\uddfe\",\n    )\n\n    order_lookup = {\"order_id\": order_id, \"platform\": self.platform}\n    defaults = {\n        \"order_date\": normalized[\"order_date\"],\n        \"total_amount\": normalized[\"total_amount\"],\n        \"data_raw\": _json_safe(normalized[\"raw\"]),\n        \"synced_at\": timezone.now(),\n    }\n\n    order_obj, created = self.create_or_update(Order, order_lookup, defaults)\n\n    if self.dry_run:\n        action = \"Would create\" if created else \"Would update\"\n        self.log(f\"\ud83e\uddea {action} {len(line_items)} order item(s) for {order_id}\")\n    else:\n        order_obj.items.all().delete()\n\n    for item in line_items:\n        product = item.get(\"product\")\n        if not product:\n            self.counters[\"unmapped\"] += 1\n            self.log(\n                f\"\u26a0\ufe0f  Unmapped Shopify item '{item.get('title')}' (SKU: {item.get('sku')})\",\n                \"\u26a0\ufe0f\",\n            )\n        else:\n            self.counters[\"matched\"] = self.counters.get(\"matched\", 0) + 1\n\n        quantity = item.get(\"quantity\", 0)\n        if self.dry_run:\n            self.log(\n                f\"\ud83e\uddea Would record {quantity}x {item.get('title')} (product={'mapped' if product else 'missing'})\",\n                \"\ud83e\uddea\",\n            )\n        else:\n            variant_payload = _json_safe(item.get(\"variant_info\", {}))\n            if quantity &gt; 0:\n                OrderItem.objects.create(\n                    order=order_obj,\n                    product=product,\n                    quantity=quantity,\n                    unit_price=item[\"unit_price\"],\n                    variant_info=variant_payload,\n                )\n\n        self._track_usage_from_item(item)\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter","title":"<code>SquareImporter(dry_run=False)</code>","text":"<p>Handles parsing and importing Square CSV exports.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def __init__(self, dry_run: bool = False):\n    self.dry_run = dry_run\n    self.buffer: list[str] = []\n    self.stats = {\n        \"rows_processed\": 0,\n        \"matched\": 0,\n        \"unmatched\": 0,\n        \"order_items_logged\": 0,\n        \"modifiers_applied\": 0,\n        \"errors\": 0,\n    }\n    self._summary_added = False\n    self._summary_cache: list[str] | None = None\n    self._last_run_started: datetime | None = None\n    self._last_run_finished: datetime | None = None\n    self._current_order: Order | None = None\n    self._orders_by_transaction: dict[str, Order | None] = {}\n    self._unmapped_seen_keys: set[tuple[str, str, str]] = set()\n    self.usage_totals: defaultdict[int, Decimal] = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_breakdown: defaultdict[int, defaultdict[str, Decimal]] = defaultdict(\n        lambda: defaultdict(lambda: Decimal(\"0\"))\n    )\n    self._ingredient_cache: dict[str, Ingredient | None] = {}\n    self._normalized_modifier_names: set[str] | None = None\n    self._normalized_ingredient_names: set[str] | None = None\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_output","title":"<code>get_output()</code>","text":"<p>Return concatenated importer log output.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_output(self) -&gt; str:\n    \"\"\"Return concatenated importer log output.\"\"\"\n    \"\"\"Return the collected log as a single string.\"\"\"\n    return \"\\n\".join(self.buffer)\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_run_metadata","title":"<code>get_run_metadata()</code>","text":"<p>Expose structured metadata about the previous run.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_run_metadata(self) -&gt; dict:\n    \"\"\"Expose structured metadata about the previous run.\"\"\"\n    \"\"\"Return structured metadata about the most recent run.\"\"\"\n    stats = dict(self.stats)\n    started_at = self._last_run_started\n    finished_at = self._last_run_finished\n    duration = None\n    if started_at and finished_at:\n        duration = (finished_at - started_at).total_seconds()\n\n    return {\n        \"started_at\": started_at,\n        \"finished_at\": finished_at,\n        \"duration_seconds\": duration,\n        \"stats\": stats,\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_summary","title":"<code>get_summary()</code>","text":"<p>Return the formatted summary for display (without mutating twice).</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_summary(self) -&gt; str:\n    \"\"\"Return the formatted summary for display (without mutating twice).\"\"\"\n    return self.summarize()\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_usage_breakdown","title":"<code>get_usage_breakdown()</code>","text":"<p>Return ingredient usage grouped by ingredient name and source label.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_usage_breakdown(self) -&gt; dict[str, dict[str, Decimal]]:\n    \"\"\"Return ingredient usage grouped by ingredient name and source label.\"\"\"\n    result: dict[str, dict[str, Decimal]] = {}\n    for ingredient_id, per_source in self.usage_breakdown.items():\n        ingredient = Ingredient.objects.filter(id=ingredient_id).first()\n        name = ingredient.name if ingredient else f\"Ingredient #{ingredient_id}\"\n        result[name] = dict(per_source)\n    return result\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.get_usage_totals","title":"<code>get_usage_totals()</code>","text":"<p>Expose aggregated ingredient usage totals keyed by id.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def get_usage_totals(self) -&gt; dict[int, Decimal]:\n    \"\"\"Expose aggregated ingredient usage totals keyed by id.\"\"\"\n    return {\n        ingredient_id: qty\n        for ingredient_id, qty in self.usage_totals.items()\n        if qty &gt; 0\n    }\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.run_from_file","title":"<code>run_from_file(file_path)</code>","text":"<p>Run import from a given CSV file.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def run_from_file(self, file_path: Path):\n    \"\"\"Run import from a given CSV file.\"\"\"\n    self.buffer = []\n    self.stats = {\n        \"rows_processed\": 0,\n        \"matched\": 0,\n        \"unmatched\": 0,\n        \"order_items_logged\": 0,\n        \"modifiers_applied\": 0,\n        \"errors\": 0,\n    }\n    self.usage_totals = defaultdict(lambda: Decimal(\"0\"))\n    self.usage_breakdown = defaultdict(lambda: defaultdict(lambda: Decimal(\"0\")))\n    self._ingredient_cache = {}\n    start_time = timezone.now()\n    self._last_run_started = start_time\n    self._summary_added = False\n    self._summary_cache = None\n    self._unmapped_seen_keys = set()\n    self._orders_by_transaction = {}\n    self.buffer.append(\n        f\"\ud83d\udce5 Importing {file_path.name} ({'dry-run' if self.dry_run else 'live'})\"\n    )\n\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File not found: {file_path}\")\n\n    context = nullcontext() if self.dry_run else transaction.atomic()\n\n    with context:\n        if not self.dry_run:\n            self._current_order = None\n        with open(file_path, newline=\"\", encoding=\"utf-8-sig\") as csvfile:\n            reader = csv.DictReader(csvfile)\n            for row in reader:\n                self._process_row(row, file_path=file_path)\n\n        self.summarize()\n\n        if self.dry_run:\n            self._current_order = None\n\n    self._last_run_finished = timezone.now()\n    self._current_order = None\n    return self.get_output()\n</code></pre>"},{"location":"16_API/importers/#importers.SquareImporter.summarize","title":"<code>summarize()</code>","text":"<p>Generate and cache a run summary with timing and counts.</p> Source code in <code>importers/square_importer.py</code> <pre><code>def summarize(self):\n    \"\"\"Generate and cache a run summary with timing and counts.\"\"\"\n    if self._summary_added and self._summary_cache is not None:\n        return \"\\n\".join(self._summary_cache)\n\n    start_time = self._last_run_started or timezone.now()\n    end_time = self._last_run_finished or timezone.now()\n    elapsed = (end_time - start_time).total_seconds()\n\n    summary_lines = [\n        \"\",\n        \"\ud83d\udcca Square Import Summary\",\n        f\"Started: {start_time:%Y-%m-%d %H:%M:%S}\",\n        f\"Elapsed: {elapsed:.2f}s\",\n        \"\",\n        f\"\ud83e\uddfe Rows processed: {self.stats['rows_processed']}\",\n        f\"\u2705 Products matched: {self.stats['matched']}\",\n        f\"\u26a0\ufe0f Unmatched items: {self.stats['unmatched']}\",\n        f\"\ud83e\uddfa Order items logged: {self.stats['order_items_logged']}\",\n        f\"\ud83e\udde9 Modifiers applied: {self.stats['modifiers_applied']}\",\n        f\"\u274c Errors: {self.stats['errors']}\",\n        \"\u2705 Dry-run complete.\" if self.dry_run else \"\u2705 Import complete.\",\n    ]\n\n    self.buffer.extend(summary_lines)\n    self._summary_added = True\n    self._summary_cache = summary_lines\n    return \"\\n\".join(summary_lines)\n</code></pre>"},{"location":"16_API/management_commands/","title":"Management Commands API","text":"<p>import docs.django_setup </p>"},{"location":"16_API/models/","title":"Models API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized </p> <p>Database models that power inventory, ordering, and import workflows.</p>"},{"location":"16_API/models/#mscrInventory.models.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>Model</code></p> <p>Simple taxonomy bucket for grouping Products.</p>"},{"location":"16_API/models/#mscrInventory.models.ContainerType","title":"<code>ContainerType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Reusable container description for packaging selections.</p>"},{"location":"16_API/models/#mscrInventory.models.ImportLog","title":"<code>ImportLog</code>","text":"<p>               Bases: <code>Model</code></p> <p>Tracks file-based or API imports, counts, and outcomes.</p>"},{"location":"16_API/models/#mscrInventory.models.Ingredient","title":"<code>Ingredient</code>","text":"<p>               Bases: <code>Model</code></p> <p>Inventory tracked item with measurement, costing, and notes.</p>"},{"location":"16_API/models/#mscrInventory.models.Ingredient.decrement_stock","title":"<code>decrement_stock(quantity)</code>","text":"<p>Decrease stock by quantity. Does NOT recalculate cost. Should be called in transaction when logging usage.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def decrement_stock(self, quantity: Decimal):\n    \"\"\"\n    Decrease stock by quantity. Does NOT recalculate cost.\n    Should be called in transaction when logging usage.\n    \"\"\"\n    new_stock = (Decimal(self.current_stock or 0) - Decimal(quantity))\n    # Allow negatives (so we can see overuse), but you might want to block it.\n    self.current_stock = new_stock.quantize(Decimal(\"0.000\"))\n    self.save(update_fields=[\"current_stock\", \"last_updated\"])\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.Ingredient.increment_stock","title":"<code>increment_stock(quantity, cost_per_unit)</code>","text":"<p>Increase stock and recalculate weighted average cost. Called by StockEntry.save() inside a transaction.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def increment_stock(self, quantity: Decimal, cost_per_unit: Decimal):\n    \"\"\"\n    Increase stock and recalculate weighted average cost.\n    Called by StockEntry.save() inside a transaction.\n    \"\"\"\n    if quantity &lt;= 0:\n        return\n\n    old_stock = Decimal(self.current_stock or 0)\n    old_cost = Decimal(self.average_cost_per_unit or 0)\n    new_stock = Decimal(quantity)\n    new_cost = Decimal(cost_per_unit)\n\n    total_qty = old_stock + new_stock\n    if total_qty &gt; 0:\n        weighted_avg = ((old_stock * old_cost) + (new_stock * new_cost)) / total_qty\n    else:\n        weighted_avg = new_cost\n\n    self.average_cost_per_unit = weighted_avg.quantize(Decimal(\"0.000001\"))\n    self.current_stock = total_qty.quantize(Decimal(\"0.000\"))\n    self.save(update_fields=[\"average_cost_per_unit\", \"current_stock\", \"last_updated\"])\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.IngredientType","title":"<code>IngredientType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Labels ingredients into logical families (roasts, packaging, etc.).</p>"},{"location":"16_API/models/#mscrInventory.models.IngredientUsageLog","title":"<code>IngredientUsageLog</code>","text":"<p>               Bases: <code>Model</code></p> <p>Log of ingredient usage per date. Typically created by the sync process that consumes OrderItems+RecipeItems and aggregates by ingredient.</p>"},{"location":"16_API/models/#mscrInventory.models.IngredientUsageLog.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>On create, decrement ingredient.current_stock. If updating an existing record, compute delta and apply difference.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def save(self, *args, **kwargs):\n    \"\"\"\n    On create, decrement ingredient.current_stock.\n    If updating an existing record, compute delta and apply difference.\n    \"\"\"\n    with transaction.atomic():\n        if self.pk:\n            # existing; compute delta\n            old = IngredientUsageLog.objects.select_for_update().get(pk=self.pk)\n            delta = Decimal(self.quantity_used) - Decimal(old.quantity_used)\n            super().save(*args, **kwargs)\n            if delta != 0:\n                # positive delta =&gt; additional consumption\n                self.ingredient.decrement_stock(delta)\n        else:\n            super().save(*args, **kwargs)\n            # new usage -&gt; decrement the stock by the full amount\n            self.ingredient.decrement_stock(Decimal(self.quantity_used))\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.ModifierBehavior","title":"<code>ModifierBehavior</code>","text":"<p>               Bases: <code>TextChoices</code></p> <p>Normalized operations for manipulating recipe ingredients.</p>"},{"location":"16_API/models/#mscrInventory.models.Order","title":"<code>Order</code>","text":"<p>               Bases: <code>Model</code></p> <p>High-level order pulled from connected commerce platforms.</p>"},{"location":"16_API/models/#mscrInventory.models.OrderItem","title":"<code>OrderItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Line item belonging to an Order, optionally linked to a Product.</p>"},{"location":"16_API/models/#mscrInventory.models.Packaging","title":"<code>Packaging</code>","text":"<p>               Bases: <code>Ingredient</code></p> <p>Ingredient subtype for cups, lids, and other packaging combos.</p>"},{"location":"16_API/models/#mscrInventory.models.Product","title":"<code>Product</code>","text":"<p>               Bases: <code>Model</code></p> <p>Sellable menu item that links recipes, modifiers, and POS identifiers.</p>"},{"location":"16_API/models/#mscrInventory.models.Product.calculated_cogs","title":"<code>calculated_cogs</code>  <code>property</code>","text":"<p>Returns total cost of goods sold for this product, based on linked ingredients and their average cost.</p>"},{"location":"16_API/models/#mscrInventory.models.ProductVariantCache","title":"<code>ProductVariantCache</code>","text":"<p>               Bases: <code>Model</code></p> <p>Normalized variant metadata learned from POS imports.</p>"},{"location":"16_API/models/#mscrInventory.models.RecipeItem","title":"<code>RecipeItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Represents a single ingredient entry within a product's recipe.</p> <p>Each RecipeItem links one Product to one Ingredient, with a specific quantity, unit, and optional cost/price data. Together, all RecipeItems for a Product define that product's complete recipe and cost-of-goods basis.</p> Example <p>Latte  \u2192  [ (Espresso Shot, 1 unit), (Milk, 8 oz), (Foam, 1 unit) ]</p>"},{"location":"16_API/models/#mscrInventory.models.RecipeModifier","title":"<code>RecipeModifier</code>","text":"<p>               Bases: <code>Model</code></p> <p>Modifiers are extensions of Ingredients (e.g. milk options, syrups, extra shots). Each links to a base Ingredient but may have its own cost, price, and behavior.</p> Extended behavior system <ul> <li>behavior: ADD, REPLACE, SCALE</li> <li>quantity_factor: scaling multiplier (replaces size_multiplier)</li> <li>target_selector: defines which ingredients to target (by type/name)</li> <li>replaces: specifies replacements for REPLACE behavior</li> </ul>"},{"location":"16_API/models/#mscrInventory.models.RecipeModifierAlias","title":"<code>RecipeModifierAlias</code>","text":"<p>               Bases: <code>Model</code></p> <p>Maps raw order modifiers to the normalized RecipeModifier.</p>"},{"location":"16_API/models/#mscrInventory.models.RoastProfile","title":"<code>RoastProfile</code>","text":"<p>               Bases: <code>Ingredient</code></p> <p>Retail coffee bag metadata tied to a roast ingredient.</p>"},{"location":"16_API/models/#mscrInventory.models.SizeLabel","title":"<code>SizeLabel</code>","text":"<p>               Bases: <code>Model</code></p> <p>Named portion sizes used when presenting packaging choices.</p>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem","title":"<code>SquareUnmappedItem</code>","text":"<p>               Bases: <code>Model</code></p> <p>Tracks Square rows that could not be resolved to an internal mapping.</p>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem.mark_resolved","title":"<code>mark_resolved(*, user=None, ignored=False, product=None, ingredient=None, modifier=None, note=None)</code>","text":"<p>Mark the item as resolved and optionally link an existing record.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def mark_resolved(\n    self,\n    *,\n    user=None,\n    ignored: bool = False,\n    product: Optional[\"Product\"] = None,\n    ingredient: Optional[\"Ingredient\"] = None,\n    modifier: Optional[\"RecipeModifier\"] = None,\n    note: str | None = None,\n) -&gt; None:\n    \"\"\"Mark the item as resolved and optionally link an existing record.\"\"\"\n\n    update_fields = {\"resolved\", \"ignored\", \"resolved_at\"}\n\n    self.resolved = not ignored\n    self.ignored = ignored\n    self.resolved_at = timezone.now()\n    self.resolved_by = user\n    update_fields.add(\"resolved_by\")\n\n    if self.item_type == \"product\":\n        self.linked_product = product\n    else:\n        self.linked_product = None\n    update_fields.add(\"linked_product\")\n\n    if self.item_type == \"ingredient\":\n        self.linked_ingredient = ingredient\n    else:\n        self.linked_ingredient = None\n    update_fields.add(\"linked_ingredient\")\n\n    if self.item_type == \"modifier\":\n        self.linked_modifier = modifier\n    else:\n        self.linked_modifier = None\n    update_fields.add(\"linked_modifier\")\n\n    if note is not None:\n        self.item_note = note\n        update_fields.add(\"item_note\")\n\n    self.save(update_fields=list(update_fields))\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.SquareUnmappedItem.reopen","title":"<code>reopen()</code>","text":"<p>Reopen an item for review.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def reopen(self) -&gt; None:\n    \"\"\"Reopen an item for review.\"\"\"\n\n    self.resolved = False\n    self.ignored = False\n    self.resolved_at = None\n    self.resolved_by = None\n    self.linked_product = None\n    self.linked_ingredient = None\n    self.linked_modifier = None\n    self.save(\n        update_fields=[\n            \"resolved\",\n            \"ignored\",\n            \"resolved_at\",\n            \"resolved_by\",\n            \"linked_product\",\n            \"linked_ingredient\",\n            \"linked_modifier\",\n        ]\n    )\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.StockEntry","title":"<code>StockEntry</code>","text":"<p>               Bases: <code>Model</code></p> <p>Represents a restock event that updates weighted average cost.</p>"},{"location":"16_API/models/#mscrInventory.models.StockEntry.save","title":"<code>save(*args, **kwargs)</code>","text":"<p>On save, update ingredient's stock and weighted average cost. If this is an update (existing pk), behavior is naive: we handle only create. For production, handle edits/deletes explicitly (reverse previous effect).</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def save(self, *args, **kwargs):\n    \"\"\"\n    On save, update ingredient's stock and weighted average cost.\n    If this is an update (existing pk), behavior is naive: we handle only create.\n    For production, handle edits/deletes explicitly (reverse previous effect).\n    \"\"\"\n    is_create = self.pk is None\n    with transaction.atomic():\n        super().save(*args, **kwargs)\n        if is_create and self.quantity_added and self.cost_per_unit is not None:\n            # Update Ingredient aggregate fields\n            self.ingredient.increment_stock(self.quantity_added, self.cost_per_unit)\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.UnitType","title":"<code>UnitType</code>","text":"<p>               Bases: <code>Model</code></p> <p>Measurement definition with a conversion ratio to a base unit.</p>"},{"location":"16_API/models/#mscrInventory.models.ensure_roast_profile","title":"<code>ensure_roast_profile(sender, instance, created, **kwargs)</code>","text":"<p>Ensure roast ingredients always have an attached RoastProfile.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>@receiver(post_save, sender=Ingredient)\ndef ensure_roast_profile(sender, instance, created, **kwargs):\n    \"\"\"Ensure roast ingredients always have an attached RoastProfile.\"\"\"\n\n    roast_type = IngredientType.objects.filter(name__iexact=\"roasts\").first()\n    has_roast_type = bool(roast_type and instance.type_id == roast_type.id)\n    try:\n        profile = instance.roastprofile\n    except RoastProfile.DoesNotExist:\n        profile = None\n\n    if has_roast_type and profile is None:\n        get_or_create_roast_profile(instance)\n    elif not has_roast_type and profile is not None:\n        profile.delete()\n</code></pre>"},{"location":"16_API/models/#mscrInventory.models.get_or_create_roast_profile","title":"<code>get_or_create_roast_profile(ingredient)</code>","text":"<p>Return the roast profile for an ingredient, creating it if needed.</p> Source code in <code>mscrInventory/models.py</code> <pre><code>def get_or_create_roast_profile(ingredient: \"Ingredient\") -&gt; RoastProfile | None:\n    \"\"\"Return the roast profile for an ingredient, creating it if needed.\"\"\"\n\n    if ingredient is None:\n        return None\n\n    if ingredient.pk is None:\n        return None\n\n    try:\n        return ingredient.roastprofile\n    except RoastProfile.DoesNotExist:\n        pass\n\n    defaults = {\n        \"bag_size\": RoastProfile._meta.get_field(\"bag_size\").get_default(),\n        \"grind\": RoastProfile._meta.get_field(\"grind\").get_default(),\n    }\n\n    table_name = connection.ops.quote_name(RoastProfile._meta.db_table)\n    parent_column = connection.ops.quote_name(\n        RoastProfile._meta.get_field(\"ingredient_ptr\").column\n    )\n    bag_column = connection.ops.quote_name(RoastProfile._meta.get_field(\"bag_size\").column)\n    grind_column = connection.ops.quote_name(RoastProfile._meta.get_field(\"grind\").column)\n\n    with transaction.atomic():\n        with connection.cursor() as cursor:\n            try:\n                cursor.execute(\n                    f\"INSERT INTO {table_name} ({parent_column}, {bag_column}, {grind_column}) \"\n                    \"VALUES (%s, %s, %s)\",\n                    [ingredient.pk, defaults[\"bag_size\"], defaults[\"grind\"]],\n                )\n            except IntegrityError:\n                # Another transaction created the profile first; fetch below.\n                pass\n\n    try:\n        return RoastProfile.objects.get(pk=ingredient.pk)\n    except RoastProfile.DoesNotExist:\n        return None\n</code></pre>"},{"location":"16_API/utils/","title":"Utilities API","text":"<p>import docs.django_setup </p> <p>Utility helpers for dashboards, reports, and modifier analysis.</p>"},{"location":"16_API/views/","title":"Views API Reference","text":"<p>import docs.django_setup  # ensures Django is initialized </p> <p>Collection of Django views grouped by feature area (inventory, orders, etc.).</p>"}]}